<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8">
<meta name="viewport" content="initial-scale=1">
<title>Sankey Diagram Builder</title>
<link rel="stylesheet" href="build.css?v=4">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&family=Manrope:wght@200..800&display=swap" rel="stylesheet">
<!-- Core dependencies -->
<script defer src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/canvg@3/lib/umd.js" crossorigin="anonymous"></script>
<!-- SankeyMATIC core -->
<script defer src="constants.js?v=4"></script>
<script defer src="sankey.js?v=4"></script>
<script defer src="lz-string.min.js?v=4"></script>
<script defer src="color_palettes.js?v=4"></script>
<script defer src="templates.js?v=4"></script>
<script defer src="sankeymatic.js?v=4"></script>
<style>
* { box-sizing: border-box; }
body { margin: 0; font-family: 'Inter', 'Manrope', sans-serif; font-size: 13px; background: #f5f5f5; }

.app-container { display: flex; flex-direction: column; height: 100vh; overflow: hidden; }

/* Menu Bar */
.menu-bar {
  display: flex;
  background: #fff;
  border-bottom: 1px solid #e0e0e0;
  padding: 0;
  align-items: center;
  height: 40px;
  flex-shrink: 0;
}

.menu-item {
  position: relative;
  padding: 10px 16px;
  cursor: pointer;
  font-size: 13px;
  color: #333;
  border: none;
  background: none;
  font-family: inherit;
  height: 100%;
  display: flex;
  align-items: center;
}

.menu-item:hover { background: #f0f0f0; }

.menu-dropdown {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  background: #fff;
  border: 1px solid #e0e0e0;
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  min-width: 280px;
  z-index: 1000;
  max-height: 80vh;
  overflow-y: auto;
}

.menu-item:hover .menu-dropdown { display: block; }

.menu-section-title {
  padding: 8px 16px;
  font-weight: 600;
  color: #666;
  background: #f8f8f8;
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.menu-dropdown-item {
  display: flex;
  align-items: center;
  padding: 8px 16px;
  cursor: pointer;
  font-size: 13px;
  gap: 8px;
}

.menu-dropdown-item:hover { background: #f5f5f5; }
.menu-dropdown-item input[type="checkbox"] { margin: 0; }
.menu-dropdown-item input[type="number"], 
.menu-dropdown-item input[type="text"],
.menu-dropdown-item select {
  padding: 4px 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 12px;
}
.menu-dropdown-item input[type="color"] { width: 30px; height: 24px; padding: 0; border: 1px solid #ddd; }
.menu-dropdown-item label { flex: 1; }
.menu-divider { height: 1px; background: #e0e0e0; margin: 4px 0; }

.menu-spacer { flex: 1; }

.menu-btn {
  padding: 6px 12px;
  margin: 0 8px;
  background: #1a73e8;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
}
.menu-btn:hover { background: #1557b0; }
.menu-btn.secondary { background: #f1f3f4; color: #333; }
.menu-btn.secondary:hover { background: #e8eaed; }

/* Main Content */
.main-content { display: flex; flex: 1; overflow: hidden; }

/* Diagram Panel */
.diagram-panel {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: #fff;
  overflow: hidden;
}

.diagram-title-bar {
  padding: 12px 20px;
  border-bottom: 1px solid #e0e0e0;
  background: #fafafa;
}

.diagram-title-input {
  border: none;
  font-size: 20px;
  font-weight: 600;
  width: 100%;
  background: transparent;
  text-align: center;
}
.diagram-title-input:focus { outline: 2px solid #1a73e8; border-radius: 4px; }

.diagram-area {
  flex: 1;
  display: flex;
  justify-content: center;
  align-items: center;
  overflow: auto;
  padding: 20px;
  background: #fff;
}

#chart_container { position: relative; }

.diagram-footer {
  padding: 8px 20px;
  text-align: center;
  font-size: 11px;
  color: #999;
  border-top: 1px solid #e0e0e0;
  background: #fafafa;
}

/* Right Panel - WIDER */
.right-panel {
  width: 480px;
  min-width: 480px;
  border-left: 1px solid #e0e0e0;
  display: flex;
  flex-direction: column;
  background: #fff;
  overflow: hidden;
}

.panel-header {
  padding: 12px 16px;
  font-weight: 600;
  font-size: 14px;
  background: #f8f9fa;
  border-bottom: 1px solid #e0e0e0;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.panel-header-actions { display: flex; gap: 8px; }
.panel-header-actions button {
  padding: 4px 10px;
  font-size: 11px;
  border: 1px solid #ddd;
  background: #fff;
  border-radius: 4px;
  cursor: pointer;
}
.panel-header-actions button:hover { background: #f5f5f5; }

/* Data Table */
.data-table-wrapper { flex: 1; overflow: auto; }

.data-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 12px;
}

.data-table th {
  background: #f1f3f4;
  padding: 10px 8px;
  text-align: left;
  font-weight: 500;
  color: #5f6368;
  border-bottom: 1px solid #e0e0e0;
  position: sticky;
  top: 0;
  z-index: 10;
}

.data-table td {
  padding: 4px;
  border-bottom: 1px solid #f0f0f0;
}

.data-table input {
  width: 100%;
  border: 1px solid transparent;
  padding: 6px 8px;
  font-size: 12px;
  background: transparent;
  border-radius: 4px;
}

.data-table input:focus {
  border-color: #1a73e8;
  outline: none;
  background: #fff;
}

.data-table .delete-btn {
  color: #dc3545;
  cursor: pointer;
  padding: 4px 8px;
  border: none;
  background: none;
  font-size: 16px;
}
.data-table .delete-btn:hover { background: #fee; border-radius: 4px; }

.add-row-section {
  padding: 12px 16px;
  border-top: 1px solid #e0e0e0;
  display: flex;
  align-items: center;
  gap: 8px;
  background: #fafafa;
}

.add-row-btn {
  padding: 6px 12px;
  border: 1px solid #ddd;
  background: #fff;
  cursor: pointer;
  font-size: 12px;
  border-radius: 4px;
  display: flex;
  align-items: center;
  gap: 4px;
}
.add-row-btn:hover { background: #f5f5f5; }

/* AI Chat Section */
.ai-section {
  border-top: 1px solid #e0e0e0;
  background: #f8f9fa;
}

.ai-section-header {
  padding: 12px 16px;
  font-weight: 600;
  font-size: 13px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-bottom: 1px solid #e0e0e0;
  background: #fff;
}

.ai-settings-btn {
  padding: 4px 8px;
  background: none;
  border: 1px solid #ddd;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
}
.ai-settings-btn:hover { background: #f5f5f5; }

.ai-chat-area { padding: 12px 16px; }

.ai-chat-input-wrapper {
  display: flex;
  gap: 8px;
  margin-bottom: 8px;
}

.ai-chat-input {
  flex: 1;
  padding: 10px 12px;
  border: 1px solid #ddd;
  border-radius: 6px;
  font-size: 13px;
  resize: none;
  min-height: 60px;
}
.ai-chat-input:focus { outline: none; border-color: #1a73e8; }

.ai-chat-btn {
  padding: 10px 20px;
  background: #1a73e8;
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 13px;
  font-weight: 500;
  align-self: flex-end;
}
.ai-chat-btn:hover { background: #1557b0; }
.ai-chat-btn:disabled { background: #ccc; cursor: not-allowed; }

.ai-status {
  font-size: 12px;
  padding: 8px 0;
}
.ai-status.success { color: #0d6efd; }
.ai-status.error { color: #dc3545; }
.ai-status.warning { color: #fd7e14; }

/* Status Bar */
.status-bar {
  padding: 10px 20px;
  background: #e8f5e9;
  border-top: 1px solid #c8e6c9;
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: #2e7d32;
  flex-shrink: 0;
}
.status-bar.warning { background: #fff3e0; border-color: #ffe0b2; color: #e65100; }
.status-bar.error { background: #ffebee; border-color: #ffcdd2; color: #c62828; }

/* Settings Modal */
.modal-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.5);
  z-index: 2000;
  justify-content: center;
  align-items: center;
}
.modal-overlay.active { display: flex; }

.modal {
  background: #fff;
  border-radius: 12px;
  width: 500px;
  max-width: 90%;
  max-height: 90vh;
  overflow: auto;
  box-shadow: 0 8px 32px rgba(0,0,0,0.2);
}

.modal-header {
  padding: 16px 20px;
  border-bottom: 1px solid #e0e0e0;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: #fff;
}
.modal-header h3 { margin: 0; font-size: 16px; }
.modal-close { background: none; border: none; font-size: 24px; cursor: pointer; color: #666; padding: 0; line-height: 1; }

.modal-body { padding: 20px; }

.form-group { margin-bottom: 16px; }
.form-group label { display: block; margin-bottom: 6px; font-size: 13px; font-weight: 500; }
.form-group input, .form-group select, .form-group textarea {
  width: 100%;
  padding: 10px 12px;
  border: 1px solid #ddd;
  border-radius: 6px;
  font-size: 13px;
}
.form-group input:focus, .form-group select:focus, .form-group textarea:focus {
  outline: none;
  border-color: #1a73e8;
}
.form-group .hint { font-size: 11px; color: #666; margin-top: 4px; }
.form-group .hint a { color: #1a73e8; }

.modal-footer {
  padding: 16px 20px;
  border-top: 1px solid #e0e0e0;
  display: flex;
  justify-content: flex-end;
  gap: 8px;
  position: sticky;
  bottom: 0;
  background: #fff;
}

.btn {
  padding: 10px 20px;
  border-radius: 6px;
  font-size: 13px;
  cursor: pointer;
  font-weight: 500;
}
.btn-secondary { background: #f1f3f4; border: 1px solid #ddd; color: #333; }
.btn-primary { background: #1a73e8; border: 1px solid #1a73e8; color: white; }
.btn:hover { opacity: 0.9; }

/* Hide old elements */
.header, .footer, .center_basic, .skm_grid { display: none !important; }
</style>
</head>
<body>

<div class="app-container">
  <!-- Menu Bar with all sidebar features -->
  <div class="menu-bar">
    <div class="menu-item">
      File
      <div class="menu-dropdown">
        <div class="menu-dropdown-item" onclick="newDiagram()">üìÑ New Diagram</div>
        <div class="menu-dropdown-item" onclick="document.getElementById('load_file_input').click()">üìÇ Open File...</div>
        <div class="menu-dropdown-item" onclick="saveDiagramToFile()">üíæ Save As...</div>
        <div class="menu-divider"></div>
        <div class="menu-dropdown-item" onclick="saveDiagramAsPNG(2)">üñºÔ∏è Export as PNG</div>
        <div class="menu-dropdown-item" onclick="saveDiagramAsPNG(4)">üñºÔ∏è Export as PNG (Large)</div>
        <div class="menu-dropdown-item" onclick="saveDiagramAsSVG()">üìê Export as SVG</div>
      </div>
    </div>
    
    <div class="menu-item">
      Labels
      <div class="menu-dropdown">
        <div class="menu-section-title">Display</div>
        <div class="menu-dropdown-item">
          <input type="checkbox" id="opt_labelname_appears" checked onchange="updateOption()">
          <label for="opt_labelname_appears">Show Names</label>
        </div>
        <div class="menu-dropdown-item">
          <input type="checkbox" id="opt_labelvalue_appears" checked onchange="updateOption()">
          <label for="opt_labelvalue_appears">Show Values</label>
        </div>
        <div class="menu-dropdown-item">
          <input type="checkbox" id="opt_labels_comparisonline" onchange="updateOption()">
          <label for="opt_labels_comparisonline">Show Comparison %</label>
        </div>
        <div class="menu-divider"></div>
        <div class="menu-section-title">Typography</div>
        <div class="menu-dropdown-item">
          <label>Font Size</label>
          <input type="number" id="opt_labelname_size" value="16" min="8" max="36" style="width:60px" onchange="updateOption()">
        </div>
        <div class="menu-dropdown-item">
          <label>Color</label>
          <input type="color" id="opt_labels_color" value="#000000" onchange="updateOption()">
        </div>
        <div class="menu-dropdown-item">
          <label>Font</label>
          <select id="opt_labels_fontface" onchange="updateFontOption()" style="width:120px">
            <option value="sans-serif">Sans-serif</option>
            <option value="serif">Serif</option>
            <option value="monospace">Monospace</option>
          </select>
        </div>
        <div class="menu-dropdown-item">
          <label>Google Font</label>
          <select id="opt_labels_googlefont" onchange="updateOption()" style="width:120px">
            <option value="">None</option>
            <option value="Inter">Inter</option>
            <option value="Manrope">Manrope</option>
            <option value="Roboto">Roboto</option>
            <option value="Open Sans">Open Sans</option>
            <option value="Lato">Lato</option>
            <option value="Montserrat">Montserrat</option>
            <option value="Poppins">Poppins</option>
            <option value="Source Sans Pro">Source Sans Pro</option>
            <option value="Nunito">Nunito</option>
            <option value="Raleway">Raleway</option>
          </select>
        </div>
        <div class="menu-divider"></div>
        <div class="menu-section-title">Label Style</div>
        <div class="menu-dropdown-item">
          <label>Opacity %</label>
          <input type="number" id="opt_labels_opacity" value="100" min="0" max="100" style="width:60px" onchange="updateOption()">
        </div>
        <div class="menu-dropdown-item">
          <label>Alignment</label>
          <select id="opt_labels_align" onchange="updateOption()" style="width:80px">
            <option value="auto">Auto</option>
            <option value="left">Left</option>
            <option value="center">Center</option>
            <option value="right">Right</option>
          </select>
        </div>
        <div class="menu-divider"></div>
        <div class="menu-section-title">Number Format</div>
        <div class="menu-dropdown-item">
          <label>Decimal Places</label>
          <select id="opt_labels_decimalplaces" onchange="updateOption()" style="width:60px">
            <option value="0">0</option>
            <option value="1">1</option>
            <option value="2" selected>2</option>
          </select>
        </div>
        <div class="menu-dropdown-item">
          <label>Prefix</label>
          <input type="text" id="opt_value_prefix" value="" style="width:60px" onchange="updateOption()" placeholder="$">
        </div>
        <div class="menu-dropdown-item">
          <label>Suffix</label>
          <input type="text" id="opt_value_suffix" value="" style="width:60px" onchange="updateOption()">
        </div>
      </div>
    </div>
    
    <div class="menu-item">
      Nodes
      <div class="menu-dropdown">
        <div class="menu-section-title">Dimensions</div>
        <div class="menu-dropdown-item">
          <label>Width</label>
          <input type="number" id="opt_node_w" value="12" min="0" max="100" style="width:60px" onchange="updateOption()">
        </div>
        <div class="menu-dropdown-item">
          <label>Height %</label>
          <input type="number" id="opt_node_h" value="50" min="0" max="100" style="width:60px" onchange="updateOption()">
        </div>
        <div class="menu-dropdown-item">
          <label>Spacing %</label>
          <input type="number" id="opt_node_spacing" value="75" min="0" max="100" style="width:60px" onchange="updateOption()">
        </div>
        <div class="menu-dropdown-item">
          <label>Border</label>
          <input type="number" id="opt_node_border" value="0" min="0" max="10" style="width:60px" onchange="updateOption()">
        </div>
        <div class="menu-dropdown-item">
          <label>Opacity %</label>
          <input type="number" id="opt_node_opacity" value="100" min="0" max="100" style="width:60px" onchange="updateOption()">
        </div>
        <div class="menu-divider"></div>
        <div class="menu-section-title">Colors</div>
        <div class="menu-dropdown-item">
          <label>Theme</label>
          <select id="opt_node_theme" onchange="updateOption()" style="width:100px">
            <option value="a">Theme A</option>
            <option value="b">Theme B</option>
            <option value="c">Theme C</option>
            <option value="d">Theme D</option>
            <option value="none">Single Color</option>
          </select>
        </div>
        <div class="menu-dropdown-item">
          <label>Single Color</label>
          <input type="color" id="opt_node_color" value="#888888" onchange="updateOption()">
        </div>
      </div>
    </div>
    
    <div class="menu-item">
      Flows
      <div class="menu-dropdown">
        <div class="menu-section-title">Appearance</div>
        <div class="menu-dropdown-item">
          <label>Opacity %</label>
          <input type="number" id="opt_flow_opacity" value="45" min="0" max="100" style="width:60px" onchange="updateOption()">
        </div>
        <div class="menu-dropdown-item">
          <label>Curviness %</label>
          <input type="number" id="opt_flow_curvature" value="50" min="10" max="90" style="width:60px" onchange="updateOption()">
        </div>
        <div class="menu-divider"></div>
        <div class="menu-section-title">Color Source</div>
        <div class="menu-dropdown-item">
          <input type="radio" name="flow_color" id="opt_flow_outside_in" checked onchange="updateOption()">
          <label for="opt_flow_outside_in">From outermost nodes</label>
        </div>
        <div class="menu-dropdown-item">
          <input type="radio" name="flow_color" id="opt_flow_source" onchange="updateOption()">
          <label for="opt_flow_source">From source node</label>
        </div>
        <div class="menu-dropdown-item">
          <input type="radio" name="flow_color" id="opt_flow_target" onchange="updateOption()">
          <label for="opt_flow_target">From target node</label>
        </div>
        <div class="menu-dropdown-item">
          <input type="radio" name="flow_color" id="opt_flow_single" onchange="updateOption()">
          <label for="opt_flow_single">Single color</label>
          <input type="color" id="opt_flow_color" value="#999999" onchange="updateOption()">
        </div>
      </div>
    </div>
    
    <div class="menu-item">
      Layout
      <div class="menu-dropdown">
        <div class="menu-section-title">Diagram Size</div>
        <div class="menu-dropdown-item">
          <label>Width</label>
          <input type="number" id="opt_size_w" value="700" min="100" max="2000" style="width:80px" onchange="updateOption()">
        </div>
        <div class="menu-dropdown-item">
          <label>Height</label>
          <input type="number" id="opt_size_h" value="500" min="100" max="2000" style="width:80px" onchange="updateOption()">
        </div>
        <div class="menu-divider"></div>
        <div class="menu-section-title">Margins</div>
        <div class="menu-dropdown-item">
          <label>Left</label>
          <input type="number" id="opt_margin_l" value="80" min="0" style="width:50px" onchange="updateOption()">
          <label>Right</label>
          <input type="number" id="opt_margin_r" value="80" min="0" style="width:50px" onchange="updateOption()">
        </div>
        <div class="menu-dropdown-item">
          <label>Top</label>
          <input type="number" id="opt_margin_t" value="30" min="0" style="width:50px" onchange="updateOption()">
          <label>Bottom</label>
          <input type="number" id="opt_margin_b" value="30" min="0" style="width:50px" onchange="updateOption()">
        </div>
        <div class="menu-divider"></div>
        <div class="menu-section-title">Background</div>
        <div class="menu-dropdown-item">
          <label>Color</label>
          <input type="color" id="opt_bg_color" value="#FFFFFF" onchange="updateOption()">
          <input type="checkbox" id="opt_bg_transparent" onchange="updateOption()">
          <label for="opt_bg_transparent">Transparent</label>
        </div>
        <div class="menu-divider"></div>
        <div class="menu-section-title">Arrangement</div>
        <div class="menu-dropdown-item">
          <input type="radio" name="layout_order" id="opt_layout_automatic" checked onchange="updateOption()">
          <label for="opt_layout_automatic">Automatic</label>
        </div>
        <div class="menu-dropdown-item">
          <input type="radio" name="layout_order" id="opt_layout_exact" onchange="updateOption()">
          <label for="opt_layout_exact">Exact input order</label>
        </div>
        <div class="menu-divider"></div>
        <div class="menu-dropdown-item" onclick="resetAllNodes()">üîÑ Reset Node Positions</div>
        <div class="menu-dropdown-item" onclick="resetAllLabels()">üîÑ Reset Label Positions</div>
      </div>
    </div>
    
    <div class="menu-spacer"></div>
    
    <button class="menu-btn secondary" onclick="openSettingsModal()">‚öôÔ∏è AI Settings</button>
  </div>

  <!-- Main Content -->
  <div class="main-content">
    <!-- Diagram Panel -->
    <div class="diagram-panel">
      <div class="diagram-title-bar">
        <input type="text" class="diagram-title-input" id="diagram-title-input" value="My Sankey Diagram" placeholder="Enter diagram title...">
      </div>
      
      <!-- Canvas Controls -->
      <div class="canvas-controls" style="padding:8px 20px;display:flex;gap:8px;align-items:center;border-bottom:1px solid #e0e0e0;background:#fafafa;">
        <button class="add-row-btn" onclick="zoomCanvas(-0.1)" title="Zoom Out">‚ûñ</button>
        <span id="zoom-level" style="font-size:12px;min-width:50px;text-align:center;">100%</span>
        <button class="add-row-btn" onclick="zoomCanvas(0.1)" title="Zoom In">‚ûï</button>
        <button class="add-row-btn" onclick="resetZoom()" title="Reset Zoom">üîÑ Reset</button>
        <div style="flex:1;"></div>
        <button class="add-row-btn" onclick="undoLastAction()" title="Undo">‚Ü©Ô∏è Undo</button>
        <button class="add-row-btn" onclick="resetAllNodes()">Reset Nodes</button>
        <button class="add-row-btn" onclick="resetAllLabels()">Reset Labels</button>
      </div>
      
      <div class="diagram-area" id="diagram-area" style="overflow:auto;">
        <div id="chart" style="transform-origin:center center;transition:transform 0.2s;">
          <svg id="sankey_svg" height="500" width="700" xmlns="http://www.w3.org/2000/svg"></svg>
        </div>
        <svg id="svg_scratch" height="500" width="700" xmlns="http://www.w3.org/2000/svg" style="display:none;"></svg>
        <canvas id="png_preview" height="500" width="700" style="display:none;"></canvas>
      </div>
      
      <div class="diagram-footer">
        ‚úèÔ∏è Click on any element to edit it ‚Ä¢ Move nodes by dragging ‚Ä¢ Double-click to reset
      </div>
    </div>

    <!-- Right Panel - Data Editor -->
    <div class="right-panel">
      <div class="panel-header">
        <span>Data Editor</span>
        <div class="panel-header-actions">
          <button onclick="exportCSV()">Export CSV</button>
          <button onclick="document.getElementById('csv_import').click()">Import CSV</button>
        </div>
      </div>
      
      <div class="data-table-wrapper">
        <table class="data-table">
          <thead>
            <tr>
              <th style="width:20%">From</th>
              <th style="width:20%">To</th>
              <th style="width:15%">Amount</th>
              <th style="width:15%">Comparison</th>
              <th style="width:10%">Color</th>
              <th style="width:20%"></th>
            </tr>
          </thead>
          <tbody id="data-table-body"></tbody>
        </table>
      </div>
      
      <div class="add-row-section">
        <button class="add-row-btn" onclick="addDataRow()">+ Add</button>
        <input type="number" id="add-row-count" value="1" min="1" max="20" style="width:50px">
        <span>rows</span>
        <div style="flex:1"></div>
        <button class="add-row-btn" onclick="clearAllRows()">Clear All</button>
      </div>
      
      <!-- Node Editor Panel (shown when clicking a node) -->
      <div class="node-editor-section" id="node-editor" style="display:none;">
        <div class="ai-section-header">
          <span>‚úèÔ∏è Edit Node</span>
          <button class="ai-settings-btn" onclick="closeNodeEditor()">‚úï</button>
        </div>
        <div style="padding:12px 16px;">
          <div class="form-group" style="margin-bottom:12px;">
            <label style="font-size:12px;margin-bottom:4px;display:block;">Node Label</label>
            <input type="text" id="node-edit-label" style="width:100%;padding:8px;border:1px solid #ddd;border-radius:4px;">
          </div>
          <div class="form-group" style="margin-bottom:12px;">
            <label style="font-size:12px;margin-bottom:4px;display:block;">2nd Line (Value)</label>
            <input type="text" id="node-edit-line2" style="width:100%;padding:8px;border:1px solid #ddd;border-radius:4px;" placeholder="e.g., $20M">
          </div>
          <div class="form-group" style="margin-bottom:12px;">
            <label style="font-size:12px;margin-bottom:4px;display:block;">3rd Line (% Change)</label>
            <input type="text" id="node-edit-line3" style="width:100%;padding:8px;border:1px solid #ddd;border-radius:4px;" placeholder="e.g., 5% Y/Y">
          </div>
          <div class="form-group" style="margin-bottom:12px;">
            <label style="font-size:12px;margin-bottom:4px;display:block;">Node Color</label>
            <input type="color" id="node-edit-color" value="#888888" style="width:60px;height:32px;padding:0;border:1px solid #ddd;">
          </div>
          <div style="display:flex;gap:8px;">
            <button class="add-row-btn" onclick="applyNodeEdit()" style="background:#1a73e8;color:white;border:none;">Apply</button>
            <button class="add-row-btn" onclick="closeNodeEditor()">Cancel</button>
          </div>
        </div>
      </div>
      
      <!-- AI Section with Chat History and Image Upload -->
      <div class="ai-section">
        <div class="ai-section-header">
          <span>ü§ñ AI Assistant</span>
          <button class="ai-settings-btn" onclick="openSettingsModal()">‚öôÔ∏è Settings</button>
        </div>
        <div class="ai-chat-area">
          <!-- Chat History -->
          <div id="ai-chat-history" style="max-height:180px;overflow-y:auto;margin-bottom:8px;font-size:12px;border:1px solid #e0e0e0;border-radius:6px;padding:8px;background:#fff;min-height:60px;">
            <div style="color:#999;font-size:11px;text-align:center;">Chat with AI about your data, or say "parse" to extract flows</div>
          </div>
          
          <!-- Image Preview -->
          <div id="ai-image-preview" style="display:none;margin-bottom:8px;padding:8px;background:#f5f5f5;border-radius:4px;">
            <div style="display:flex;align-items:center;gap:8px;">
              <img id="ai-preview-img" style="max-width:100px;max-height:60px;border-radius:4px;">
              <span id="ai-preview-name" style="flex:1;font-size:12px;"></span>
              <button onclick="clearImagePreview()" style="background:none;border:none;cursor:pointer;color:#dc3545;">‚úï</button>
            </div>
          </div>
          
          <div class="ai-chat-input-wrapper">
            <textarea class="ai-chat-input" id="ai-chat-input" placeholder="Ask about your data, paste image (Ctrl+V), or type 'parse: [your data]'..."></textarea>
          </div>
          <div style="display:flex;gap:8px;align-items:center;margin-top:8px;">
            <input type="file" id="ai-image-input" accept="image/*" style="display:none" onchange="handleImageUpload(event)">
            <button class="add-row-btn" onclick="document.getElementById('ai-image-input').click()" title="Upload image">üì∑</button>
            <button class="add-row-btn" onclick="pasteFromClipboard()" title="Paste from clipboard">üìã Paste</button>
            <button class="ai-chat-btn" id="ai-send-btn" onclick="processAIChat()">üí¨ Send</button>
            <div class="ai-status" id="ai-status"></div>
          </div>
          <div style="font-size:10px;color:#999;margin-top:4px;">üí° Paste image with Ctrl+V, or use "parse", "extract" to convert data</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Status Bar -->
  <div class="status-bar" id="status-bar">
    <span>‚úì</span>
    <span id="status-message">Ready - Add data to create your Sankey diagram</span>
  </div>
</div>

<!-- Settings Modal -->
<div class="modal-overlay" id="settings-modal">
  <div class="modal">
    <div class="modal-header">
      <h3>‚öôÔ∏è AI Settings</h3>
      <button class="modal-close" onclick="closeSettingsModal()">&times;</button>
    </div>
    <div class="modal-body">
      <div class="form-group">
        <label>Gemini API Key</label>
        <input type="password" id="gemini-api-key" placeholder="Enter your Gemini API key...">
        <div class="hint">Get your API key from <a href="https://aistudio.google.com/app/apikey" target="_blank">Google AI Studio</a></div>
      </div>
      <div class="form-group">
        <label>Model Name</label>
        <input type="text" id="ai-model" value="gemini-2.0-flash" placeholder="e.g., gemini-2.0-flash, gemini-1.5-pro">
        <div class="hint">Enter any Gemini model name. Common options: gemini-2.0-flash, gemini-1.5-pro, gemini-1.5-flash</div>
      </div>
      <div class="form-group">
        <label>System Prompt</label>
        <textarea id="ai-system-prompt" rows="8" style="font-size:11px;"></textarea>
        <div class="hint">Customize how the AI interprets your data. Click "Reset to Default" to restore.</div>
        <button type="button" class="btn btn-secondary" style="margin-top:8px;padding:6px 12px;font-size:11px;" onclick="resetSystemPrompt()">Reset to Default</button>
      </div>
    </div>
    <div class="modal-footer">
      <button class="btn btn-secondary" onclick="closeSettingsModal()">Cancel</button>
      <button class="btn btn-primary" onclick="saveSettings()">Save Settings</button>
    </div>
  </div>
</div>

<!-- Hidden inputs -->
<input type="file" id="load_file_input" accept=".txt,.skm" style="display:none" onchange="loadDiagramFile()">
<input type="file" id="csv_import" accept=".csv" style="display:none" onchange="importCSV(event)">

<!-- Hidden message areas required by sankeymatic.js -->
<div style="display:none">
  <div id="issue_messages"></div>
  <div id="imbalance_messages"></div>
  <div id="totals_area"></div>
  <div id="info_messages"></div>
  <div id="console_area"><div id="console_lines"></div></div>
  <span id="theme_a_guide"></span><span id="theme_a_label"></span>
  <span id="theme_b_guide"></span><span id="theme_b_label"></span>
  <span id="theme_c_guide"></span><span id="theme_c_label"></span>
  <span id="theme_d_guide"></span><span id="theme_d_label"></span>
  <button id="reset_all_moved_nodes"></button>
  <button id="reset_all_moved_labels"></button>
  <button id="save_as_png_1x" title=""></button>
  <button id="save_as_png_2x" title=""></button>
  <button id="save_as_png_4x" title=""></button>
  <button id="save_as_png_6x" title=""></button>
  <span id="scale_figures"></span>
  <div id="imbalances_area"></div>
</div>

<!-- Hidden textarea for DSL -->
<textarea id="flows_in" style="display:none">Wages [1500] Budget
Other [250] Budget
Budget [450] Taxes
Budget [420] Housing
Budget [400] Food
Budget [255] Transportation
Budget [160] Other Necessities
Budget [65] Savings</textarea>

<!-- Hidden form for compatibility with existing sankeymatic.js -->
<form id="skm_form" style="display:none">
  <input id="size_w" value="700"><input id="size_h" value="500">
  <input id="bg_color" value="#FFFFFF"><input type="checkbox" id="bg_transparent">
  <input id="margin_l" value="80"><input id="margin_r" value="80">
  <input id="margin_t" value="30"><input id="margin_b" value="30">
  <input id="node_w" value="12"><input id="node_h" value="50">
  <input id="node_spacing" value="75"><input id="node_border" value="0">
  <input id="node_opacity" value="1.0"><input id="node_color" value="#888888">
  <input id="flow_opacity" value="0.45"><input id="flow_curvature" value="0.5">
  <input id="flow_color" value="#999999">
  <input id="labelname_size" value="16"><input id="labels_color" value="#000000">
  <input type="checkbox" id="labelname_appears" checked>
  <input type="checkbox" id="labelvalue_appears" checked>
  <input type="checkbox" id="labels_comparisonline">
  <input id="labels_decimalplaces" value="2">
  <input id="value_prefix" value=""><input id="value_suffix" value="">
  <input id="value_format" value=",.">
  <input id="labels_hide" type="checkbox">
  <input id="labels_highlight" value="0.75">
  <input id="labels_googlefont_hidden" value="">
  <input id="labels_valuemode" value="absolute">
  <input id="labels_linespacing" value="0.15">
  <input id="labels_relativesize" value="100">
  <input id="labels_magnify" value="100">
  <input id="labelname_weight" value="400">
  <input id="labelvalue_fullprecision" type="checkbox" checked>
  <input id="labelvalue_weight" value="400">
  <input id="labelposition_autoalign" value="0">
  <input id="labelposition_breakpoint" value="9999">
  <input id="layout_justifyorigins" type="checkbox">
  <input id="layout_justifyends" type="checkbox">
  <input id="layout_reversegraph" type="checkbox">
  <input id="meta_mentionsankeymatic" type="checkbox">
  <input id="meta_listimbalances" type="checkbox" checked>
  <input id="internal_revealshadows" type="checkbox">
  <input type="radio" name="labels_fontface" id="labels_fontface_sans" value="sans-serif" checked>
  <input type="radio" name="labels_fontface" id="labels_fontface_serif" value="serif">
  <input type="radio" name="labels_fontface" id="labels_fontface_mono" value="monospace">
  <input type="radio" name="labelposition_scheme" id="labelposition_scheme_auto" value="auto" checked>
  <input type="radio" name="labelposition_scheme" id="labelposition_scheme_per_stage" value="per_stage">
  <input type="radio" name="labelposition_first" id="labelposition_first_before" value="before" checked>
  <input type="radio" name="labelposition_first" id="labelposition_first_after" value="after">
  <input type="radio" name="layout_attachincompletesto" id="layout_attach_leading" value="leading">
  <input type="radio" name="layout_attachincompletesto" id="layout_attach_nearest" value="nearest" checked>
  <input type="radio" name="layout_attachincompletesto" id="layout_attach_trailing" value="trailing">
  <input type="radio" name="labels_fontface" id="sans_serif" value="sans-serif" checked>
  <input type="radio" name="node_theme" id="theme_a_radio" value="a" checked>
  <input type="radio" name="node_theme" id="theme_b_radio" value="b">
  <input type="radio" name="node_theme" id="theme_c_radio" value="c">
  <input type="radio" name="node_theme" id="theme_d_radio" value="d">
  <input type="radio" name="node_theme" id="theme_none_radio" value="none">
  <input type="radio" name="flow_inheritfrom" id="flow_inherit_outside_in" value="outside-in" checked>
  <input type="radio" name="flow_inheritfrom" id="flow_inherit_from_source" value="source">
  <input type="radio" name="flow_inheritfrom" id="flow_inherit_from_target" value="target">
  <input type="radio" name="flow_inheritfrom" id="flow_inherit_none" value="none">
  <input type="radio" name="layout_order" id="layout_order_automatic" value="automatic" checked>
  <input type="radio" name="layout_order" id="layout_order_exact" value="exact">
  <input type="radio" name="labelvalue_position" id="labelvalue_below" value="below" checked>
  <input id="internal_iterations" value="25">
  <input id="themeoffset_a" value="6"><input id="themeoffset_b" value="0">
  <input id="themeoffset_c" value="0"><input id="themeoffset_d" value="0">
  <input id="labels_fontface" value="sans-serif">
  <input id="labels_googlefont" value="">
  <!-- Missing elements required by sankeymatic.js -->
  <input id="meta_listimbalances" type="checkbox" checked>
  <input type="radio" name="layout_attachincompletesto" id="layout_attachto_leading" value="leading">
  <input type="radio" name="layout_attachincompletesto" id="layout_attachto_trailing" value="trailing">
  <input type="radio" name="layout_attachincompletesto" id="layout_attachto_nearest" value="nearest" checked>
</form>

<script>
// ============ DATA TABLE ============
function initializeDataTable() {
  const tbody = document.getElementById('data-table-body');
  const flowsText = document.getElementById('flows_in').value;
  const lines = flowsText.split('\n').filter(line => {
    const t = line.trim();
    return t && !t.startsWith('//') && !t.startsWith(':') && !t.startsWith("'");
  });
  
  tbody.innerHTML = '';
  lines.forEach(line => {
    const match = line.match(/^(.+?)\s*\[([^\]]+)\]\s*(.+?)(?:\s+(#[a-f0-9]{3,6}))?$/i);
    if (match) {
      addDataRowWithValues(match[1].trim(), match[3].trim(), match[2].trim(), '');
    }
  });
  
  if (tbody.children.length === 0) {
    addDataRowWithValues('', '', '', '');
  }
}

function addDataRow() {
  saveStateForUndo();
  const count = parseInt(document.getElementById('add-row-count').value) || 1;
  for (let i = 0; i < count; i++) {
    addDataRowWithValues('', '', '', '');
  }
}

function addDataRowWithValues(from, to, amount, comparison, color) {
  const tbody = document.getElementById('data-table-body');
  const row = document.createElement('tr');
  const colorVal = color || '';
  row.innerHTML = `
    <td><input type="text" value="${escapeHtml(from)}" onfocus="saveStateForUndo()" onchange="updateDiagramFromTableNoUndo()" placeholder="Source"></td>
    <td><input type="text" value="${escapeHtml(to)}" onfocus="saveStateForUndo()" onchange="updateDiagramFromTableNoUndo()" placeholder="Target"></td>
    <td><input type="text" value="${escapeHtml(amount)}" onfocus="saveStateForUndo()" onchange="updateDiagramFromTableNoUndo()" placeholder="0"></td>
    <td><input type="text" value="${escapeHtml(comparison)}" onfocus="saveStateForUndo()" onchange="updateDiagramFromTableNoUndo()" placeholder="Prev"></td>
    <td><input type="color" value="${colorVal || '#cccccc'}" onfocus="saveStateForUndo()" onchange="updateDiagramFromTableNoUndo()" title="Flow color" style="width:40px;height:24px;padding:0;border:1px solid #ddd;cursor:pointer;${colorVal ? '' : 'opacity:0.3;'}"></td>
    <td style="display:flex;gap:4px;">
      <button class="delete-btn" onclick="editFlowNode(this)" title="Edit" style="color:#1a73e8;">‚úèÔ∏è</button>
      <button class="delete-btn" onclick="saveStateForUndo(); deleteDataRow(this)" title="Delete">√ó</button>
    </td>
  `;
  tbody.appendChild(row);
}

function escapeHtml(str) {
  if (!str) return '';
  return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

function deleteDataRow(btn) {
  btn.closest('tr').remove();
  updateDiagramFromTableNoUndo();
}

function clearAllRows() {
  if (confirm('Clear all data rows?')) {
    saveStateForUndo();
    document.getElementById('data-table-body').innerHTML = '';
    addDataRowWithValues('', '', '', '');
    updateDiagramFromTableNoUndo();
  }
}

function updateDiagramFromTable() {
  // Save state for undo BEFORE making changes
  saveStateForUndo();
  
  const tbody = document.getElementById('data-table-body');
  const rows = tbody.querySelectorAll('tr');
  let dsl = '';
  let validRows = 0;
  
  rows.forEach(row => {
    const inputs = row.querySelectorAll('input');
    const from = inputs[0].value.trim();
    const to = inputs[1].value.trim();
    const amount = inputs[2].value.trim();
    const comparison = inputs[3]?.value.trim() || '';
    const colorInput = inputs[4];
    const color = colorInput && colorInput.style.opacity !== '0.3' ? colorInput.value : '';
    
    if (from && to && amount) {
      let line = `${from} [${amount}] ${to}`;
      if (color && color !== '#cccccc') {
        line += ` ${color}`;
      }
      dsl += line + '\n';
      validRows++;
    }
  });
  
  document.getElementById('flows_in').value = dsl;
  renderDiagram();
  updateStatus(validRows);
}

// ============ RENDER DIAGRAM ============
function renderDiagram() {
  syncOptionsToForm();
  
  // Try window.process_sankey first (from sankeymatic.js IIFE)
  const processFn = window.process_sankey || (typeof process_sankey !== 'undefined' ? process_sankey : null);
  
  if (processFn) {
    try {
      processFn();
      console.log('Diagram rendered successfully');
    } catch (e) {
      console.error('Render error:', e);
      document.getElementById('status-message').textContent = 'Error: ' + e.message;
      document.getElementById('status-bar').className = 'status-bar error';
    }
  } else {
    console.warn('process_sankey not available yet, will retry...');
    // Retry after a short delay
    setTimeout(renderDiagram, 200);
  }
}

// ============ OPTIONS SYNC ============
function syncOptionsFromForm() {
  // Sync from hidden form to menu options
  const mappings = {
    'opt_labelname_appears': { el: 'labelname_appears', type: 'checkbox' },
    'opt_labelvalue_appears': { el: 'labelvalue_appears', type: 'checkbox' },
    'opt_labels_comparisonline': { el: 'labels_comparisonline', type: 'checkbox' },
    'opt_labelname_size': { el: 'labelname_size', type: 'value' },
    'opt_labels_color': { el: 'labels_color', type: 'value' },
    'opt_labels_decimalplaces': { el: 'labels_decimalplaces', type: 'value' },
    'opt_value_prefix': { el: 'value_prefix', type: 'value' },
    'opt_value_suffix': { el: 'value_suffix', type: 'value' },
    'opt_node_w': { el: 'node_w', type: 'value' },
    'opt_node_h': { el: 'node_h', type: 'value' },
    'opt_node_spacing': { el: 'node_spacing', type: 'value' },
    'opt_node_border': { el: 'node_border', type: 'value' },
    'opt_node_opacity': { el: 'node_opacity', type: 'value', scale: 100 },
    'opt_node_color': { el: 'node_color', type: 'value' },
    'opt_flow_opacity': { el: 'flow_opacity', type: 'value', scale: 100 },
    'opt_flow_curvature': { el: 'flow_curvature', type: 'value', scale: 100 },
    'opt_flow_color': { el: 'flow_color', type: 'value' },
    'opt_size_w': { el: 'size_w', type: 'value' },
    'opt_size_h': { el: 'size_h', type: 'value' },
    'opt_margin_l': { el: 'margin_l', type: 'value' },
    'opt_margin_r': { el: 'margin_r', type: 'value' },
    'opt_margin_t': { el: 'margin_t', type: 'value' },
    'opt_margin_b': { el: 'margin_b', type: 'value' },
    'opt_bg_color': { el: 'bg_color', type: 'value' },
    'opt_bg_transparent': { el: 'bg_transparent', type: 'checkbox' },
  };
  
  for (const [optId, cfg] of Object.entries(mappings)) {
    const optEl = document.getElementById(optId);
    const formEl = document.getElementById(cfg.el);
    if (optEl && formEl) {
      if (cfg.type === 'checkbox') {
        optEl.checked = formEl.checked;
      } else {
        let val = formEl.value;
        if (cfg.scale) val = parseFloat(val) * cfg.scale;
        optEl.value = val;
      }
    }
  }
}

function syncOptionsToForm() {
  // Sync from menu options to hidden form
  const el = id => document.getElementById(id);
  
  // Labels
  if (el('opt_labelname_appears')) el('labelname_appears').checked = el('opt_labelname_appears').checked;
  if (el('opt_labelvalue_appears')) el('labelvalue_appears').checked = el('opt_labelvalue_appears').checked;
  if (el('opt_labels_comparisonline')) el('labels_comparisonline').checked = el('opt_labels_comparisonline').checked;
  if (el('opt_labelname_size')) el('labelname_size').value = el('opt_labelname_size').value;
  if (el('opt_labels_color')) el('labels_color').value = el('opt_labels_color').value;
  if (el('opt_labels_decimalplaces')) el('labels_decimalplaces').value = el('opt_labels_decimalplaces').value;
  if (el('opt_value_prefix')) el('value_prefix').value = el('opt_value_prefix').value;
  if (el('opt_value_suffix')) el('value_suffix').value = el('opt_value_suffix').value;
  
  // Font handling
  if (el('opt_labels_fontface')) {
    const fontValue = el('opt_labels_fontface').value;
    const radioId = 'labels_fontface_' + (fontValue === 'sans-serif' ? 'sans' : fontValue === 'serif' ? 'serif' : 'mono');
    const radio = el(radioId);
    if (radio) radio.checked = true;
  }
  if (el('opt_labels_googlefont')) {
    const googleFont = el('opt_labels_googlefont').value;
    el('labels_googlefont').value = googleFont;
    // Load Google Font if selected
    if (googleFont) {
      loadGoogleFont(googleFont);
    }
  }
  
  // Nodes
  if (el('opt_node_w')) el('node_w').value = el('opt_node_w').value;
  if (el('opt_node_h')) el('node_h').value = el('opt_node_h').value;
  if (el('opt_node_spacing')) el('node_spacing').value = el('opt_node_spacing').value;
  if (el('opt_node_border')) el('node_border').value = el('opt_node_border').value;
  if (el('opt_node_opacity')) el('node_opacity').value = el('opt_node_opacity').value / 100;
  if (el('opt_node_color')) el('node_color').value = el('opt_node_color').value;
  if (el('opt_node_theme')) {
    const theme = el('opt_node_theme').value;
    const radioId = 'theme_' + theme + '_radio';
    const radio = el(radioId);
    if (radio) radio.checked = true;
  }
  
  // Flows
  if (el('opt_flow_opacity')) el('flow_opacity').value = el('opt_flow_opacity').value / 100;
  if (el('opt_flow_curvature')) el('flow_curvature').value = el('opt_flow_curvature').value / 100;
  if (el('opt_flow_color')) el('flow_color').value = el('opt_flow_color').value;
  if (el('opt_flow_outside_in')?.checked) el('flow_inherit_outside_in').checked = true;
  if (el('opt_flow_source')?.checked) el('flow_inherit_from_source').checked = true;
  if (el('opt_flow_target')?.checked) el('flow_inherit_from_target').checked = true;
  if (el('opt_flow_single')?.checked) el('flow_inherit_none').checked = true;
  
  // Layout
  if (el('opt_size_w')) el('size_w').value = el('opt_size_w').value;
  if (el('opt_size_h')) el('size_h').value = el('opt_size_h').value;
  if (el('opt_margin_l')) el('margin_l').value = el('opt_margin_l').value;
  if (el('opt_margin_r')) el('margin_r').value = el('opt_margin_r').value;
  if (el('opt_margin_t')) el('margin_t').value = el('opt_margin_t').value;
  if (el('opt_margin_b')) el('margin_b').value = el('opt_margin_b').value;
  if (el('opt_bg_color')) el('bg_color').value = el('opt_bg_color').value;
  if (el('opt_bg_transparent')) el('bg_transparent').checked = el('opt_bg_transparent').checked;
  if (el('opt_layout_automatic')?.checked) el('layout_order_automatic').checked = true;
  if (el('opt_layout_exact')?.checked) el('layout_order_exact').checked = true;
  
  // Update SVG size
  const svg = document.getElementById('sankey_svg');
  if (svg && el('opt_size_w') && el('opt_size_h')) {
    svg.setAttribute('width', el('opt_size_w').value);
    svg.setAttribute('height', el('opt_size_h').value);
  }
}

function updateOption() {
  renderDiagram();
}

function updateFontOption() {
  const fontSelect = document.getElementById('opt_labels_fontface');
  const fontValue = fontSelect.value;
  
  // Update the radio buttons
  const radioId = 'labels_fontface_' + (fontValue === 'sans-serif' ? 'sans' : fontValue === 'serif' ? 'serif' : 'mono');
  const radio = document.getElementById(radioId);
  if (radio) radio.checked = true;
  
  renderDiagram();
}

// ============ FILE OPERATIONS ============
function newDiagram() {
  if (confirm('Create new diagram? Current data will be cleared.')) {
    document.getElementById('data-table-body').innerHTML = '';
    document.getElementById('flows_in').value = '';
    document.getElementById('diagram-title-input').value = 'My Sankey Diagram';
    addDataRowWithValues('', '', '', '');
    renderDiagram();
  }
}

function resetAllNodes() {
  if (typeof resetMovesAndRender === 'function') resetMovesAndRender();
}

function resetAllLabels() {
  if (typeof resetLabelMovesAndRender === 'function') resetLabelMovesAndRender();
}

function exportCSV() {
  const tbody = document.getElementById('data-table-body');
  const rows = tbody.querySelectorAll('tr');
  let csv = 'From,To,Amount,Comparison\n';
  rows.forEach(row => {
    const inputs = row.querySelectorAll('input');
    csv += `"${inputs[0].value}","${inputs[1].value}","${inputs[2].value}","${inputs[3].value}"\n`;
  });
  
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'sankey_data.csv';
  a.click();
}

function importCSV(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = function(e) {
    const lines = e.target.result.split('\n');
    document.getElementById('data-table-body').innerHTML = '';
    
    lines.forEach((line, i) => {
      if (i === 0 && line.toLowerCase().includes('from')) return; // Skip header
      const parts = line.split(',').map(p => p.replace(/"/g, '').trim());
      if (parts.length >= 3 && parts[0] && parts[1]) {
        addDataRowWithValues(parts[0], parts[1], parts[2] || '0', parts[3] || '');
      }
    });
    
    updateDiagramFromTable();
  };
  reader.readAsText(file);
  event.target.value = '';
}

// ============ AI SETTINGS ============
function openSettingsModal() {
  document.getElementById('settings-modal').classList.add('active');
}

function closeSettingsModal() {
  document.getElementById('settings-modal').classList.remove('active');
}

function saveSettings() {
  const apiKey = document.getElementById('gemini-api-key').value.trim();
  const model = document.getElementById('ai-model').value.trim() || 'gemini-2.0-flash';
  const prompt = document.getElementById('ai-system-prompt').value.trim();
  
  localStorage.setItem('gemini_api_key', apiKey);
  localStorage.setItem('ai_model', model);
  localStorage.setItem('ai_system_prompt', prompt);
  
  closeSettingsModal();
  updateAIStatus(apiKey ? '‚úì Settings saved' : '‚ö†Ô∏è No API key set', apiKey ? 'success' : 'warning');
}

function updateAIStatus(msg, type) {
  const el = document.getElementById('ai-status');
  el.textContent = msg;
  el.className = 'ai-status ' + (type || '');
}

// Default system prompt
const DEFAULT_SYSTEM_PROMPT = `You are a financial data parser for Sankey diagrams.
Parse the input and extract flows between nodes.

IMPORTANT: A Sankey diagram shows flows FROM sources TO destinations with amounts.
- Each flow has: source (from), destination (to), and amount
- For income statements: Revenue flows to Gross Profit, Gross Profit flows to Operating Profit, etc.
- For balance sheets: Assets flow to categories, Liabilities flow to categories
- Amounts should be positive numbers
- Parse numbers correctly: $100M = 100000000, $1.5B = 1500000000, 1,500 = 1500

Return ONLY valid JSON in this exact format:
{"flows": [{"from": "Source Name", "to": "Destination Name", "amount": 1000}]}

Example for income statement:
Input: "Revenue $100M, COGS $40M, Operating Expenses $30M, Net Income $30M"
Output: {"flows": [
  {"from": "Revenue", "to": "Gross Profit", "amount": 60000000},
  {"from": "Revenue", "to": "COGS", "amount": 40000000},
  {"from": "Gross Profit", "to": "Operating Profit", "amount": 30000000},
  {"from": "Gross Profit", "to": "Operating Expenses", "amount": 30000000},
  {"from": "Operating Profit", "to": "Net Income", "amount": 30000000}
]}`;

function resetSystemPrompt() {
  document.getElementById('ai-system-prompt').value = DEFAULT_SYSTEM_PROMPT;
}

async function callGeminiAPI(apiKey, model, text, customPrompt, imageData) {
  const systemPrompt = customPrompt || DEFAULT_SYSTEM_PROMPT;
  
  let contents;
  if (imageData) {
    // With image
    contents = [{
      parts: [
        { text: systemPrompt + '\n\nAnalyze this image and extract financial flows:\n' + text },
        { inline_data: { mime_type: imageData.type, data: imageData.base64 } }
      ]
    }];
  } else {
    // Text only
    contents = [{ parts: [{ text: systemPrompt + '\n\nData to parse:\n' + text }] }];
  }

  const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      contents: contents,
      generationConfig: { temperature: 0.1, maxOutputTokens: 4096 }
    })
  });
  
  if (!response.ok) {
    const err = await response.json();
    throw new Error(err.error?.message || 'API request failed');
  }
  
  const data = await response.json();
  const responseText = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
  
  // Add to chat history
  addToChatHistory('user', text || 'Uploaded image');
  addToChatHistory('ai', responseText.substring(0, 200) + '...');
  
  // Extract JSON from response
  const jsonMatch = responseText.match(/\{[\s\S]*\}/);
  if (jsonMatch) {
    return JSON.parse(jsonMatch[0]);
  }
  
  throw new Error('Could not parse AI response');
}

// ============ CHAT HISTORY ============
function addToChatHistory(role, message) {
  const history = document.getElementById('ai-chat-history');
  const div = document.createElement('div');
  div.style.cssText = `padding:6px 8px;margin-bottom:4px;border-radius:4px;background:${role === 'user' ? '#e3f2fd' : '#f5f5f5'};`;
  div.innerHTML = `<strong>${role === 'user' ? 'üë§' : 'ü§ñ'}</strong> ${escapeHtml(message)}`;
  history.appendChild(div);
  history.scrollTop = history.scrollHeight;
}

// ============ IMAGE UPLOAD & CLIPBOARD PASTE ============
let currentImageData = null;

function handleImageUpload(event) {
  const file = event.target.files[0];
  if (!file) return;
  processImageFile(file);
  event.target.value = '';
}

function processImageFile(file) {
  const reader = new FileReader();
  reader.onload = function(e) {
    const base64 = e.target.result.split(',')[1];
    currentImageData = { type: file.type, base64: base64 };
    
    // Show preview
    document.getElementById('ai-preview-img').src = e.target.result;
    document.getElementById('ai-preview-name').textContent = file.name || 'Pasted image';
    document.getElementById('ai-image-preview').style.display = 'block';
    updateAIStatus('üì∑ Image ready', 'success');
  };
  reader.readAsDataURL(file);
}

// Paste from clipboard button
async function pasteFromClipboard() {
  try {
    const clipboardItems = await navigator.clipboard.read();
    for (const item of clipboardItems) {
      // Check for image types
      const imageType = item.types.find(type => type.startsWith('image/'));
      if (imageType) {
        const blob = await item.getType(imageType);
        const file = new File([blob], 'pasted-image.png', { type: imageType });
        processImageFile(file);
        return;
      }
    }
    updateAIStatus('No image in clipboard', 'warning');
  } catch (err) {
    console.error('Clipboard error:', err);
    updateAIStatus('Cannot access clipboard', 'error');
  }
}

// Listen for paste events on the chat input
document.addEventListener('DOMContentLoaded', function() {
  const chatInput = document.getElementById('ai-chat-input');
  if (chatInput) {
    chatInput.addEventListener('paste', function(e) {
      const items = e.clipboardData?.items;
      if (!items) return;
      
      for (let i = 0; i < items.length; i++) {
        if (items[i].type.startsWith('image/')) {
          e.preventDefault();
          const file = items[i].getAsFile();
          if (file) {
            processImageFile(file);
          }
          break;
        }
      }
    });
  }
});

function clearImagePreview() {
  currentImageData = null;
  document.getElementById('ai-image-preview').style.display = 'none';
  updateAIStatus('', '');
}

// ============ NODE EDITOR ============
let currentEditingNode = null;
let nodeColors = {}; // Store custom node colors

function editFlowNode(btn) {
  const row = btn.closest('tr');
  const inputs = row.querySelectorAll('input');
  
  document.getElementById('node-edit-label').value = inputs[0].value;
  document.getElementById('node-edit-line2').value = inputs[2].value;
  document.getElementById('node-edit-line3').value = inputs[3].value;
  document.getElementById('node-edit-color').value = inputs[4].value || '#888888';
  
  currentEditingNode = row;
  document.getElementById('node-editor').style.display = 'block';
}

function closeNodeEditor() {
  document.getElementById('node-editor').style.display = 'none';
  currentEditingNode = null;
}

function applyNodeEdit() {
  if (!currentEditingNode) return;
  
  const inputs = currentEditingNode.querySelectorAll('input');
  const oldLabel = inputs[0].value;
  const newLabel = document.getElementById('node-edit-label').value;
  const newColor = document.getElementById('node-edit-color').value;
  
  inputs[0].value = newLabel;
  inputs[2].value = document.getElementById('node-edit-line2').value;
  inputs[3].value = document.getElementById('node-edit-line3').value;
  inputs[4].value = newColor;
  inputs[4].style.opacity = '1';
  
  // Store node color for DSL
  if (newColor && newColor !== '#888888' && newColor !== '#cccccc') {
    nodeColors[newLabel] = newColor;
    // Remove old label color if renamed
    if (oldLabel !== newLabel && nodeColors[oldLabel]) {
      delete nodeColors[oldLabel];
    }
  }
  
  closeNodeEditor();
  updateDiagramFromTableWithNodeColors();
}

// Update diagram with node color definitions
function updateDiagramFromTableWithNodeColors() {
  saveStateForUndo();
  
  const tbody = document.getElementById('data-table-body');
  const rows = tbody.querySelectorAll('tr');
  let dsl = '';
  let validRows = 0;
  
  // Add node color definitions at the top
  for (const [nodeName, color] of Object.entries(nodeColors)) {
    dsl += `:${nodeName} ${color}\n`;
  }
  if (Object.keys(nodeColors).length > 0) {
    dsl += '\n';
  }
  
  rows.forEach(row => {
    const inputs = row.querySelectorAll('input');
    const from = inputs[0].value.trim();
    const to = inputs[1].value.trim();
    const amount = inputs[2].value.trim();
    const colorInput = inputs[4];
    const flowColor = colorInput && colorInput.style.opacity !== '0.3' ? colorInput.value : '';
    
    if (from && to && amount) {
      let line = `${from} [${amount}] ${to}`;
      // Flow color (different from node color)
      if (flowColor && flowColor !== '#cccccc' && !nodeColors[from] && !nodeColors[to]) {
        line += ` ${flowColor}`;
      }
      dsl += line + '\n';
      validRows++;
    }
  });
  
  document.getElementById('flows_in').value = dsl;
  renderDiagram();
  updateStatus(validRows);
  saveProgressToLocal();
}

// Update loadSettings to show default prompt
function loadSettings() {
  document.getElementById('gemini-api-key').value = localStorage.getItem('gemini_api_key') || '';
  document.getElementById('ai-model').value = localStorage.getItem('ai_model') || 'gemini-2.0-flash';
  
  const savedPrompt = localStorage.getItem('ai_system_prompt');
  document.getElementById('ai-system-prompt').value = savedPrompt || DEFAULT_SYSTEM_PROMPT;
  
  const hasKey = !!localStorage.getItem('gemini_api_key');
  updateAIStatus(hasKey ? '‚úì API key configured' : '‚ö†Ô∏è Set API key in Settings', hasKey ? 'success' : 'warning');
}

// ============ GOOGLE FONT LOADER ============
function loadGoogleFont(fontName) {
  if (!fontName) return;
  const fontId = 'google-font-' + fontName.replace(/\s+/g, '-');
  if (document.getElementById(fontId)) return; // Already loaded
  
  const link = document.createElement('link');
  link.id = fontId;
  link.rel = 'stylesheet';
  link.href = `https://fonts.googleapis.com/css2?family=${encodeURIComponent(fontName)}:wght@400;500;600;700&display=swap`;
  document.head.appendChild(link);
}

// ============ ZOOM CONTROLS ============
let currentZoom = 1.0;

function zoomCanvas(delta) {
  currentZoom = Math.max(0.25, Math.min(3, currentZoom + delta));
  document.getElementById('chart').style.transform = `scale(${currentZoom})`;
  document.getElementById('zoom-level').textContent = Math.round(currentZoom * 100) + '%';
}

function resetZoom() {
  currentZoom = 1.0;
  document.getElementById('chart').style.transform = 'scale(1)';
  document.getElementById('zoom-level').textContent = '100%';
}

// ============ UNDO FUNCTIONALITY ============
let undoStack = [];
let lastSavedState = null;
const MAX_UNDO = 20;

// Save current state (call this BEFORE making changes)
function saveStateForUndo() {
  const flowsEl = document.getElementById('flows_in');
  const tbodyEl = document.getElementById('data-table-body');
  if (!flowsEl || !tbodyEl) return;
  
  const currentState = {
    flows: flowsEl.value,
    tableHtml: tbodyEl.innerHTML,
    timestamp: Date.now()
  };
  
  // Don't save duplicate states
  if (lastSavedState && lastSavedState.flows === currentState.flows) {
    return;
  }
  
  undoStack.push(currentState);
  lastSavedState = currentState;
  if (undoStack.length > MAX_UNDO) undoStack.shift();
  console.log('Undo state saved, stack size:', undoStack.length);
}

function undoLastAction() {
  console.log('Undo called, stack size:', undoStack.length);
  if (undoStack.length <= 1) {
    updateAIStatus('Nothing to undo', 'warning');
    return;
  }
  
  // Pop current state, then get previous state
  undoStack.pop(); // Remove current
  const state = undoStack[undoStack.length - 1]; // Get previous (don't pop it)
  
  const flowsEl = document.getElementById('flows_in');
  const tbodyEl = document.getElementById('data-table-body');
  if (flowsEl) flowsEl.value = state.flows;
  if (tbodyEl) {
    tbodyEl.innerHTML = state.tableHtml;
    // Re-attach event listeners to restored inputs
    attachTableEventListeners();
  }
  
  lastSavedState = state;
  renderDiagramOnly();
  updateAIStatus('‚Ü©Ô∏è Undone', 'success');
}

// Attach event listeners to table inputs
function attachTableEventListeners() {
  const tbody = document.getElementById('data-table-body');
  if (!tbody) return;
  
  tbody.querySelectorAll('tr').forEach(row => {
    const inputs = row.querySelectorAll('input');
    inputs.forEach(input => {
      input.onfocus = saveStateForUndo;
      input.onchange = updateDiagramFromTableNoUndo;
    });
    const deleteBtn = row.querySelector('.delete-btn:last-child');
    if (deleteBtn) {
      deleteBtn.onclick = function() { 
        saveStateForUndo();
        deleteDataRow(this); 
      };
    }
  });
}

// Separate render function that doesn't trigger undo save
function renderDiagramOnly() {
  syncOptionsToForm();
  const processFn = window.process_sankey || (typeof process_sankey !== 'undefined' ? process_sankey : null);
  if (processFn) {
    try {
      processFn();
    } catch (e) {
      console.error('Render error:', e);
    }
  }
}

// Update diagram without saving undo state (used after undo)
function updateDiagramFromTableNoUndo() {
  const tbody = document.getElementById('data-table-body');
  const rows = tbody.querySelectorAll('tr');
  let dsl = '';
  let validRows = 0;
  
  rows.forEach(row => {
    const inputs = row.querySelectorAll('input');
    const from = inputs[0].value.trim();
    const to = inputs[1].value.trim();
    const amount = inputs[2].value.trim();
    const colorInput = inputs[4];
    const color = colorInput && colorInput.style.opacity !== '0.3' ? colorInput.value : '';
    
    if (from && to && amount) {
      let line = `${from} [${amount}] ${to}`;
      if (color && color !== '#cccccc') {
        line += ` ${color}`;
      }
      dsl += line + '\n';
      validRows++;
    }
  });
  
  document.getElementById('flows_in').value = dsl;
  renderDiagramOnly();
  updateStatus(validRows);
}

// ============ NODE BALANCE VALIDATION ============
function checkNodeBalance() {
  const tbody = document.getElementById('data-table-body');
  const rows = tbody.querySelectorAll('tr');
  const nodeIn = {};
  const nodeOut = {};
  
  rows.forEach(row => {
    const inputs = row.querySelectorAll('input');
    const from = inputs[0].value.trim();
    const to = inputs[1].value.trim();
    const amount = parseFloat(inputs[2].value) || 0;
    
    if (from && to && amount > 0) {
      nodeOut[from] = (nodeOut[from] || 0) + amount;
      nodeIn[to] = (nodeIn[to] || 0) + amount;
    }
  });
  
  // Find imbalanced nodes (nodes that have both in and out flows)
  const allNodes = new Set([...Object.keys(nodeIn), ...Object.keys(nodeOut)]);
  const imbalanced = [];
  
  allNodes.forEach(node => {
    const inFlow = nodeIn[node] || 0;
    const outFlow = nodeOut[node] || 0;
    // Only check nodes that have both inputs and outputs
    if (inFlow > 0 && outFlow > 0 && Math.abs(inFlow - outFlow) > 0.01) {
      imbalanced.push({ node, inFlow, outFlow, diff: inFlow - outFlow });
    }
  });
  
  return imbalanced;
}

// Override updateStatus to check balance
function updateStatus(rowCount) {
  const bar = document.getElementById('status-bar');
  const msg = document.getElementById('status-message');
  
  if (rowCount === 0) {
    bar.className = 'status-bar warning';
    msg.textContent = 'No valid flows - add data to create diagram';
    return;
  }
  
  const imbalanced = checkNodeBalance();
  if (imbalanced.length > 0) {
    bar.className = 'status-bar warning';
    const nodeList = imbalanced.map(n => `${n.node} (${n.diff > 0 ? '+' : ''}${n.diff.toFixed(2)})`).join(', ');
    msg.textContent = `‚ö†Ô∏è ${rowCount} flows ‚Ä¢ Imbalanced nodes: ${nodeList}`;
  } else {
    bar.className = 'status-bar';
    msg.textContent = `‚úì ${rowCount} flows ‚Ä¢ All nodes balanced`;
  }
}

// ============ CONVERSATIONAL AI CHAT ============
let chatMode = 'chat'; // 'chat' or 'parse'

async function processAIChat() {
  const input = document.getElementById('ai-chat-input');
  const btn = document.getElementById('ai-send-btn');
  const text = input.value.trim();
  
  if (!text && !currentImageData) {
    updateAIStatus('Please enter text or upload an image', 'error');
    return;
  }
  
  const apiKey = localStorage.getItem('gemini_api_key');
  if (!apiKey) {
    updateAIStatus('‚ö†Ô∏è Please set API key in Settings', 'warning');
    openSettingsModal();
    return;
  }
  
  btn.disabled = true;
  addToChatHistory('user', text || '[Image uploaded]');
  updateAIStatus('‚è≥ Processing...', '');
  
  try {
    const model = localStorage.getItem('ai_model') || 'gemini-2.0-flash';
    const customPrompt = localStorage.getItem('ai_system_prompt') || '';
    
    // Check if user wants to parse data or just chat
    const parseKeywords = ['parse', 'extract', 'convert', 'add to diagram', 'create flows', 'generate'];
    const shouldParse = parseKeywords.some(kw => text.toLowerCase().includes(kw)) || currentImageData;
    
    if (shouldParse) {
      // Parse mode - extract flows
      const result = await callGeminiAPI(apiKey, model, text, customPrompt, currentImageData);
      
      if (result.flows && result.flows.length > 0) {
        result.flows.forEach(f => {
          addDataRowWithValues(f.from || f.source, f.to || f.target, String(f.amount || f.value || 0), '', '');
        });
        updateDiagramFromTable();
        addToChatHistory('ai', `‚úÖ Added ${result.flows.length} flows to the diagram!`);
        updateAIStatus(`‚úì Added ${result.flows.length} flows`, 'success');
      } else {
        addToChatHistory('ai', 'I couldn\'t find any flows to extract. Try describing your data more clearly, or use keywords like "parse" or "extract".');
        updateAIStatus('No flows found', 'warning');
      }
    } else {
      // Chat mode - have a conversation about the data
      const chatResponse = await callGeminiChatAPI(apiKey, model, text);
      addToChatHistory('ai', chatResponse);
      updateAIStatus('', '');
    }
    
    input.value = '';
    clearImagePreview();
  } catch (err) {
    console.error('AI Error:', err);
    addToChatHistory('ai', '‚ùå Error: ' + err.message);
    updateAIStatus('Error: ' + err.message, 'error');
  } finally {
    btn.disabled = false;
  }
}

// Chat API for conversational mode
async function callGeminiChatAPI(apiKey, model, text) {
  const chatPrompt = `You are a helpful assistant for creating Sankey diagrams. You help users understand their financial data and how to visualize it.

Current diagram data:
${document.getElementById('flows_in').value || 'No data yet'}

User question: ${text}

Respond helpfully and concisely. If the user wants to add data, tell them to use keywords like "parse" or "extract" followed by their data. Keep responses under 150 words.`;

  const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      contents: [{ parts: [{ text: chatPrompt }] }],
      generationConfig: { temperature: 0.7, maxOutputTokens: 500 }
    })
  });
  
  if (!response.ok) {
    const err = await response.json();
    throw new Error(err.error?.message || 'API request failed');
  }
  
  const data = await response.json();
  return data.candidates?.[0]?.content?.parts?.[0]?.text || 'Sorry, I couldn\'t generate a response.';
}

// ============ CLICK TO EDIT ON CANVAS ============
function setupClickToEdit() {
  const svg = document.getElementById('sankey_svg');
  if (!svg) return;
  
  // Add click handlers to nodes
  svg.querySelectorAll('rect').forEach(rect => {
    rect.style.cursor = 'pointer';
    rect.onclick = function(e) {
      e.stopPropagation();
      const nodeName = this.getAttribute('data-name') || this.parentElement?.getAttribute('data-name');
      if (nodeName) showNodeEditorForName(nodeName);
    };
  });
  
  // Add click handlers to labels
  svg.querySelectorAll('text').forEach(text => {
    text.style.cursor = 'pointer';
    text.onclick = function(e) {
      e.stopPropagation();
      const nodeName = this.textContent?.trim();
      if (nodeName) showNodeEditorForName(nodeName);
    };
  });
}

function showNodeEditorForName(nodeName) {
  // Find the row in the data table that contains this node
  const tbody = document.getElementById('data-table-body');
  const rows = tbody.querySelectorAll('tr');
  
  for (const row of rows) {
    const inputs = row.querySelectorAll('input');
    if (inputs[0].value === nodeName || inputs[1].value === nodeName) {
      document.getElementById('node-edit-label').value = nodeName;
      document.getElementById('node-edit-line2').value = inputs[2].value;
      document.getElementById('node-edit-line3').value = inputs[3].value;
      document.getElementById('node-edit-color').value = inputs[4].value || '#888888';
      currentEditingNode = row;
      document.getElementById('node-editor').style.display = 'block';
      return;
    }
  }
  
  // Node not found in table, show empty editor
  document.getElementById('node-edit-label').value = nodeName;
  document.getElementById('node-edit-line2').value = '';
  document.getElementById('node-edit-line3').value = '';
  document.getElementById('node-edit-color').value = '#888888';
  currentEditingNode = null;
  document.getElementById('node-editor').style.display = 'block';
}

// ============ LABEL DRAGGING ============
let labelPositions = {}; // Store custom label positions
let selectedLabels = new Set(); // Multi-select labels
let labelDragState = {
  isDragging: false,
  startX: 0,
  startY: 0,
  origPositions: {}
};
let labelDragInitialized = false;

function initLabelDragging() {
  const svg = document.getElementById('sankey_svg');
  if (!svg) return;
  
  // Mark labels as draggable
  svg.querySelectorAll('text').forEach(text => {
    text.style.cursor = 'move';
    text.setAttribute('data-draggable', 'true');
  });
  
  // Only add global listeners once
  if (!labelDragInitialized) {
    labelDragInitialized = true;
    
    // Global mousemove handler
    document.addEventListener('mousemove', function(e) {
      if (!labelDragState.isDragging) return;
      
      let dx = (e.clientX - labelDragState.startX) / currentZoom;
      let dy = (e.clientY - labelDragState.startY) / currentZoom;
      
      // Shift key constrains to one direction
      if (e.shiftKey) {
        if (Math.abs(dx) > Math.abs(dy)) {
          dy = 0; // Horizontal only
        } else {
          dx = 0; // Vertical only
        }
      }
      
      // Move all dragged labels
      for (const [labelText, pos] of Object.entries(labelDragState.origPositions)) {
        if (pos.el) {
          const newX = pos.x + dx;
          const newY = pos.y + dy;
          pos.el.setAttribute('x', newX);
          pos.el.setAttribute('y', newY);
        }
      }
    });
    
    // Global mouseup handler
    document.addEventListener('mouseup', function(e) {
      if (!labelDragState.isDragging) return;
      labelDragState.isDragging = false;
      
      // Save positions for all moved labels
      for (const [labelText, pos] of Object.entries(labelDragState.origPositions)) {
        if (pos.el) {
          labelPositions[labelText] = {
            x: parseFloat(pos.el.getAttribute('x')),
            y: parseFloat(pos.el.getAttribute('y'))
          };
        }
      }
      saveProgressToLocal();
      labelDragState.origPositions = {};
    });
  }
}

// Handle mousedown on SVG - called via onclick in setupLabelInteraction
function handleLabelMouseDown(e, text) {
  if (e.button !== 0) return; // Only left click
  
  // Ctrl/Cmd click for multi-select
  if (e.ctrlKey || e.metaKey) {
    e.preventDefault();
    e.stopPropagation();
    const labelText = text.textContent?.trim();
    if (selectedLabels.has(labelText)) {
      selectedLabels.delete(labelText);
      text.style.outline = '';
    } else {
      selectedLabels.add(labelText);
      text.style.outline = '2px solid #1a73e8';
    }
    return;
  }
  
  // Start dragging
  labelDragState.isDragging = true;
  labelDragState.startX = e.clientX;
  labelDragState.startY = e.clientY;
  
  const svg = document.getElementById('sankey_svg');
  const labelText = text.textContent?.trim();
  labelDragState.origPositions = {};
  
  if (selectedLabels.size > 0 && selectedLabels.has(labelText)) {
    // Drag all selected labels
    svg.querySelectorAll('text').forEach(t => {
      const lt = t.textContent?.trim();
      if (selectedLabels.has(lt)) {
        labelDragState.origPositions[lt] = {
          el: t,
          x: parseFloat(t.getAttribute('x')) || 0,
          y: parseFloat(t.getAttribute('y')) || 0
        };
      }
    });
  } else {
    // Drag only this label
    labelDragState.origPositions[labelText] = {
      el: text,
      x: parseFloat(text.getAttribute('x')) || 0,
      y: parseFloat(text.getAttribute('y')) || 0
    };
  }
  
  e.preventDefault();
  e.stopPropagation();
}

// Handle double-click to reset label position
function handleLabelDblClick(e, text) {
  const labelText = text.textContent?.trim();
  if (labelText && labelPositions[labelText]) {
    delete labelPositions[labelText];
    selectedLabels.delete(labelText);
    text.style.outline = '';
    saveProgressToLocal();
    renderDiagram();
  }
}

// Setup label interaction after each render
function setupLabelInteraction() {
  const svg = document.getElementById('sankey_svg');
  if (!svg) return;
  
  svg.querySelectorAll('text').forEach(text => {
    text.style.cursor = 'move';
    text.onmousedown = (e) => handleLabelMouseDown(e, text);
    text.ondblclick = (e) => handleLabelDblClick(e, text);
  });
  
  // Click on canvas background to deselect
  svg.onclick = function(e) {
    if (e.target === svg || e.target.tagName === 'rect' || e.target.tagName === 'path') {
      clearLabelSelection();
    }
  };
}

function clearLabelSelection() {
  const svg = document.getElementById('sankey_svg');
  if (svg) {
    svg.querySelectorAll('text').forEach(t => {
      t.style.outline = '';
    });
  }
  selectedLabels.clear();
}

// Apply saved label positions after render
function applyLabelPositions() {
  const svg = document.getElementById('sankey_svg');
  if (!svg) return;
  
  svg.querySelectorAll('text').forEach(text => {
    const labelText = text.textContent?.trim();
    if (labelText && labelPositions[labelText]) {
      text.setAttribute('x', labelPositions[labelText].x);
      text.setAttribute('y', labelPositions[labelText].y);
    }
  });
}

// ============ SAVE/LOAD PROGRESS ============
const STORAGE_KEY = 'sankey_diagram_progress';

function saveProgressToLocal() {
  const progress = {
    title: document.getElementById('diagram-title-input').value,
    flows: document.getElementById('flows_in').value,
    tableData: getTableData(),
    options: getOptionsState(),
    labelPositions: labelPositions,
    nodeColors: nodeColors,
    zoom: currentZoom,
    savedAt: new Date().toISOString()
  };
  localStorage.setItem(STORAGE_KEY, JSON.stringify(progress));
  console.log('Progress saved');
}

function loadProgressFromLocal() {
  const saved = localStorage.getItem(STORAGE_KEY);
  if (!saved) return false;
  
  try {
    const progress = JSON.parse(saved);
    
    // Restore title
    if (progress.title) {
      document.getElementById('diagram-title-input').value = progress.title;
    }
    
    // Restore flows
    if (progress.flows) {
      document.getElementById('flows_in').value = progress.flows;
    }
    
    // Restore table data
    if (progress.tableData && progress.tableData.length > 0) {
      const tbody = document.getElementById('data-table-body');
      tbody.innerHTML = '';
      progress.tableData.forEach(row => {
        addDataRowWithValues(row.from, row.to, row.amount, row.comparison, row.color);
      });
    }
    
    // Restore options
    if (progress.options) {
      restoreOptionsState(progress.options);
    }
    
    // Restore label positions
    if (progress.labelPositions) {
      labelPositions = progress.labelPositions;
    }
    
    // Restore node colors
    if (progress.nodeColors) {
      nodeColors = progress.nodeColors;
    }
    
    // Restore zoom
    if (progress.zoom) {
      currentZoom = progress.zoom;
      document.getElementById('chart').style.transform = `scale(${currentZoom})`;
      document.getElementById('zoom-level').textContent = Math.round(currentZoom * 100) + '%';
    }
    
    console.log('Progress loaded from', progress.savedAt);
    return true;
  } catch (e) {
    console.error('Failed to load progress:', e);
    return false;
  }
}

function getTableData() {
  const tbody = document.getElementById('data-table-body');
  const rows = tbody.querySelectorAll('tr');
  const data = [];
  rows.forEach(row => {
    const inputs = row.querySelectorAll('input');
    data.push({
      from: inputs[0].value,
      to: inputs[1].value,
      amount: inputs[2].value,
      comparison: inputs[3]?.value || '',
      color: inputs[4]?.value || ''
    });
  });
  return data;
}

function getOptionsState() {
  const options = {};
  const optionIds = [
    'opt_labelname_appears', 'opt_labelvalue_appears', 'opt_labels_comparisonline',
    'opt_labelname_size', 'opt_labels_color', 'opt_labels_fontface', 'opt_labels_googlefont',
    'opt_labels_opacity', 'opt_labels_align', 'opt_labels_decimalplaces',
    'opt_value_prefix', 'opt_value_suffix',
    'opt_node_w', 'opt_node_h', 'opt_node_spacing', 'opt_node_border', 'opt_node_opacity',
    'opt_node_theme', 'opt_node_color',
    'opt_flow_opacity', 'opt_flow_curvature', 'opt_flow_color',
    'opt_size_w', 'opt_size_h',
    'opt_margin_l', 'opt_margin_r', 'opt_margin_t', 'opt_margin_b',
    'opt_bg_color', 'opt_bg_transparent'
  ];
  
  optionIds.forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      options[id] = el.type === 'checkbox' ? el.checked : el.value;
    }
  });
  
  // Radio buttons
  ['opt_flow_outside_in', 'opt_flow_source', 'opt_flow_target', 'opt_flow_single',
   'opt_layout_automatic', 'opt_layout_exact'].forEach(id => {
    const el = document.getElementById(id);
    if (el) options[id] = el.checked;
  });
  
  return options;
}

function restoreOptionsState(options) {
  for (const [id, value] of Object.entries(options)) {
    const el = document.getElementById(id);
    if (el) {
      if (el.type === 'checkbox' || el.type === 'radio') {
        el.checked = value;
      } else {
        el.value = value;
      }
    }
  }
}

// Auto-save on changes
function setupAutoSave() {
  // Save on title change
  document.getElementById('diagram-title-input').addEventListener('change', saveProgressToLocal);
  
  // Save periodically (every 30 seconds)
  setInterval(saveProgressToLocal, 30000);
  
  // Save before unload
  window.addEventListener('beforeunload', saveProgressToLocal);
}

// ============ ENHANCED INITIALIZATION ============
document.addEventListener('DOMContentLoaded', function() {
  loadSettings();
  
  // Try to load saved progress
  const hasProgress = loadProgressFromLocal();
  
  if (!hasProgress) {
    initializeDataTable();
  }
  
  syncOptionsFromForm();
  setupAutoSave();
  
  // Wait for sankeymatic.js to load, then render
  setTimeout(() => {
    renderDiagram();
    // Save initial state for undo
    saveStateForUndo();
    // Setup label dragging after render
    setTimeout(() => {
      initLabelDragging();
      setupLabelInteraction();
      applyLabelPositions();
    }, 500);
  }, 500);
  
  // Re-init label interaction and click handlers after each render
  const observer = new MutationObserver(function() {
    setTimeout(() => {
      initLabelDragging();
      setupLabelInteraction();
      applyLabelPositions();
      setupClickToEdit();
    }, 100);
  });
  observer.observe(document.getElementById('chart') || document.body, { childList: true, subtree: true });
});

// Override renderDiagram to apply label positions after
const originalRenderDiagram = renderDiagram;
renderDiagram = function() {
  originalRenderDiagram();
  setTimeout(applyLabelPositions, 200);
};
</script>

</body>
</html>
