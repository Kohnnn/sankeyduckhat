<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8">
<meta name="viewport" content="initial-scale=1">
<title>Sankey Diagram Builder</title>
<link rel="stylesheet" href="build.css?v=5">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&family=Manrope:wght@200..800&display=swap" rel="stylesheet">
<!-- Core dependencies -->
<script defer src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/canvg@3/lib/umd.js" crossorigin="anonymous"></script>
<!-- SankeyMATIC core -->
<script defer src="constants.js?v=5"></script>
<script defer src="sankey.js?v=5"></script>
<script defer src="lz-string.min.js?v=5"></script>
<script defer src="color_palettes.js?v=5"></script>
<script defer src="templates.js?v=5"></script>
<script defer src="sankeymatic.js?v=5"></script>
<style>
* { box-sizing: border-box; }
body { margin: 0; font-family: 'Inter', 'Manrope', sans-serif; font-size: 13px; background: #f5f5f5; }
.app-container { display: flex; flex-direction: column; height: 100vh; overflow: hidden; }

/* Menu Bar */
.menu-bar { display: flex; background: #fff; border-bottom: 1px solid #e0e0e0; padding: 0; align-items: center; height: 40px; flex-shrink: 0; }
.menu-item { position: relative; padding: 10px 16px; cursor: pointer; font-size: 13px; color: #333; border: none; background: none; font-family: inherit; height: 100%; display: flex; align-items: center; }
.menu-item:hover { background: #f0f0f0; }
.menu-dropdown { display: none; position: absolute; top: 100%; left: 0; background: #fff; border: 1px solid #e0e0e0; box-shadow: 0 4px 12px rgba(0,0,0,0.15); min-width: 280px; z-index: 1000; max-height: 80vh; overflow-y: auto; }
.menu-item:hover .menu-dropdown { display: block; }
.menu-section-title { padding: 8px 16px; font-weight: 600; color: #666; background: #f8f8f8; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; }
.menu-dropdown-item { display: flex; align-items: center; padding: 8px 16px; cursor: pointer; font-size: 13px; gap: 8px; }
.menu-dropdown-item:hover { background: #f5f5f5; }
.menu-dropdown-item input[type="checkbox"] { margin: 0; }
.menu-dropdown-item input[type="number"], .menu-dropdown-item input[type="text"], .menu-dropdown-item select { padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; }
.menu-dropdown-item input[type="color"] { width: 30px; height: 24px; padding: 0; border: 1px solid #ddd; }
.menu-dropdown-item label { flex: 1; }
.menu-divider { height: 1px; background: #e0e0e0; margin: 4px 0; }
.menu-spacer { flex: 1; }
.menu-btn { padding: 6px 12px; margin: 0 8px; background: #1a73e8; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; }
.menu-btn:hover { background: #1557b0; }
.menu-btn.secondary { background: #f1f3f4; color: #333; }
.menu-btn.secondary:hover { background: #e8eaed; }

/* Main Content */
.main-content { display: flex; flex: 1; overflow: hidden; }
</style>
</head>
<body>
<div class="app-container">
<style>
/* Diagram Panel */
.diagram-panel { flex: 1; display: flex; flex-direction: column; background: #fff; overflow: hidden; }
.diagram-title-bar { padding: 12px 20px; border-bottom: 1px solid #e0e0e0; background: #fafafa; }
.diagram-title-input { border: none; font-size: 20px; font-weight: 600; width: 100%; background: transparent; text-align: center; }
.diagram-title-input:focus { outline: 2px solid #1a73e8; border-radius: 4px; }
.diagram-area { flex: 1; display: flex; justify-content: center; align-items: center; overflow: auto; padding: 20px; background: #fff; position: relative; }
#chart_container { position: relative; }
.diagram-footer { padding: 8px 20px; text-align: center; font-size: 11px; color: #999; border-top: 1px solid #e0e0e0; background: #fafafa; }

/* Right Panel */
.right-panel { width: 480px; min-width: 480px; border-left: 1px solid #e0e0e0; display: flex; flex-direction: column; background: #fff; overflow: hidden; }
.panel-header { padding: 12px 16px; font-weight: 600; font-size: 14px; background: #f8f9fa; border-bottom: 1px solid #e0e0e0; display: flex; align-items: center; justify-content: space-between; }
.panel-header-actions { display: flex; gap: 8px; }
.panel-header-actions button { padding: 4px 10px; font-size: 11px; border: 1px solid #ddd; background: #fff; border-radius: 4px; cursor: pointer; }
.panel-header-actions button:hover { background: #f5f5f5; }

/* Data Table */
.data-table-wrapper { flex: 1; overflow: auto; }
.data-table { width: 100%; border-collapse: collapse; font-size: 12px; }
.data-table th { background: #f1f3f4; padding: 10px 8px; text-align: left; font-weight: 500; color: #5f6368; border-bottom: 1px solid #e0e0e0; position: sticky; top: 0; z-index: 10; }
.data-table td { padding: 4px; border-bottom: 1px solid #f0f0f0; }
.data-table input { width: 100%; border: 1px solid transparent; padding: 6px 8px; font-size: 12px; background: transparent; border-radius: 4px; }
.data-table input:focus { border-color: #1a73e8; outline: none; background: #fff; }
.data-table .delete-btn { color: #dc3545; cursor: pointer; padding: 4px 8px; border: none; background: none; font-size: 16px; }
.data-table .delete-btn:hover { background: #fee; border-radius: 4px; }
.add-row-section { padding: 12px 16px; border-top: 1px solid #e0e0e0; display: flex; align-items: center; gap: 8px; background: #fafafa; }
.add-row-btn { padding: 6px 12px; border: 1px solid #ddd; background: #fff; cursor: pointer; font-size: 12px; border-radius: 4px; display: flex; align-items: center; gap: 4px; }
.add-row-btn:hover { background: #f5f5f5; }

/* AI Section */
.ai-section { border-top: 1px solid #e0e0e0; background: #f8f9fa; }
.ai-section-header { padding: 12px 16px; font-weight: 600; font-size: 13px; display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid #e0e0e0; background: #fff; }
.ai-settings-btn { padding: 4px 8px; background: none; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 12px; }
.ai-settings-btn:hover { background: #f5f5f5; }
.ai-chat-area { padding: 12px 16px; }
.ai-chat-input-wrapper { display: flex; gap: 8px; margin-bottom: 8px; }
.ai-chat-input { flex: 1; padding: 10px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 13px; resize: none; min-height: 60px; }
.ai-chat-input:focus { outline: none; border-color: #1a73e8; }
.ai-chat-btn { padding: 10px 20px; background: #1a73e8; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; align-self: flex-end; }
.ai-chat-btn:hover { background: #1557b0; }
.ai-chat-btn:disabled { background: #ccc; cursor: not-allowed; }
.ai-status { font-size: 12px; padding: 8px 0; }
.ai-status.success { color: #0d6efd; }
.ai-status.error { color: #dc3545; }
.ai-status.warning { color: #fd7e14; }

/* Status Bar */
.status-bar { padding: 10px 20px; background: #e8f5e9; border-top: 1px solid #c8e6c9; display: flex; align-items: center; gap: 8px; font-size: 13px; color: #2e7d32; flex-shrink: 0; }
.status-bar.warning { background: #fff3e0; border-color: #ffe0b2; color: #e65100; }
.status-bar.error { background: #ffebee; border-color: #ffcdd2; color: #c62828; }
</style>
<style>
/* Node Customization Popup */
.node-popup-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.3); z-index: 2000; }
.node-popup-overlay.active { display: flex; justify-content: center; align-items: center; }
.node-popup { background: #fff; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.2); width: 380px; max-width: 95%; max-height: 90vh; overflow: auto; }
.node-popup-header { padding: 16px 20px; border-bottom: 1px solid #e0e0e0; display: flex; justify-content: space-between; align-items: center; background: #f8f9fa; border-radius: 12px 12px 0 0; }
.node-popup-header h3 { margin: 0; font-size: 16px; font-weight: 600; }
.node-popup-close { background: none; border: none; font-size: 24px; cursor: pointer; color: #666; padding: 0; line-height: 1; }
.node-popup-body { padding: 20px; }
.node-popup-section { margin-bottom: 20px; }
.node-popup-section h4 { margin: 0 0 12px; font-size: 13px; font-weight: 600; color: #333; text-transform: uppercase; letter-spacing: 0.5px; }
.node-popup-row { display: flex; align-items: center; gap: 12px; margin-bottom: 12px; }
.node-popup-row label { flex: 0 0 100px; font-size: 13px; color: #666; }
.node-popup-row input[type="text"], .node-popup-row input[type="number"] { flex: 1; padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 13px; }
.node-popup-row input[type="color"] { width: 50px; height: 36px; padding: 2px; border: 1px solid #ddd; border-radius: 6px; cursor: pointer; }
.node-popup-row input:focus { outline: none; border-color: #1a73e8; }
.node-popup-toggle { display: flex; align-items: center; gap: 8px; }
.node-popup-toggle input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; }
.node-popup-alignment { display: flex; gap: 4px; }
.node-popup-alignment button { padding: 8px 12px; border: 1px solid #ddd; background: #fff; cursor: pointer; font-size: 12px; }
.node-popup-alignment button:first-child { border-radius: 6px 0 0 6px; }
.node-popup-alignment button:last-child { border-radius: 0 6px 6px 0; }
.node-popup-alignment button.active { background: #1a73e8; color: white; border-color: #1a73e8; }
.node-popup-footer { padding: 16px 20px; border-top: 1px solid #e0e0e0; display: flex; justify-content: flex-end; gap: 8px; background: #f8f9fa; border-radius: 0 0 12px 12px; }
.btn { padding: 10px 20px; border-radius: 6px; font-size: 13px; cursor: pointer; font-weight: 500; }
.btn-secondary { background: #f1f3f4; border: 1px solid #ddd; color: #333; }
.btn-primary { background: #1a73e8; border: 1px solid #1a73e8; color: white; }
.btn:hover { opacity: 0.9; }

/* Modal Overlay */
.modal-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 2000; justify-content: center; align-items: center; }
.modal-overlay.active { display: flex; }
.modal { background: #fff; border-radius: 12px; width: 500px; max-width: 90%; max-height: 90vh; overflow: auto; box-shadow: 0 8px 32px rgba(0,0,0,0.2); }
.modal-header { padding: 16px 20px; border-bottom: 1px solid #e0e0e0; display: flex; justify-content: space-between; align-items: center; position: sticky; top: 0; background: #fff; }
.modal-header h3 { margin: 0; font-size: 16px; }
.modal-close { background: none; border: none; font-size: 24px; cursor: pointer; color: #666; padding: 0; line-height: 1; }
.modal-body { padding: 20px; }
.form-group { margin-bottom: 16px; }
.form-group label { display: block; margin-bottom: 6px; font-size: 13px; font-weight: 500; }
.form-group input, .form-group select, .form-group textarea { width: 100%; padding: 10px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 13px; }
.form-group input:focus, .form-group select:focus, .form-group textarea:focus { outline: none; border-color: #1a73e8; }
.form-group .hint { font-size: 11px; color: #666; margin-top: 4px; }
.form-group .hint a { color: #1a73e8; }
.modal-footer { padding: 16px 20px; border-top: 1px solid #e0e0e0; display: flex; justify-content: flex-end; gap: 8px; position: sticky; bottom: 0; background: #fff; }

/* JSON Editor Modal */
.json-editor-modal { width: 700px; }
.json-editor-textarea { font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; font-size: 12px; min-height: 300px; resize: vertical; }
.json-editor-actions { display: flex; gap: 8px; margin-bottom: 12px; }

/* Multi-image upload */
.image-upload-area { border: 2px dashed #ddd; border-radius: 8px; padding: 20px; text-align: center; cursor: pointer; transition: all 0.2s; }
.image-upload-area:hover { border-color: #1a73e8; background: #f8f9ff; }
.image-upload-area.dragover { border-color: #1a73e8; background: #e3f2fd; }
.image-previews { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 12px; }
.image-preview-item { position: relative; width: 80px; height: 80px; border-radius: 8px; overflow: hidden; border: 1px solid #ddd; }
.image-preview-item img { width: 100%; height: 100%; object-fit: cover; }
.image-preview-item .remove-btn { position: absolute; top: 2px; right: 2px; width: 20px; height: 20px; background: rgba(220,53,69,0.9); color: white; border: none; border-radius: 50%; cursor: pointer; font-size: 12px; line-height: 1; }
.upload-progress { margin-top: 8px; }
.progress-bar { height: 4px; background: #e0e0e0; border-radius: 2px; overflow: hidden; }
.progress-bar-fill { height: 100%; background: #1a73e8; transition: width 0.3s; }

/* Hide old elements */
.header, .footer, .center_basic, .skm_grid { display: none !important; }
</style>

  <!-- Menu Bar -->
  <div class="menu-bar">
    <div class="menu-item">
      File
      <div class="menu-dropdown">
        <div class="menu-dropdown-item" onclick="newDiagram()">üìÑ New Diagram</div>
        <div class="menu-dropdown-item" onclick="document.getElementById('load_file_input').click()">üìÇ Open File...</div>
        <div class="menu-dropdown-item" onclick="saveDiagramToFile()">üíæ Save As...</div>
        <div class="menu-divider"></div>
        <div class="menu-dropdown-item" onclick="saveDiagramAsPNG(2)">üñºÔ∏è Export as PNG</div>
        <div class="menu-dropdown-item" onclick="saveDiagramAsPNG(4)">üñºÔ∏è Export as PNG (Large)</div>
        <div class="menu-dropdown-item" onclick="saveDiagramAsSVG()">üìê Export as SVG</div>
      </div>
    </div>
    
    <div class="menu-item">
      Labels
      <div class="menu-dropdown">
        <div class="menu-section-title">Display</div>
        <div class="menu-dropdown-item"><input type="checkbox" id="opt_labelname_appears" checked onchange="updateOption()"><label for="opt_labelname_appears">Show Names</label></div>
        <div class="menu-dropdown-item"><input type="checkbox" id="opt_labelvalue_appears" checked onchange="updateOption()"><label for="opt_labelvalue_appears">Show Values</label></div>
        <div class="menu-dropdown-item"><input type="checkbox" id="opt_labels_comparisonline" onchange="updateOption()"><label for="opt_labels_comparisonline">Show Comparison %</label></div>
        <div class="menu-divider"></div>
        <div class="menu-section-title">Typography</div>
        <div class="menu-dropdown-item"><label>Font Size</label><input type="number" id="opt_labelname_size" value="16" min="8" max="36" style="width:60px" onchange="updateOption()"></div>
        <div class="menu-dropdown-item"><label>Color</label><input type="color" id="opt_labels_color" value="#000000" onchange="updateOption()"></div>
        <div class="menu-dropdown-item"><label>Font</label><select id="opt_labels_fontface" onchange="updateFontOption()" style="width:120px"><option value="sans-serif">Sans-serif</option><option value="serif">Serif</option><option value="monospace">Monospace</option></select></div>
        <div class="menu-dropdown-item"><label>Google Font</label><select id="opt_labels_googlefont" onchange="updateOption()" style="width:120px"><option value="">None</option><option value="Inter">Inter</option><option value="Manrope">Manrope</option><option value="Roboto">Roboto</option><option value="Open Sans">Open Sans</option><option value="Lato">Lato</option><option value="Montserrat">Montserrat</option><option value="Poppins">Poppins</option></select></div>
        <div class="menu-divider"></div>
        <div class="menu-section-title">Number Format</div>
        <div class="menu-dropdown-item"><label>Decimal Places</label><select id="opt_labels_decimalplaces" onchange="updateOption()" style="width:60px"><option value="0">0</option><option value="1">1</option><option value="2" selected>2</option></select></div>
        <div class="menu-dropdown-item"><label>Prefix</label><input type="text" id="opt_value_prefix" value="" style="width:60px" onchange="updateOption()" placeholder="$"></div>
        <div class="menu-dropdown-item"><label>Suffix</label><input type="text" id="opt_value_suffix" value="" style="width:60px" onchange="updateOption()"></div>
      </div>
    </div>
    
    <div class="menu-item">
      Nodes
      <div class="menu-dropdown">
        <div class="menu-section-title">Dimensions</div>
        <div class="menu-dropdown-item"><label>Width</label><input type="number" id="opt_node_w" value="12" min="0" max="100" style="width:60px" onchange="updateOption()"></div>
        <div class="menu-dropdown-item"><label>Height %</label><input type="number" id="opt_node_h" value="50" min="0" max="100" style="width:60px" onchange="updateOption()"></div>
        <div class="menu-dropdown-item"><label>Spacing %</label><input type="number" id="opt_node_spacing" value="75" min="0" max="100" style="width:60px" onchange="updateOption()"></div>
        <div class="menu-dropdown-item"><label>Border</label><input type="number" id="opt_node_border" value="0" min="0" max="10" style="width:60px" onchange="updateOption()"></div>
        <div class="menu-dropdown-item"><label>Opacity %</label><input type="number" id="opt_node_opacity" value="100" min="0" max="100" style="width:60px" onchange="updateOption()"></div>
        <div class="menu-divider"></div>
        <div class="menu-section-title">Colors</div>
        <div class="menu-dropdown-item"><label>Theme</label><select id="opt_node_theme" onchange="updateOption()" style="width:100px"><option value="a">Theme A</option><option value="b">Theme B</option><option value="c">Theme C</option><option value="d">Theme D</option><option value="none">Single Color</option></select></div>
        <div class="menu-dropdown-item"><label>Single Color</label><input type="color" id="opt_node_color" value="#888888" onchange="updateOption()"></div>
      </div>
    </div>
    
    <div class="menu-item">
      Flows
      <div class="menu-dropdown">
        <div class="menu-section-title">Appearance</div>
        <div class="menu-dropdown-item"><label>Opacity %</label><input type="number" id="opt_flow_opacity" value="45" min="0" max="100" style="width:60px" onchange="updateOption()"></div>
        <div class="menu-dropdown-item"><label>Curviness %</label><input type="number" id="opt_flow_curvature" value="50" min="10" max="90" style="width:60px" onchange="updateOption()"></div>
        <div class="menu-divider"></div>
        <div class="menu-section-title">Color Source</div>
        <div class="menu-dropdown-item"><input type="radio" name="flow_color" id="opt_flow_outside_in" checked onchange="updateOption()"><label for="opt_flow_outside_in">From outermost nodes</label></div>
        <div class="menu-dropdown-item"><input type="radio" name="flow_color" id="opt_flow_source" onchange="updateOption()"><label for="opt_flow_source">From source node</label></div>
        <div class="menu-dropdown-item"><input type="radio" name="flow_color" id="opt_flow_target" onchange="updateOption()"><label for="opt_flow_target">From target node</label></div>
        <div class="menu-dropdown-item"><input type="radio" name="flow_color" id="opt_flow_single" onchange="updateOption()"><label for="opt_flow_single">Single color</label><input type="color" id="opt_flow_color" value="#999999" onchange="updateOption()"></div>
      </div>
    </div>
    
    <div class="menu-item">
      Layout
      <div class="menu-dropdown">
        <div class="menu-section-title">Diagram Size</div>
        <div class="menu-dropdown-item"><label>Width</label><input type="number" id="opt_size_w" value="700" min="100" max="2000" style="width:80px" onchange="updateOption()"></div>
        <div class="menu-dropdown-item"><label>Height</label><input type="number" id="opt_size_h" value="500" min="100" max="2000" style="width:80px" onchange="updateOption()"></div>
        <div class="menu-divider"></div>
        <div class="menu-section-title">Margins</div>
        <div class="menu-dropdown-item"><label>Left</label><input type="number" id="opt_margin_l" value="80" min="0" style="width:50px" onchange="updateOption()"><label>Right</label><input type="number" id="opt_margin_r" value="80" min="0" style="width:50px" onchange="updateOption()"></div>
        <div class="menu-dropdown-item"><label>Top</label><input type="number" id="opt_margin_t" value="30" min="0" style="width:50px" onchange="updateOption()"><label>Bottom</label><input type="number" id="opt_margin_b" value="30" min="0" style="width:50px" onchange="updateOption()"></div>
        <div class="menu-divider"></div>
        <div class="menu-section-title">Background</div>
        <div class="menu-dropdown-item"><label>Color</label><input type="color" id="opt_bg_color" value="#FFFFFF" onchange="updateOption()"><input type="checkbox" id="opt_bg_transparent" onchange="updateOption()"><label for="opt_bg_transparent">Transparent</label></div>
        <div class="menu-divider"></div>
        <div class="menu-dropdown-item" onclick="resetAllNodes()">üîÑ Reset Node Positions</div>
        <div class="menu-dropdown-item" onclick="resetAllLabels()">üîÑ Reset Label Positions</div>
      </div>
    </div>
    
    <div class="menu-spacer"></div>
    <button class="menu-btn secondary" onclick="openJSONEditor()">üìã JSON Editor</button>
    <button class="menu-btn secondary" onclick="openSettingsModal()">‚öôÔ∏è AI Settings</button>
  </div>

  <!-- Main Content -->
  <div class="main-content">
    <!-- Diagram Panel -->
    <div class="diagram-panel">
      <div class="diagram-title-bar">
        <input type="text" class="diagram-title-input" id="diagram-title-input" value="My Sankey Diagram" placeholder="Enter diagram title...">
      </div>
      
      <!-- Canvas Controls -->
      <div class="canvas-controls" style="padding:8px 20px;display:flex;gap:8px;align-items:center;border-bottom:1px solid #e0e0e0;background:#fafafa;">
        <button class="add-row-btn" onclick="zoomCanvas(-0.1)" title="Zoom Out">‚ûñ</button>
        <span id="zoom-level" style="font-size:12px;min-width:50px;text-align:center;">100%</span>
        <button class="add-row-btn" onclick="zoomCanvas(0.1)" title="Zoom In">‚ûï</button>
        <button class="add-row-btn" onclick="resetZoom()" title="Reset Zoom">üîÑ Reset</button>
        <div style="flex:1;"></div>
        <button class="add-row-btn" onclick="undoLastAction()" title="Undo">‚Ü©Ô∏è Undo</button>
        <button class="add-row-btn" onclick="resetAllNodes()">Reset Nodes</button>
        <button class="add-row-btn" onclick="resetAllLabels()">Reset Labels</button>
      </div>
      
      <div class="diagram-area" id="diagram-area" style="overflow:auto;">
        <div id="chart" style="transform-origin:center center;transition:transform 0.2s;">
          <svg id="sankey_svg" height="500" width="700" xmlns="http://www.w3.org/2000/svg"></svg>
        </div>
        <svg id="svg_scratch" height="500" width="700" xmlns="http://www.w3.org/2000/svg" style="display:none;"></svg>
        <canvas id="png_preview" height="500" width="700" style="display:none;"></canvas>
      </div>
      
      <div class="diagram-footer">
        ‚úèÔ∏è Click on any node to customize ‚Ä¢ Drag nodes and labels freely ‚Ä¢ Double-click to reset position
      </div>
    </div>

    <!-- Right Panel - Data Editor -->
    <div class="right-panel">
      <div class="panel-header">
        <span>Data Editor</span>
        <div class="panel-header-actions">
          <button onclick="exportCSV()">Export CSV</button>
          <button onclick="document.getElementById('csv_import').click()">Import CSV</button>
        </div>
      </div>
      
      <div class="data-table-wrapper">
        <table class="data-table">
          <thead>
            <tr>
              <th style="width:25%">From</th>
              <th style="width:25%">To</th>
              <th style="width:20%">Amount</th>
              <th style="width:15%">Comparison</th>
              <th style="width:15%"></th>
            </tr>
          </thead>
          <tbody id="data-table-body"></tbody>
        </table>
      </div>
      
      <div class="add-row-section">
        <button class="add-row-btn" onclick="addDataRow()">+ Add</button>
        <input type="number" id="add-row-count" value="1" min="1" max="20" style="width:50px">
        <span>rows</span>
        <div style="flex:1"></div>
        <button class="add-row-btn" onclick="clearAllRows()">Clear All</button>
      </div>
      
      <!-- AI Section with Multi-Image Upload -->
      <div class="ai-section">
        <div class="ai-section-header">
          <span>ü§ñ AI Assistant</span>
          <button class="ai-settings-btn" onclick="openSettingsModal()">‚öôÔ∏è Settings</button>
        </div>
        <div class="ai-chat-area">
          <!-- Chat History -->
          <div id="ai-chat-history" style="max-height:150px;overflow-y:auto;margin-bottom:8px;font-size:12px;border:1px solid #e0e0e0;border-radius:6px;padding:8px;background:#fff;min-height:50px;">
            <div style="color:#999;font-size:11px;text-align:center;">Chat with AI about your data, or upload images to extract flows</div>
          </div>
          
          <!-- Multi-Image Upload Area -->
          <div class="image-upload-area" id="image-upload-area" onclick="document.getElementById('ai-image-input').click()">
            <div>üì∑ Drop images here or click to upload</div>
            <div style="font-size:11px;color:#999;margin-top:4px;">Supports multiple images ‚Ä¢ Ctrl+V to paste</div>
          </div>
          <div class="image-previews" id="image-previews"></div>
          <div class="upload-progress" id="upload-progress" style="display:none;">
            <div class="progress-bar"><div class="progress-bar-fill" id="progress-bar-fill" style="width:0%"></div></div>
            <div style="font-size:11px;color:#666;margin-top:4px;" id="progress-text">Processing...</div>
          </div>
          
          <div class="ai-chat-input-wrapper" style="margin-top:12px;">
            <textarea class="ai-chat-input" id="ai-chat-input" placeholder="Describe your data, ask questions, or type 'parse: [data]' to extract flows..."></textarea>
          </div>
          <div style="display:flex;gap:8px;align-items:center;margin-top:8px;">
            <input type="file" id="ai-image-input" accept="image/*" multiple style="display:none" onchange="handleMultiImageUpload(event)">
            <button class="add-row-btn" onclick="pasteFromClipboard()" title="Paste from clipboard">üìã Paste</button>
            <button class="ai-chat-btn" id="ai-send-btn" onclick="processAIChat()">üí¨ Send</button>
            <div class="ai-status" id="ai-status"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Status Bar -->
  <div class="status-bar" id="status-bar">
    <span>‚úì</span>
    <span id="status-message">Ready - Add data to create your Sankey diagram</span>
  </div>
</div>

<!-- Node Customization Popup -->
<div class="node-popup-overlay" id="node-popup-overlay">
  <div class="node-popup">
    <div class="node-popup-header">
      <h3>‚úèÔ∏è Customize Node</h3>
      <button class="node-popup-close" onclick="closeNodePopup()">&times;</button>
    </div>
    <div class="node-popup-body">
      <div class="node-popup-section">
        <h4>Node Properties</h4>
        <div class="node-popup-row">
          <label>Name</label>
          <input type="text" id="popup-node-name" placeholder="Node name">
        </div>
        <div class="node-popup-row">
          <label>Fill Color</label>
          <input type="color" id="popup-node-fill" value="#888888">
        </div>
        <div class="node-popup-row">
          <label>Border Color</label>
          <input type="color" id="popup-node-border" value="#666666">
        </div>
        <div class="node-popup-row">
          <label>Opacity %</label>
          <input type="number" id="popup-node-opacity" value="100" min="0" max="100" style="width:80px">
        </div>
      </div>
      
      <div class="node-popup-section">
        <h4>Label Properties</h4>
        <div class="node-popup-row">
          <label>Label Text</label>
          <input type="text" id="popup-label-text" placeholder="Custom label">
        </div>
        <div class="node-popup-row">
          <label>Font Size</label>
          <input type="number" id="popup-label-fontsize" value="16" min="8" max="72" style="width:80px">
          <span style="font-size:11px;color:#666;">px</span>
        </div>
        <div class="node-popup-row">
          <label>Text Color</label>
          <input type="color" id="popup-label-color" value="#000000">
        </div>
        <div class="node-popup-row">
          <label>Alignment</label>
          <div class="node-popup-alignment">
            <button type="button" onclick="setLabelAlignment('left')" id="align-left">Left</button>
            <button type="button" onclick="setLabelAlignment('center')" id="align-center" class="active">Center</button>
            <button type="button" onclick="setLabelAlignment('right')" id="align-right">Right</button>
          </div>
        </div>
        <div class="node-popup-row">
          <label>Background</label>
          <input type="color" id="popup-label-bg" value="#ffffff">
          <div class="node-popup-toggle">
            <input type="checkbox" id="popup-label-bg-enabled">
            <span style="font-size:11px;">Enable BG</span>
          </div>
        </div>
        <div class="node-popup-row">
          <label>Box Width</label>
          <input type="number" id="popup-label-width" value="0" min="0" max="500" style="width:80px" placeholder="Auto">
          <span style="font-size:11px;color:#666;">0 = auto</span>
        </div>
        <div class="node-popup-row">
          <label>Box Height</label>
          <input type="number" id="popup-label-height" value="0" min="0" max="200" style="width:80px" placeholder="Auto">
          <span style="font-size:11px;color:#666;">0 = auto</span>
        </div>
      </div>
      
      <div class="node-popup-section">
        <h4>Position & Movement</h4>
        <div class="node-popup-row">
          <div class="node-popup-toggle">
            <input type="checkbox" id="popup-label-locked" checked>
            <label style="flex:none;">Lock label to node</label>
          </div>
        </div>
        <div class="node-popup-row">
          <label>X Offset</label>
          <input type="number" id="popup-label-x" value="0" style="width:80px">
        </div>
        <div class="node-popup-row">
          <label>Y Offset</label>
          <input type="number" id="popup-label-y" value="0" style="width:80px">
        </div>
      </div>
    </div>
    <div class="node-popup-footer">
      <button class="btn btn-secondary" onclick="resetNodeToDefault()">Reset to Default</button>
      <button class="btn btn-secondary" onclick="closeNodePopup()">Cancel</button>
      <button class="btn btn-primary" onclick="applyNodeCustomization()">Apply</button>
    </div>
  </div>
</div>

<!-- JSON Editor Modal -->
<div class="modal-overlay" id="json-editor-modal">
  <div class="modal json-editor-modal">
    <div class="modal-header">
      <h3>üìã JSON Data Editor</h3>
      <button class="modal-close" onclick="closeJSONEditor()">&times;</button>
    </div>
    <div class="modal-body">
      <div class="json-editor-actions">
        <button class="btn btn-secondary" onclick="copyJSONToClipboard()">üìã Copy to Clipboard</button>
        <button class="btn btn-secondary" onclick="pasteJSONFromClipboard()">üì• Paste from Clipboard</button>
        <button class="btn btn-secondary" onclick="formatJSON()">‚ú® Format</button>
      </div>
      <div class="form-group">
        <label>Diagram Data (JSON)</label>
        <textarea id="json-editor-textarea" class="json-editor-textarea" placeholder='{"flows": [{"from": "Source", "to": "Target", "amount": 100}]}'></textarea>
        <div class="hint">Edit the JSON directly or paste data from clipboard. AI can also modify this structure.</div>
      </div>
    </div>
    <div class="modal-footer">
      <button class="btn btn-secondary" onclick="closeJSONEditor()">Cancel</button>
      <button class="btn btn-primary" onclick="applyJSONData()">Apply Changes</button>
    </div>
  </div>
</div>

<!-- Settings Modal -->
<div class="modal-overlay" id="settings-modal">
  <div class="modal">
    <div class="modal-header">
      <h3>‚öôÔ∏è AI Settings</h3>
      <button class="modal-close" onclick="closeSettingsModal()">&times;</button>
    </div>
    <div class="modal-body">
      <div class="form-group">
        <label>Gemini API Key</label>
        <input type="password" id="gemini-api-key" placeholder="Enter your Gemini API key...">
        <div class="hint">Get your API key from <a href="https://aistudio.google.com/app/apikey" target="_blank">Google AI Studio</a></div>
      </div>
      <div class="form-group">
        <label>Model Name</label>
        <input type="text" id="ai-model" value="gemini-2.0-flash">
        <div class="hint">Common options: gemini-2.0-flash, gemini-1.5-pro, gemini-1.5-flash</div>
      </div>
      <div class="form-group">
        <label>System Prompt</label>
        <textarea id="ai-system-prompt" rows="8" style="font-size:11px;"></textarea>
        <div class="hint">Customize how the AI interprets your data.</div>
        <button type="button" class="btn btn-secondary" style="margin-top:8px;padding:6px 12px;font-size:11px;" onclick="resetSystemPrompt()">Reset to Default</button>
      </div>
    </div>
    <div class="modal-footer">
      <button class="btn btn-secondary" onclick="closeSettingsModal()">Cancel</button>
      <button class="btn btn-primary" onclick="saveSettings()">Save Settings</button>
    </div>
  </div>
</div>

<!-- Hidden inputs -->
<input type="file" id="load_file_input" accept=".txt,.skm" style="display:none" onchange="loadDiagramFile()">
<input type="file" id="csv_import" accept=".csv" style="display:none" onchange="importCSV(event)">

<!-- Hidden message areas required by sankeymatic.js -->
<div style="display:none">
  <div id="issue_messages"></div>
  <div id="imbalance_messages"></div>
  <div id="totals_area"></div>
  <div id="info_messages"></div>
  <div id="console_area"><div id="console_lines"></div></div>
  <span id="theme_a_guide"></span><span id="theme_a_label"></span>
  <span id="theme_b_guide"></span><span id="theme_b_label"></span>
  <span id="theme_c_guide"></span><span id="theme_c_label"></span>
  <span id="theme_d_guide"></span><span id="theme_d_label"></span>
  <button id="reset_all_moved_nodes"></button>
  <button id="reset_all_moved_labels"></button>
  <button id="save_as_png_1x" title=""></button>
  <button id="save_as_png_2x" title=""></button>
  <button id="save_as_png_4x" title=""></button>
  <button id="save_as_png_6x" title=""></button>
  <span id="scale_figures"></span>
  <div id="imbalances_area"></div>
</div>

<!-- Hidden textarea for DSL -->
<textarea id="flows_in" style="display:none">Wages [1500] Budget
Other [250] Budget
Budget [450] Taxes
Budget [420] Housing
Budget [400] Food
Budget [255] Transportation
Budget [160] Other Necessities
Budget [65] Savings</textarea>

<!-- Hidden form for compatibility with existing sankeymatic.js -->
<form id="skm_form" style="display:none">
  <input id="size_w" value="700"><input id="size_h" value="500">
  <input id="bg_color" value="#FFFFFF"><input type="checkbox" id="bg_transparent">
  <input id="margin_l" value="80"><input id="margin_r" value="80">
  <input id="margin_t" value="30"><input id="margin_b" value="30">
  <input id="node_w" value="12"><input id="node_h" value="50">
  <input id="node_spacing" value="75"><input id="node_border" value="0">
  <input id="node_opacity" value="1.0"><input id="node_color" value="#888888">
  <input id="flow_opacity" value="0.45"><input id="flow_curvature" value="0.5">
  <input id="flow_color" value="#999999">
  <input id="labelname_size" value="16"><input id="labels_color" value="#000000">
  <input type="checkbox" id="labelname_appears" checked>
  <input type="checkbox" id="labelvalue_appears" checked>
  <input type="checkbox" id="labels_comparisonline">
  <input id="labels_decimalplaces" value="2">
  <input id="value_prefix" value=""><input id="value_suffix" value="">
  <input id="value_format" value=",.">
  <input id="labels_hide" type="checkbox">
  <input id="labels_highlight" value="0.75">
  <input id="labels_googlefont_hidden" value="">
  <input id="labels_valuemode" value="absolute">
  <input id="labels_linespacing" value="0.15">
  <input id="labels_relativesize" value="100">
  <input id="labels_magnify" value="100">
  <input id="labelname_weight" value="400">
  <input id="labelvalue_fullprecision" type="checkbox" checked>
  <input id="labelvalue_weight" value="400">
  <input id="labelposition_autoalign" value="0">
  <input id="labelposition_breakpoint" value="9999">
  <input id="layout_justifyorigins" type="checkbox">
  <input id="layout_justifyends" type="checkbox">
  <input id="layout_reversegraph" type="checkbox">
  <input id="meta_mentionsankeymatic" type="checkbox">
  <input id="meta_listimbalances" type="checkbox" checked>
  <input id="internal_revealshadows" type="checkbox">
  <input type="radio" name="labels_fontface" id="labels_fontface_sans" value="sans-serif" checked>
  <input type="radio" name="labels_fontface" id="labels_fontface_serif" value="serif">
  <input type="radio" name="labels_fontface" id="labels_fontface_mono" value="monospace">
  <input type="radio" name="labelposition_scheme" id="labelposition_scheme_auto" value="auto" checked>
  <input type="radio" name="labelposition_scheme" id="labelposition_scheme_per_stage" value="per_stage">
  <input type="radio" name="labelposition_first" id="labelposition_first_before" value="before" checked>
  <input type="radio" name="labelposition_first" id="labelposition_first_after" value="after">
  <input type="radio" name="layout_attachincompletesto" id="layout_attach_leading" value="leading">
  <input type="radio" name="layout_attachincompletesto" id="layout_attach_nearest" value="nearest" checked>
  <input type="radio" name="layout_attachincompletesto" id="layout_attach_trailing" value="trailing">
  <input type="radio" name="labels_fontface" id="sans_serif" value="sans-serif" checked>
  <input type="radio" name="node_theme" id="theme_a_radio" value="a" checked>
  <input type="radio" name="node_theme" id="theme_b_radio" value="b">
  <input type="radio" name="node_theme" id="theme_c_radio" value="c">
  <input type="radio" name="node_theme" id="theme_d_radio" value="d">
  <input type="radio" name="node_theme" id="theme_none_radio" value="none">
  <input type="radio" name="flow_inheritfrom" id="flow_inherit_outside_in" value="outside-in" checked>
  <input type="radio" name="flow_inheritfrom" id="flow_inherit_from_source" value="source">
  <input type="radio" name="flow_inheritfrom" id="flow_inherit_from_target" value="target">
  <input type="radio" name="flow_inheritfrom" id="flow_inherit_none" value="none">
  <input type="radio" name="layout_order" id="layout_order_automatic" value="automatic" checked>
  <input type="radio" name="layout_order" id="layout_order_exact" value="exact">
  <input type="radio" name="labelvalue_position" id="labelvalue_below" value="below" checked>
  <input id="internal_iterations" value="25">
  <input id="themeoffset_a" value="6"><input id="themeoffset_b" value="0">
  <input id="themeoffset_c" value="0"><input id="themeoffset_d" value="0">
  <input id="labels_fontface" value="sans-serif">
  <input id="labels_googlefont" value="">
  <input type="radio" name="layout_attachincompletesto" id="layout_attachto_leading" value="leading">
  <input type="radio" name="layout_attachincompletesto" id="layout_attachto_trailing" value="trailing">
  <input type="radio" name="layout_attachincompletesto" id="layout_attachto_nearest" value="nearest" checked>
</form>

<script>
// ============ GLOBAL STATE ============
let currentZoom = 1.0;
let undoStack = [];
let lastSavedState = null;
const MAX_UNDO = 20;
let nodeColors = {};
let nodeCustomizations = {}; // Store per-node customizations
let labelPositions = {};
let currentEditingNodeName = null;
let uploadedImages = []; // Multi-image support

// ============ CUSTOM LAYOUT STATE ============
// Independent state management for nodes and labels
// Structure: customLayout["NodeName"] = { 
//   nodeX, nodeY, labelX, labelY, labelW, labelH,
//   labelColor, labelBg, labelBgEnabled, labelAlign, labelFontSize,
//   nodeColor, nodeBorder, nodeOpacity
// }
let customLayout = {};
let labelDragEnabled = true; // Global toggle for label dragging

// ============ DEFAULT SYSTEM PROMPT ============
const DEFAULT_SYSTEM_PROMPT = `You are a financial data parser for Sankey diagrams.
Parse the input and extract flows between nodes.

CRITICAL JSON FORMATTING RULES:
1. Return ONLY valid JSON - no markdown, no explanations before or after
2. Use this EXACT format: {"flows": [{"from": "Source", "to": "Target", "amount": 1000}]}
3. All amounts must be plain numbers (no quotes, no commas, no currency symbols)
4. Keep node names short and clean (no special characters)
5. Ensure the JSON is complete and properly closed with ]}

SANKEY DIAGRAM RULES:
- Each flow has: source (from), destination (to), and amount
- For income statements: Revenue flows to Gross Profit, Gross Profit flows to Operating Profit, etc.
- For balance sheets: Assets flow to categories, Liabilities flow to categories
- Amounts should be positive numbers
- Parse numbers: $100M = 100000000, $1.5B = 1500000000, 1,500 = 1500

RESPONSE FORMAT (return ONLY this, nothing else):
{"flows": [{"from": "Source Name", "to": "Destination Name", "amount": 1000}]}

For modifications:
{"action": "modify", "modifications": [{"node": "NodeName", "newAmount": 500}]}

For rebalancing:
{"action": "rebalance", "targetNode": "NodeName", "newTotal": 1000}

Example:
Input: "Revenue $100M, COGS $40M, Operating Expenses $30M"
Output: {"flows": [{"from": "Revenue", "to": "Gross Profit", "amount": 60000000}, {"from": "Revenue", "to": "COGS", "amount": 40000000}, {"from": "Gross Profit", "to": "Operating Profit", "amount": 30000000}]}`;

// ============ UTILITY FUNCTIONS ============
function escapeHtml(str) {
  if (!str) return '';
  return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

function updateAIStatus(msg, type) {
  const el = document.getElementById('ai-status');
  el.textContent = msg;
  el.className = 'ai-status ' + (type || '');
}

function addToChatHistory(role, message) {
  const history = document.getElementById('ai-chat-history');
  const div = document.createElement('div');
  div.style.cssText = `padding:6px 8px;margin-bottom:4px;border-radius:4px;background:${role === 'user' ? '#e3f2fd' : '#f5f5f5'};`;
  div.innerHTML = `<strong>${role === 'user' ? 'üë§' : 'ü§ñ'}</strong> ${escapeHtml(message.substring(0, 300))}${message.length > 300 ? '...' : ''}`;
  history.appendChild(div);
  history.scrollTop = history.scrollHeight;
}

// ============ DATA TABLE ============
function initializeDataTable() {
  const tbody = document.getElementById('data-table-body');
  const flowsText = document.getElementById('flows_in').value;
  const lines = flowsText.split('\n').filter(line => {
    const t = line.trim();
    return t && !t.startsWith('//') && !t.startsWith(':') && !t.startsWith("'");
  });
  
  tbody.innerHTML = '';
  lines.forEach(line => {
    const match = line.match(/^(.+?)\s*\[([^\]]+)\]\s*(.+?)(?:\s+(#[a-f0-9]{3,6}))?$/i);
    if (match) {
      addDataRowWithValues(match[1].trim(), match[3].trim(), match[2].trim(), '');
    }
  });
  
  if (tbody.children.length === 0) {
    addDataRowWithValues('', '', '', '');
  }
}

function addDataRow() {
  saveStateForUndo();
  const count = parseInt(document.getElementById('add-row-count').value) || 1;
  for (let i = 0; i < count; i++) {
    addDataRowWithValues('', '', '', '');
  }
}

function addDataRowWithValues(from, to, amount, comparison) {
  const tbody = document.getElementById('data-table-body');
  const row = document.createElement('tr');
  row.innerHTML = `
    <td><input type="text" value="${escapeHtml(from)}" onfocus="saveStateForUndo()" onchange="updateDiagramFromTableNoUndo()" placeholder="Source"></td>
    <td><input type="text" value="${escapeHtml(to)}" onfocus="saveStateForUndo()" onchange="updateDiagramFromTableNoUndo()" placeholder="Target"></td>
    <td><input type="text" value="${escapeHtml(amount)}" onfocus="saveStateForUndo()" onchange="updateDiagramFromTableNoUndo()" placeholder="0"></td>
    <td><input type="text" value="${escapeHtml(comparison)}" onfocus="saveStateForUndo()" onchange="updateDiagramFromTableNoUndo()" placeholder="Prev"></td>
    <td style="display:flex;gap:4px;">
      <button class="delete-btn" onclick="saveStateForUndo(); deleteDataRow(this)" title="Delete">√ó</button>
    </td>
  `;
  tbody.appendChild(row);
}

function deleteDataRow(btn) {
  btn.closest('tr').remove();
  updateDiagramFromTableNoUndo();
}

function clearAllRows() {
  if (confirm('Clear all data rows?')) {
    saveStateForUndo();
    document.getElementById('data-table-body').innerHTML = '';
    addDataRowWithValues('', '', '', '');
    updateDiagramFromTableNoUndo();
  }
}
</script>

<script>
// ============ DIAGRAM RENDERING ============
function updateDiagramFromTable() {
  saveStateForUndo();
  updateDiagramFromTableNoUndo();
}

function updateDiagramFromTableNoUndo() {
  const tbody = document.getElementById('data-table-body');
  const rows = tbody.querySelectorAll('tr');
  let dsl = '';
  let validRows = 0;
  
  // Add node color definitions at the top
  for (const [nodeName, color] of Object.entries(nodeColors)) {
    dsl += `:${nodeName} ${color}\n`;
  }
  if (Object.keys(nodeColors).length > 0) dsl += '\n';
  
  rows.forEach(row => {
    const inputs = row.querySelectorAll('input');
    const from = inputs[0].value.trim();
    const to = inputs[1].value.trim();
    const amount = inputs[2].value.trim();
    
    if (from && to && amount) {
      dsl += `${from} [${amount}] ${to}\n`;
      validRows++;
    }
  });
  
  document.getElementById('flows_in').value = dsl;
  renderDiagram();
  updateStatus(validRows);
  saveProgressToLocal();
}

function renderDiagram() {
  syncOptionsToForm();
  const processFn = window.process_sankey || (typeof process_sankey !== 'undefined' ? process_sankey : null);
  
  if (processFn) {
    try {
      processFn();
      setTimeout(() => {
        setupNodeClickHandlers();
        applyLabelPositions();
      }, 100);
    } catch (e) {
      console.error('Render error:', e);
      document.getElementById('status-message').textContent = 'Error: ' + e.message;
      document.getElementById('status-bar').className = 'status-bar error';
    }
  } else {
    setTimeout(renderDiagram, 200);
  }
}

function renderDiagramOnly() {
  syncOptionsToForm();
  const processFn = window.process_sankey || (typeof process_sankey !== 'undefined' ? process_sankey : null);
  if (processFn) {
    try { processFn(); } catch (e) { console.error('Render error:', e); }
  }
}

// ============ OPTIONS SYNC ============
function syncOptionsToForm() {
  const el = id => document.getElementById(id);
  
  if (el('opt_labelname_appears')) el('labelname_appears').checked = el('opt_labelname_appears').checked;
  if (el('opt_labelvalue_appears')) el('labelvalue_appears').checked = el('opt_labelvalue_appears').checked;
  if (el('opt_labels_comparisonline')) el('labels_comparisonline').checked = el('opt_labels_comparisonline').checked;
  if (el('opt_labelname_size')) el('labelname_size').value = el('opt_labelname_size').value;
  if (el('opt_labels_color')) el('labels_color').value = el('opt_labels_color').value;
  if (el('opt_labels_decimalplaces')) el('labels_decimalplaces').value = el('opt_labels_decimalplaces').value;
  if (el('opt_value_prefix')) el('value_prefix').value = el('opt_value_prefix').value;
  if (el('opt_value_suffix')) el('value_suffix').value = el('opt_value_suffix').value;
  
  if (el('opt_labels_fontface')) {
    const fontValue = el('opt_labels_fontface').value;
    const radioId = 'labels_fontface_' + (fontValue === 'sans-serif' ? 'sans' : fontValue === 'serif' ? 'serif' : 'mono');
    const radio = el(radioId);
    if (radio) radio.checked = true;
  }
  if (el('opt_labels_googlefont')) {
    const googleFont = el('opt_labels_googlefont').value;
    el('labels_googlefont').value = googleFont;
    if (googleFont) loadGoogleFont(googleFont);
  }
  
  if (el('opt_node_w')) el('node_w').value = el('opt_node_w').value;
  if (el('opt_node_h')) el('node_h').value = el('opt_node_h').value;
  if (el('opt_node_spacing')) el('node_spacing').value = el('opt_node_spacing').value;
  if (el('opt_node_border')) el('node_border').value = el('opt_node_border').value;
  if (el('opt_node_opacity')) el('node_opacity').value = el('opt_node_opacity').value / 100;
  if (el('opt_node_color')) el('node_color').value = el('opt_node_color').value;
  if (el('opt_node_theme')) {
    const theme = el('opt_node_theme').value;
    const radioId = 'theme_' + theme + '_radio';
    const radio = el(radioId);
    if (radio) radio.checked = true;
  }
  
  if (el('opt_flow_opacity')) el('flow_opacity').value = el('opt_flow_opacity').value / 100;
  if (el('opt_flow_curvature')) el('flow_curvature').value = el('opt_flow_curvature').value / 100;
  if (el('opt_flow_color')) el('flow_color').value = el('opt_flow_color').value;
  if (el('opt_flow_outside_in')?.checked) el('flow_inherit_outside_in').checked = true;
  if (el('opt_flow_source')?.checked) el('flow_inherit_from_source').checked = true;
  if (el('opt_flow_target')?.checked) el('flow_inherit_from_target').checked = true;
  if (el('opt_flow_single')?.checked) el('flow_inherit_none').checked = true;
  
  if (el('opt_size_w')) el('size_w').value = el('opt_size_w').value;
  if (el('opt_size_h')) el('size_h').value = el('opt_size_h').value;
  if (el('opt_margin_l')) el('margin_l').value = el('opt_margin_l').value;
  if (el('opt_margin_r')) el('margin_r').value = el('opt_margin_r').value;
  if (el('opt_margin_t')) el('margin_t').value = el('opt_margin_t').value;
  if (el('opt_margin_b')) el('margin_b').value = el('opt_margin_b').value;
  if (el('opt_bg_color')) el('bg_color').value = el('opt_bg_color').value;
  if (el('opt_bg_transparent')) el('bg_transparent').checked = el('opt_bg_transparent').checked;
  if (el('opt_layout_automatic')?.checked) el('layout_order_automatic').checked = true;
  if (el('opt_layout_exact')?.checked) el('layout_order_exact').checked = true;
  
  const svg = document.getElementById('sankey_svg');
  if (svg && el('opt_size_w') && el('opt_size_h')) {
    svg.setAttribute('width', el('opt_size_w').value);
    svg.setAttribute('height', el('opt_size_h').value);
  }
}

function updateOption() { renderDiagram(); }
function updateFontOption() {
  const fontSelect = document.getElementById('opt_labels_fontface');
  const fontValue = fontSelect.value;
  const radioId = 'labels_fontface_' + (fontValue === 'sans-serif' ? 'sans' : fontValue === 'serif' ? 'serif' : 'mono');
  const radio = document.getElementById(radioId);
  if (radio) radio.checked = true;
  renderDiagram();
}

function loadGoogleFont(fontName) {
  if (!fontName) return;
  const fontId = 'google-font-' + fontName.replace(/\s+/g, '-');
  if (document.getElementById(fontId)) return;
  const link = document.createElement('link');
  link.id = fontId;
  link.rel = 'stylesheet';
  link.href = `https://fonts.googleapis.com/css2?family=${encodeURIComponent(fontName)}:wght@400;500;600;700&display=swap`;
  document.head.appendChild(link);
}
</script>

<script>
// ============ NODE CUSTOMIZATION POPUP ============
function setupNodeClickHandlers() {
  const svg = document.getElementById('sankey_svg');
  if (!svg) return;
  
  // Add click handlers to nodes (rects) - for node customization
  svg.querySelectorAll('rect').forEach(rect => {
    // Skip label background rects and drag handles
    if (rect.classList.contains('custom-label-bg') || rect.classList.contains('drag-handle')) return;
    
    rect.style.cursor = 'pointer';
    rect.onclick = function(e) {
      e.stopPropagation();
      const title = this.querySelector('title');
      if (title) {
        const nodeName = title.textContent.split(':')[0].trim();
        openNodePopup(nodeName, this);
      }
    };
  });
  
  // Setup independent label dragging using D3
  setupIndependentLabelDragging();
}

// ============ INDEPENDENT LABEL DRAGGING SYSTEM ============
function setupIndependentLabelDragging() {
  const svg = d3.select('#sankey_svg');
  if (!svg.node()) return;
  
  // Find all label groups (created by sankeymatic.js)
  const labelGroups = svg.selectAll('g[id$="_group"]');
  
  labelGroups.each(function() {
    const group = d3.select(this);
    const groupId = group.attr('id');
    const textEl = group.select('text');
    if (!textEl.node()) return;
    
    // Extract node name from the text content or group ID
    const textContent = textEl.text();
    const nodeName = textContent.split('\n')[0].trim();
    if (!nodeName) return;
    
    // Store original position if not already stored
    if (!customLayout[nodeName]) {
      const transform = group.attr('transform') || '';
      const match = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
      if (match) {
        customLayout[nodeName] = {
          originalX: parseFloat(match[1]),
          originalY: parseFloat(match[2]),
          labelX: parseFloat(match[1]),
          labelY: parseFloat(match[2]),
          labelW: 0,
          labelH: 0
        };
      }
    }
    
    // Set cursor style
    group.style('cursor', 'move');
    
    // Remove any existing drag behavior first
    group.on('.drag', null);
    
    // Apply custom D3 drag behavior
    const dragBehavior = d3.drag()
      .on('start', function(event) {
        // Store starting position
        const transform = d3.select(this).attr('transform') || '';
        const match = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
        if (match) {
          event.subject.startX = parseFloat(match[1]);
          event.subject.startY = parseFloat(match[2]);
        } else {
          event.subject.startX = 0;
          event.subject.startY = 0;
        }
        d3.select(this).raise().classed('dragging', true);
      })
      .on('drag', function(event) {
        // Calculate new position
        const newX = event.subject.startX + event.dx;
        const newY = event.subject.startY + event.dy;
        
        // Update transform
        d3.select(this).attr('transform', `translate(${newX}, ${newY})`);
        
        // Update stored position
        event.subject.startX = newX;
        event.subject.startY = newY;
      })
      .on('end', function(event) {
        d3.select(this).classed('dragging', false);
        
        // Get final position
        const transform = d3.select(this).attr('transform') || '';
        const match = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
        if (match) {
          const finalX = parseFloat(match[1]);
          const finalY = parseFloat(match[2]);
          
          // Store in customLayout
          if (!customLayout[nodeName]) {
            customLayout[nodeName] = {};
          }
          customLayout[nodeName].labelX = finalX;
          customLayout[nodeName].labelY = finalY;
          
          // Also store in sankeymatic's rememberedLabelMoves for persistence
          if (window.rememberedLabelMoves && customLayout[nodeName].originalX !== undefined) {
            const offsetX = finalX - customLayout[nodeName].originalX;
            const offsetY = finalY - customLayout[nodeName].originalY;
            window.rememberedLabelMoves.set(nodeName, [offsetX, offsetY]);
          }
          
          // Update nodeCustomizations for popup sync
          if (!nodeCustomizations[nodeName]) {
            nodeCustomizations[nodeName] = {};
          }
          nodeCustomizations[nodeName].labelX = finalX - (customLayout[nodeName].originalX || 0);
          nodeCustomizations[nodeName].labelY = finalY - (customLayout[nodeName].originalY || 0);
          
          saveProgressToLocal();
        }
      });
    
    group.call(dragBehavior);
    
    // Double-click to open popup
    group.on('dblclick', function(event) {
      event.stopPropagation();
      event.preventDefault();
      openNodePopup(nodeName, textEl.node());
    });
  });
}

// Reset a specific label to its default position
function resetLabel(nodeName) {
  if (customLayout[nodeName] && customLayout[nodeName].originalX !== undefined) {
    customLayout[nodeName].labelX = customLayout[nodeName].originalX;
    customLayout[nodeName].labelY = customLayout[nodeName].originalY;
    
    // Clear from rememberedLabelMoves
    if (window.rememberedLabelMoves) {
      window.rememberedLabelMoves.delete(nodeName);
    }
    
    // Clear from nodeCustomizations
    if (nodeCustomizations[nodeName]) {
      nodeCustomizations[nodeName].labelX = 0;
      nodeCustomizations[nodeName].labelY = 0;
    }
    
    // Re-render to apply
    renderDiagram();
  }
}

// Reset all labels to default positions
function resetAllLabelsCustom() {
  Object.keys(customLayout).forEach(nodeName => {
    if (customLayout[nodeName].originalX !== undefined) {
      customLayout[nodeName].labelX = customLayout[nodeName].originalX;
      customLayout[nodeName].labelY = customLayout[nodeName].originalY;
    }
  });
  
  // Clear all remembered label moves
  if (window.rememberedLabelMoves) {
    window.rememberedLabelMoves.clear();
  }
  
  // Clear label positions from nodeCustomizations
  Object.keys(nodeCustomizations).forEach(nodeName => {
    if (nodeCustomizations[nodeName]) {
      nodeCustomizations[nodeName].labelX = 0;
      nodeCustomizations[nodeName].labelY = 0;
    }
  });
  
  renderDiagram();
}

function openNodePopup(nodeName, element) {
  currentEditingNodeName = nodeName;
  const popup = document.getElementById('node-popup-overlay');
  
  // Load existing customizations or defaults
  const custom = nodeCustomizations[nodeName] || {};
  
  // Get current node color from SVG if not stored
  let currentFillColor = custom.fillColor || nodeColors[nodeName] || '#888888';
  const svg = document.getElementById('sankey_svg');
  if (svg && !custom.fillColor) {
    svg.querySelectorAll('rect').forEach(rect => {
      const title = rect.querySelector('title');
      if (title && title.textContent.startsWith(nodeName + ':')) {
        currentFillColor = rect.getAttribute('fill') || currentFillColor;
      }
    });
  }
  
  // Get current label position from sankeymatic.js's rememberedLabelMoves
  let currentLabelX = custom.labelX || 0;
  let currentLabelY = custom.labelY || 0;
  
  // Check if there's a remembered label move from dragging
  if (window.rememberedLabelMoves && window.rememberedLabelMoves.has(nodeName)) {
    const [offsetX, offsetY] = window.rememberedLabelMoves.get(nodeName);
    currentLabelX = Math.round(offsetX);
    currentLabelY = Math.round(offsetY);
  }
  
  document.getElementById('popup-node-name').value = nodeName;
  document.getElementById('popup-node-fill').value = currentFillColor;
  document.getElementById('popup-node-border').value = custom.borderColor || '#666666';
  document.getElementById('popup-node-opacity').value = custom.opacity || 100;
  
  document.getElementById('popup-label-text').value = custom.labelText || nodeName;
  document.getElementById('popup-label-fontsize').value = custom.labelFontSize || 16;
  document.getElementById('popup-label-bg').value = custom.labelBg || '#ffffff';
  document.getElementById('popup-label-bg-enabled').checked = custom.labelBgEnabled || false;
  document.getElementById('popup-label-color').value = custom.labelColor || '#000000';
  document.getElementById('popup-label-width').value = custom.labelWidth || 0;
  document.getElementById('popup-label-height').value = custom.labelHeight || 0;
  document.getElementById('popup-label-locked').checked = custom.labelLocked !== false;
  document.getElementById('popup-label-x').value = Math.round(currentLabelX);
  document.getElementById('popup-label-y').value = Math.round(currentLabelY);
  
  setLabelAlignment(custom.labelAlign || 'center');
  
  popup.classList.add('active');
}

function closeNodePopup() {
  document.getElementById('node-popup-overlay').classList.remove('active');
  currentEditingNodeName = null;
}

function setLabelAlignment(align) {
  ['left', 'center', 'right'].forEach(a => {
    document.getElementById('align-' + a).classList.toggle('active', a === align);
  });
}

function getLabelAlignment() {
  if (document.getElementById('align-left').classList.contains('active')) return 'left';
  if (document.getElementById('align-right').classList.contains('active')) return 'right';
  return 'center';
}

function applyNodeCustomization() {
  if (!currentEditingNodeName) return;
  
  const nodeName = currentEditingNodeName;
  const newName = document.getElementById('popup-node-name').value.trim();
  
  // Store customizations
  const custom = {
    fillColor: document.getElementById('popup-node-fill').value,
    borderColor: document.getElementById('popup-node-border').value,
    opacity: parseInt(document.getElementById('popup-node-opacity').value),
    labelText: document.getElementById('popup-label-text').value,
    labelBg: document.getElementById('popup-label-bg').value,
    labelBgEnabled: document.getElementById('popup-label-bg-enabled').checked,
    labelColor: document.getElementById('popup-label-color').value,
    labelAlign: getLabelAlignment(),
    labelWidth: parseInt(document.getElementById('popup-label-width').value) || 0,
    labelHeight: parseInt(document.getElementById('popup-label-height').value) || 0,
    labelLocked: document.getElementById('popup-label-locked').checked,
    labelX: parseInt(document.getElementById('popup-label-x').value) || 0,
    labelY: parseInt(document.getElementById('popup-label-y').value) || 0,
    labelFontSize: parseInt(document.getElementById('popup-label-fontsize')?.value) || 16
  };
  
  nodeCustomizations[nodeName] = custom;
  nodeColors[nodeName] = custom.fillColor;
  
  // Update customLayout with the new label position
  if (!customLayout[nodeName]) {
    customLayout[nodeName] = {};
  }
  
  // If there's an original position, calculate absolute position from offset
  if (customLayout[nodeName].originalX !== undefined) {
    customLayout[nodeName].labelX = customLayout[nodeName].originalX + custom.labelX;
    customLayout[nodeName].labelY = customLayout[nodeName].originalY + custom.labelY;
  }
  
  // Store label dimensions
  customLayout[nodeName].labelW = custom.labelWidth;
  customLayout[nodeName].labelH = custom.labelHeight;
  
  // Update rememberedLabelMoves for sankeymatic.js persistence
  if (window.rememberedLabelMoves) {
    if (custom.labelX !== 0 || custom.labelY !== 0) {
      window.rememberedLabelMoves.set(nodeName, [custom.labelX, custom.labelY]);
    } else if (custom.labelLocked) {
      window.rememberedLabelMoves.delete(nodeName);
    }
  }
  
  // Apply changes directly to SVG elements
  applyCustomizationToSVG(nodeName, custom);
  
  // If name changed, update table and migrate customizations
  if (newName && newName !== nodeName) {
    const tbody = document.getElementById('data-table-body');
    tbody.querySelectorAll('tr').forEach(row => {
      const inputs = row.querySelectorAll('input');
      if (inputs[0].value === nodeName) inputs[0].value = newName;
      if (inputs[1].value === nodeName) inputs[1].value = newName;
    });
    
    // Migrate all customization data to new name
    nodeColors[newName] = nodeColors[nodeName];
    delete nodeColors[nodeName];
    nodeCustomizations[newName] = nodeCustomizations[nodeName];
    delete nodeCustomizations[nodeName];
    customLayout[newName] = customLayout[nodeName];
    delete customLayout[nodeName];
    
    if (window.rememberedLabelMoves && window.rememberedLabelMoves.has(nodeName)) {
      const move = window.rememberedLabelMoves.get(nodeName);
      window.rememberedLabelMoves.delete(nodeName);
      window.rememberedLabelMoves.set(newName, move);
    }
    
    updateDiagramFromTableNoUndo();
  }
  
  closeNodePopup();
  saveProgressToLocal();
}

function applyCustomizationToSVG(nodeName, custom) {
  const svg = document.getElementById('sankey_svg');
  if (!svg) return;
  
  // Find and update the node rectangle
  svg.querySelectorAll('rect').forEach(rect => {
    const title = rect.querySelector('title');
    if (title && title.textContent.startsWith(nodeName + ':')) {
      rect.setAttribute('fill', custom.fillColor);
      rect.setAttribute('stroke', custom.borderColor);
      rect.setAttribute('stroke-width', '1');
      rect.setAttribute('opacity', custom.opacity / 100);
    }
  });
  
  // Find the label group and text
  const labelGroups = svg.querySelectorAll('g[id$="_group"]');
  labelGroups.forEach(group => {
    const textEl = group.querySelector('text');
    if (!textEl) return;
    
    const textContent = textEl.textContent?.trim();
    const labelName = textContent?.split('\n')[0]?.trim();
    if (labelName !== nodeName) return;
    
    // Apply label color
    textEl.setAttribute('fill', custom.labelColor);
    
    // Apply font size
    if (custom.labelFontSize && custom.labelFontSize > 0) {
      textEl.setAttribute('font-size', custom.labelFontSize + 'px');
      // Also update tspans
      textEl.querySelectorAll('tspan').forEach(tspan => {
        tspan.setAttribute('font-size', custom.labelFontSize + 'px');
      });
    }
    
    // Apply alignment
    const anchor = custom.labelAlign === 'left' ? 'start' : custom.labelAlign === 'right' ? 'end' : 'middle';
    textEl.setAttribute('text-anchor', anchor);
    
    // Apply position offset to the label group
    if (customLayout[nodeName] && customLayout[nodeName].originalX !== undefined) {
      const newX = customLayout[nodeName].originalX + custom.labelX;
      const newY = customLayout[nodeName].originalY + custom.labelY;
      group.setAttribute('transform', `translate(${newX}, ${newY})`);
      
      // Update customLayout
      customLayout[nodeName].labelX = newX;
      customLayout[nodeName].labelY = newY;
    }
    
    // Visual feedback for unlocked labels
    if (!custom.labelLocked) {
      textEl.classList.add('label-unlocked');
      group.style.cursor = 'move';
    } else {
      textEl.classList.remove('label-unlocked');
      group.style.cursor = 'pointer';
    }
    
    // Update label text if changed
    if (custom.labelText && custom.labelText !== nodeName) {
      const tspan = textEl.querySelector('tspan');
      if (tspan) {
        tspan.textContent = custom.labelText;
      } else {
        const lines = textContent.split('\n');
        lines[0] = custom.labelText;
        textEl.textContent = lines[0];
        if (lines.length > 1) {
          for (let i = 1; i < lines.length; i++) {
            const newTspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
            newTspan.setAttribute('x', '0');
            newTspan.setAttribute('dy', '1.2em');
            newTspan.textContent = lines[i];
            textEl.appendChild(newTspan);
          }
        }
      }
    }
    
    // Handle label background box
    const existingBg = group.querySelector('.custom-label-bg');
    if (existingBg) existingBg.remove();
    
    if (custom.labelBgEnabled) {
      applyLabelBackground(textEl, custom);
    }
    
    // Handle custom label box dimensions
    if (custom.labelWidth > 0 || custom.labelHeight > 0) {
      applyLabelBoxDimensions(textEl, custom);
    }
  });
}

// Apply custom box dimensions to label
function applyLabelBoxDimensions(textEl, custom) {
  const group = textEl.parentElement;
  if (!group || group.tagName !== 'g') return;
  
  const bbox = textEl.getBBox();
  const padding = 4;
  
  // Create or update the label box
  let labelBox = group.querySelector('.label-box');
  if (!labelBox) {
    labelBox = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    labelBox.setAttribute('class', 'label-box');
    group.insertBefore(labelBox, textEl);
  }
  
  const boxWidth = custom.labelWidth > 0 ? custom.labelWidth : bbox.width + padding * 2;
  const boxHeight = custom.labelHeight > 0 ? custom.labelHeight : bbox.height + padding * 2;
  
  labelBox.setAttribute('x', bbox.x - padding);
  labelBox.setAttribute('y', bbox.y - padding);
  labelBox.setAttribute('width', boxWidth);
  labelBox.setAttribute('height', boxHeight);
  labelBox.setAttribute('fill', custom.labelBgEnabled ? custom.labelBg : 'transparent');
  labelBox.setAttribute('stroke', custom.labelBgEnabled ? '#ccc' : 'none');
  labelBox.setAttribute('stroke-width', '1');
  labelBox.setAttribute('rx', '3');
  labelBox.setAttribute('opacity', custom.labelBgEnabled ? '0.9' : '0');
  
  // Adjust text position based on alignment within the box
  if (custom.labelWidth > 0) {
    const textX = custom.labelAlign === 'left' ? bbox.x - padding + 4 :
                  custom.labelAlign === 'right' ? bbox.x - padding + boxWidth - 4 :
                  bbox.x - padding + boxWidth / 2;
    textEl.setAttribute('x', textX - bbox.x);
  }
}

function applyLabelBackground(textEl, custom) {
  const group = textEl.parentElement;
  if (!group || group.tagName !== 'g') return;
  
  // Remove existing custom background
  const existingBg = group.querySelector('.custom-label-bg');
  if (existingBg) existingBg.remove();
  
  // Get text bounding box
  const bbox = textEl.getBBox();
  const padding = 6;
  
  // Create background rect
  const bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
  bgRect.setAttribute('class', 'custom-label-bg');
  bgRect.setAttribute('x', bbox.x - padding);
  bgRect.setAttribute('y', bbox.y - padding);
  bgRect.setAttribute('width', custom.labelWidth > 0 ? custom.labelWidth : bbox.width + padding * 2);
  bgRect.setAttribute('height', custom.labelHeight > 0 ? custom.labelHeight : bbox.height + padding * 2);
  bgRect.setAttribute('fill', custom.labelBg || '#ffffff');
  bgRect.setAttribute('stroke', '#cccccc');
  bgRect.setAttribute('stroke-width', '1');
  bgRect.setAttribute('rx', '4');
  bgRect.setAttribute('opacity', '0.95');
  
  // Insert before text so text appears on top
  group.insertBefore(bgRect, textEl);
}

function resetNodeToDefault() {
  if (!currentEditingNodeName) return;
  
  const nodeName = currentEditingNodeName;
  
  // Clear all customizations for this node
  delete nodeCustomizations[nodeName];
  delete nodeColors[nodeName];
  delete labelPositions[nodeName];
  
  // Reset customLayout to original position
  if (customLayout[nodeName] && customLayout[nodeName].originalX !== undefined) {
    customLayout[nodeName].labelX = customLayout[nodeName].originalX;
    customLayout[nodeName].labelY = customLayout[nodeName].originalY;
    customLayout[nodeName].labelW = 0;
    customLayout[nodeName].labelH = 0;
  }
  
  // Clear from rememberedLabelMoves
  if (window.rememberedLabelMoves) {
    window.rememberedLabelMoves.delete(nodeName);
  }
  
  closeNodePopup();
  renderDiagram();
}

// ============ LABEL & NODE CUSTOMIZATION APPLICATION ============
function applyLabelPositions() {
  const svg = document.getElementById('sankey_svg');
  if (!svg) return;
  
  // First, capture original positions for all label groups
  svg.querySelectorAll('g[id$="_group"]').forEach(group => {
    const textEl = group.querySelector('text');
    if (!textEl) return;
    
    const textContent = textEl.textContent?.trim();
    const nodeName = textContent?.split('\n')[0]?.trim();
    if (!nodeName) return;
    
    // Store original position if not already stored
    const transform = group.getAttribute('transform') || '';
    const match = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
    if (match) {
      if (!customLayout[nodeName]) {
        customLayout[nodeName] = {
          originalX: parseFloat(match[1]),
          originalY: parseFloat(match[2]),
          labelX: parseFloat(match[1]),
          labelY: parseFloat(match[2]),
          labelW: 0,
          labelH: 0
        };
      } else if (customLayout[nodeName].originalX === undefined) {
        customLayout[nodeName].originalX = parseFloat(match[1]);
        customLayout[nodeName].originalY = parseFloat(match[2]);
      }
    }
  });
  
  // Apply stored customizations to all labels and nodes
  Object.keys(nodeCustomizations).forEach(nodeName => {
    applyCustomizationToSVG(nodeName, nodeCustomizations[nodeName]);
  });
  
  // Setup independent label dragging
  setupIndependentLabelDragging();
}
</script>

<script>
// ============ MULTI-IMAGE UPLOAD ============
function handleMultiImageUpload(event) {
  const files = Array.from(event.target.files);
  if (!files.length) return;
  
  files.forEach(file => processImageFile(file));
  event.target.value = '';
}

function processImageFile(file) {
  const reader = new FileReader();
  reader.onload = function(e) {
    const base64 = e.target.result.split(',')[1];
    const imageData = { 
      type: file.type, 
      base64: base64, 
      name: file.name || 'image',
      dataUrl: e.target.result
    };
    uploadedImages.push(imageData);
    renderImagePreviews();
    updateAIStatus(`üì∑ ${uploadedImages.length} image(s) ready`, 'success');
  };
  reader.readAsDataURL(file);
}

function renderImagePreviews() {
  const container = document.getElementById('image-previews');
  container.innerHTML = '';
  
  uploadedImages.forEach((img, index) => {
    const div = document.createElement('div');
    div.className = 'image-preview-item';
    div.innerHTML = `
      <img src="${img.dataUrl}" alt="${img.name}">
      <button class="remove-btn" onclick="removeImage(${index})">√ó</button>
    `;
    container.appendChild(div);
  });
}

function removeImage(index) {
  uploadedImages.splice(index, 1);
  renderImagePreviews();
  updateAIStatus(uploadedImages.length ? `üì∑ ${uploadedImages.length} image(s) ready` : '', uploadedImages.length ? 'success' : '');
}

function clearAllImages() {
  uploadedImages = [];
  renderImagePreviews();
  updateAIStatus('', '');
}

// Drag and drop support
document.addEventListener('DOMContentLoaded', function() {
  const uploadArea = document.getElementById('image-upload-area');
  if (uploadArea) {
    uploadArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadArea.classList.add('dragover');
    });
    uploadArea.addEventListener('dragleave', () => {
      uploadArea.classList.remove('dragover');
    });
    uploadArea.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadArea.classList.remove('dragover');
      const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
      files.forEach(file => processImageFile(file));
    });
  }
  
  // Paste support
  const chatInput = document.getElementById('ai-chat-input');
  if (chatInput) {
    chatInput.addEventListener('paste', function(e) {
      const items = e.clipboardData?.items;
      if (!items) return;
      for (let i = 0; i < items.length; i++) {
        if (items[i].type.startsWith('image/')) {
          e.preventDefault();
          const file = items[i].getAsFile();
          if (file) processImageFile(file);
          break;
        }
      }
    });
  }
});

async function pasteFromClipboard() {
  try {
    const clipboardItems = await navigator.clipboard.read();
    for (const item of clipboardItems) {
      const imageType = item.types.find(type => type.startsWith('image/'));
      if (imageType) {
        const blob = await item.getType(imageType);
        const file = new File([blob], 'pasted-image.png', { type: imageType });
        processImageFile(file);
        return;
      }
      // Also try to paste text as JSON
      if (item.types.includes('text/plain')) {
        const blob = await item.getType('text/plain');
        const text = await blob.text();
        document.getElementById('ai-chat-input').value = text;
        return;
      }
    }
    updateAIStatus('No image or text in clipboard', 'warning');
  } catch (err) {
    console.error('Clipboard error:', err);
    updateAIStatus('Cannot access clipboard', 'error');
  }
}

// ============ AI API WITH ROBUST JSON PARSING ============
async function callGeminiAPI(apiKey, model, text, customPrompt, images) {
  const systemPrompt = customPrompt || DEFAULT_SYSTEM_PROMPT;
  
  let contents;
  if (images && images.length > 0) {
    // With images - build parts array
    const parts = [{ text: systemPrompt + '\n\nAnalyze these images and extract financial flows:\n' + text }];
    images.forEach(img => {
      parts.push({ inline_data: { mime_type: img.type, data: img.base64 } });
    });
    contents = [{ parts }];
  } else {
    contents = [{ parts: [{ text: systemPrompt + '\n\nData to parse:\n' + text }] }];
  }

  const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      contents: contents,
      generationConfig: { temperature: 0.1, maxOutputTokens: 8192 }
    })
  });
  
  if (!response.ok) {
    const err = await response.json();
    throw new Error(err.error?.message || 'API request failed');
  }
  
  const data = await response.json();
  const responseText = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
  
  addToChatHistory('ai', responseText.substring(0, 200) + '...');
  
  // Robust JSON extraction with error handling
  return parseAIResponse(responseText);
}

function parseAIResponse(responseText) {
  console.log('Parsing AI response:', responseText.substring(0, 500));
  
  // If response is empty or just whitespace
  if (!responseText || !responseText.trim()) {
    console.log('Empty response from AI');
    return { chatResponse: 'AI returned empty response', flows: [] };
  }
  
  // Try to extract JSON from response with multiple strategies
  let jsonStr = '';
  
  // Method 1: Find JSON block in markdown code fence
  const codeBlockMatch = responseText.match(/```(?:json)?\s*([\s\S]*?)```/);
  if (codeBlockMatch) {
    jsonStr = codeBlockMatch[1].trim();
    console.log('Found JSON in code block');
  }
  
  // Method 2: Find raw JSON object - be more careful with nested structures
  if (!jsonStr) {
    const startIdx = responseText.indexOf('{');
    if (startIdx !== -1) {
      let depth = 0;
      let endIdx = startIdx;
      let inString = false;
      let escapeNext = false;
      
      for (let i = startIdx; i < responseText.length; i++) {
        const char = responseText[i];
        
        if (escapeNext) {
          escapeNext = false;
          continue;
        }
        
        if (char === '\\') {
          escapeNext = true;
          continue;
        }
        
        if (char === '"' && !escapeNext) {
          inString = !inString;
          continue;
        }
        
        if (!inString) {
          if (char === '{') depth++;
          else if (char === '}') {
            depth--;
            if (depth === 0) {
              endIdx = i + 1;
              break;
            }
          }
        }
      }
      
      if (depth === 0 && endIdx > startIdx) {
        jsonStr = responseText.substring(startIdx, endIdx);
        console.log('Found JSON object in response');
      }
    }
  }
  
  // Method 3: Try to find flows pattern directly in text (no JSON wrapper)
  if (!jsonStr) {
    // Look for patterns like: Source [amount] Target or Source -> Target: amount
    const textFlows = extractFlowsFromText(responseText);
    if (textFlows.length > 0) {
      console.log('Extracted flows from text patterns');
      return { flows: textFlows };
    }
  }
  
  if (!jsonStr) {
    // Return a helpful message instead of throwing
    console.log('No JSON found, returning chat response');
    return { chatResponse: responseText, flows: [] };
  }
  
  // Clean up common JSON issues
  jsonStr = cleanJSON(jsonStr);
  
  // Multiple parsing attempts with progressive fixes
  const parseAttempts = [
    // Attempt 1: Direct parse
    () => JSON.parse(jsonStr),
    // Attempt 2: Fix trailing commas
    () => JSON.parse(jsonStr.replace(/,(\s*[}\]])/g, '$1')),
    // Attempt 3: Fix unquoted keys and trailing commas
    () => {
      let fixed = jsonStr.replace(/,(\s*[}\]])/g, '$1');
      fixed = fixed.replace(/([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)(\s*:)/g, '$1"$2"$3');
      return JSON.parse(fixed);
    },
    // Attempt 4: Extract flows with flexible regex - handles various orderings and formats
    () => {
      const flows = [];
      // More flexible patterns that handle various orderings and large numbers
      const patterns = [
        // Standard format with any order of keys
        /"from"\s*:\s*"([^"]+)"[\s\S]*?"to"\s*:\s*"([^"]+)"[\s\S]*?"amount"\s*:\s*(\d+(?:\.\d+)?(?:e[+-]?\d+)?)/gi,
        // Reversed order (amount first)
        /"amount"\s*:\s*(\d+(?:\.\d+)?(?:e[+-]?\d+)?)[\s\S]*?"from"\s*:\s*"([^"]+)"[\s\S]*?"to"\s*:\s*"([^"]+)"/gi,
        // source/target naming
        /"source"\s*:\s*"([^"]+)"[\s\S]*?"target"\s*:\s*"([^"]+)"[\s\S]*?"(?:amount|value)"\s*:\s*(\d+(?:\.\d+)?(?:e[+-]?\d+)?)/gi,
        // Simple object format
        /\{\s*"from"\s*:\s*"([^"]+)"\s*,\s*"to"\s*:\s*"([^"]+)"\s*,\s*"amount"\s*:\s*(\d+)/g
      ];
      
      for (const pattern of patterns) {
        let match;
        pattern.lastIndex = 0; // Reset regex state
        while ((match = pattern.exec(jsonStr)) !== null) {
          // Handle different capture group orders
          if (pattern.source.startsWith('"amount"')) {
            flows.push({ from: match[2], to: match[3], amount: parseFloat(match[1]) });
          } else {
            flows.push({ from: match[1], to: match[2], amount: parseFloat(match[3]) });
          }
        }
        if (flows.length > 0) break;
      }
      
      if (flows.length > 0) return { flows };
      throw new Error('No flows found');
    },
    // Attempt 5: Try to extract individual flow objects from truncated JSON
    () => {
      const flows = [];
      // Match individual flow objects even if the array is incomplete
      const flowObjPattern = /\{\s*"from"\s*:\s*"([^"]+)"\s*,\s*"to"\s*:\s*"([^"]+)"\s*,\s*"amount"\s*:\s*(\d+(?:\.\d+)?(?:e[+-]?\d+)?)\s*\}/gi;
      let match;
      while ((match = flowObjPattern.exec(responseText)) !== null) {
        flows.push({ from: match[1], to: match[2], amount: parseFloat(match[3]) });
      }
      if (flows.length > 0) return { flows };
      throw new Error('No flows found');
    }
  ];
  
  for (let i = 0; i < parseAttempts.length; i++) {
    try {
      const result = parseAttempts[i]();
      console.log(`JSON parsed successfully with attempt ${i + 1}`);
      return result;
    } catch (e) {
      console.log(`Parse attempt ${i + 1} failed:`, e.message);
    }
  }
  
  // If all parsing fails, return the response as chat
  console.log('All JSON parsing failed, returning as chat response');
  return { chatResponse: responseText, flows: [] };
}

// Extract flows from natural text patterns
function extractFlowsFromText(text) {
  const flows = [];
  
  // Pattern: "Source [amount] Target" (SankeyMATIC format)
  const sankeyPattern = /([A-Za-z][A-Za-z0-9\s]*?)\s*\[(\d+(?:\.\d+)?)\]\s*([A-Za-z][A-Za-z0-9\s]*)/g;
  let match;
  while ((match = sankeyPattern.exec(text)) !== null) {
    flows.push({ from: match[1].trim(), to: match[3].trim(), amount: parseFloat(match[2]) });
  }
  
  // Pattern: "Source -> Target: amount" or "Source to Target: amount"
  const arrowPattern = /([A-Za-z][A-Za-z0-9\s]*?)\s*(?:->|‚Üí|to)\s*([A-Za-z][A-Za-z0-9\s]*?):\s*\$?(\d+(?:,\d{3})*(?:\.\d+)?)/gi;
  while ((match = arrowPattern.exec(text)) !== null) {
    const amount = parseFloat(match[3].replace(/,/g, ''));
    flows.push({ from: match[1].trim(), to: match[2].trim(), amount });
  }
  
  return flows;
}

function cleanJSON(str) {
  // Remove BOM and other invisible characters
  str = str.replace(/^\uFEFF/, '');
  // Remove control characters except newlines and tabs
  str = str.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '');
  // Remove any text before the first { or after the last }
  const firstBrace = str.indexOf('{');
  const lastBrace = str.lastIndexOf('}');
  if (firstBrace !== -1 && lastBrace !== -1) {
    str = str.substring(firstBrace, lastBrace + 1);
  }
  // Normalize whitespace
  str = str.trim();
  return str;
}
</script>

<script>
// ============ AI CHAT PROCESSING ============
async function processAIChat() {
  const input = document.getElementById('ai-chat-input');
  const btn = document.getElementById('ai-send-btn');
  const text = input.value.trim();
  
  if (!text && uploadedImages.length === 0) {
    updateAIStatus('Please enter text or upload images', 'error');
    return;
  }
  
  const apiKey = localStorage.getItem('gemini_api_key');
  if (!apiKey) {
    updateAIStatus('‚ö†Ô∏è Please set API key in Settings', 'warning');
    openSettingsModal();
    return;
  }
  
  btn.disabled = true;
  addToChatHistory('user', text || `[${uploadedImages.length} image(s) uploaded]`);
  
  // Show progress
  const progressEl = document.getElementById('upload-progress');
  const progressBar = document.getElementById('progress-bar-fill');
  const progressText = document.getElementById('progress-text');
  progressEl.style.display = 'block';
  progressBar.style.width = '30%';
  progressText.textContent = 'Sending to AI...';
  
  try {
    const model = localStorage.getItem('ai_model') || 'gemini-2.0-flash';
    const customPrompt = localStorage.getItem('ai_system_prompt') || '';
    
    progressBar.style.width = '60%';
    progressText.textContent = 'Processing...';
    
    // Check if user wants to parse/modify data
    const parseKeywords = ['parse', 'extract', 'convert', 'add', 'create', 'generate', 'modify', 'change', 'update', 'rebalance'];
    const shouldParse = parseKeywords.some(kw => text.toLowerCase().includes(kw)) || uploadedImages.length > 0;
    
    if (shouldParse) {
      const result = await callGeminiAPI(apiKey, model, text, customPrompt, uploadedImages);
      
      progressBar.style.width = '90%';
      progressText.textContent = 'Applying changes...';
      
      if (result.chatResponse && (!result.flows || result.flows.length === 0)) {
        // AI returned a chat response instead of flows - show it to user
        addToChatHistory('ai', result.chatResponse.substring(0, 500));
        updateAIStatus('üí¨ AI responded - try being more specific about the data format', 'warning');
      } else if (result.action === 'modify' && result.modifications) {
        // Handle modifications to existing data
        applyModifications(result.modifications);
        addToChatHistory('ai', `‚úÖ Applied ${result.modifications.length} modifications`);
        updateAIStatus(`‚úì Modified ${result.modifications.length} items`, 'success');
      } else if (result.action === 'rebalance' && result.targetNode) {
        // Handle rebalancing
        rebalanceNode(result.targetNode, result.newTotal);
        addToChatHistory('ai', `‚úÖ Rebalanced ${result.targetNode}`);
        updateAIStatus(`‚úì Rebalanced node`, 'success');
      } else if (result.flows && result.flows.length > 0) {
        // Add new flows
        saveStateForUndo();
        result.flows.forEach(f => {
          addDataRowWithValues(f.from || f.source, f.to || f.target, String(f.amount || f.value || 0), '');
        });
        updateDiagramFromTableNoUndo();
        addToChatHistory('ai', `‚úÖ Added ${result.flows.length} flows to the diagram!`);
        updateAIStatus(`‚úì Added ${result.flows.length} flows`, 'success');
      } else {
        addToChatHistory('ai', 'No flows found. Try: "parse: Revenue 100 to Expenses 50" or upload an image.');
        updateAIStatus('No flows found', 'warning');
      }
    } else {
      // Chat mode
      const chatResponse = await callGeminiChatAPI(apiKey, model, text);
      addToChatHistory('ai', chatResponse);
      updateAIStatus('', '');
    }
    
    input.value = '';
    clearAllImages();
  } catch (err) {
    console.error('AI Error:', err);
    addToChatHistory('ai', '‚ùå Error: ' + err.message);
    updateAIStatus('Error: ' + err.message.substring(0, 50), 'error');
  } finally {
    btn.disabled = false;
    progressEl.style.display = 'none';
    progressBar.style.width = '0%';
  }
}

function applyModifications(modifications) {
  const tbody = document.getElementById('data-table-body');
  modifications.forEach(mod => {
    tbody.querySelectorAll('tr').forEach(row => {
      const inputs = row.querySelectorAll('input');
      if (mod.node && (inputs[0].value === mod.node || inputs[1].value === mod.node)) {
        if (mod.newAmount !== undefined) inputs[2].value = mod.newAmount;
      }
      if (mod.from && mod.to && inputs[0].value === mod.from && inputs[1].value === mod.to) {
        if (mod.newAmount !== undefined) inputs[2].value = mod.newAmount;
      }
    });
  });
  updateDiagramFromTableNoUndo();
}

function rebalanceNode(nodeName, newTotal) {
  const tbody = document.getElementById('data-table-body');
  const rows = tbody.querySelectorAll('tr');
  let currentTotal = 0;
  const affectedRows = [];
  
  rows.forEach(row => {
    const inputs = row.querySelectorAll('input');
    if (inputs[0].value === nodeName) {
      currentTotal += parseFloat(inputs[2].value) || 0;
      affectedRows.push({ row, inputs, type: 'out' });
    }
  });
  
  if (affectedRows.length > 0 && currentTotal > 0) {
    const ratio = newTotal / currentTotal;
    affectedRows.forEach(({ inputs }) => {
      const oldVal = parseFloat(inputs[2].value) || 0;
      inputs[2].value = Math.round(oldVal * ratio * 100) / 100;
    });
    updateDiagramFromTableNoUndo();
  }
}

async function callGeminiChatAPI(apiKey, model, text) {
  const chatPrompt = `You are a helpful assistant for creating Sankey diagrams. Help users understand their data.

Current diagram data:
${document.getElementById('flows_in').value || 'No data yet'}

User question: ${text}

Respond helpfully and concisely. Keep responses under 150 words.`;

  const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      contents: [{ parts: [{ text: chatPrompt }] }],
      generationConfig: { temperature: 0.7, maxOutputTokens: 500 }
    })
  });
  
  if (!response.ok) {
    const err = await response.json();
    throw new Error(err.error?.message || 'API request failed');
  }
  
  const data = await response.json();
  return data.candidates?.[0]?.content?.parts?.[0]?.text || 'Sorry, I couldn\'t generate a response.';
}
</script>

<script>
// ============ JSON EDITOR ============
function openJSONEditor() {
  const modal = document.getElementById('json-editor-modal');
  const textarea = document.getElementById('json-editor-textarea');
  
  // Convert current data to JSON
  const jsonData = getCurrentDataAsJSON();
  textarea.value = JSON.stringify(jsonData, null, 2);
  
  modal.classList.add('active');
}

function closeJSONEditor() {
  document.getElementById('json-editor-modal').classList.remove('active');
}

function getCurrentDataAsJSON() {
  const tbody = document.getElementById('data-table-body');
  const rows = tbody.querySelectorAll('tr');
  const flows = [];
  
  rows.forEach(row => {
    const inputs = row.querySelectorAll('input');
    const from = inputs[0].value.trim();
    const to = inputs[1].value.trim();
    const amount = parseFloat(inputs[2].value) || 0;
    const comparison = inputs[3]?.value.trim() || '';
    
    if (from && to && amount) {
      flows.push({ from, to, amount, comparison: comparison || undefined });
    }
  });
  
  return {
    title: document.getElementById('diagram-title-input').value,
    flows,
    nodeColors,
    nodeCustomizations,
    options: getOptionsState()
  };
}

function applyJSONData() {
  const textarea = document.getElementById('json-editor-textarea');
  let jsonStr = textarea.value.trim();
  
  try {
    jsonStr = cleanJSON(jsonStr);
    const data = JSON.parse(jsonStr);
    
    saveStateForUndo();
    
    // Clear existing data
    document.getElementById('data-table-body').innerHTML = '';
    
    // Apply title
    if (data.title) {
      document.getElementById('diagram-title-input').value = data.title;
    }
    
    // Apply flows
    if (data.flows && Array.isArray(data.flows)) {
      data.flows.forEach(f => {
        addDataRowWithValues(
          f.from || f.source || '',
          f.to || f.target || '',
          String(f.amount || f.value || 0),
          f.comparison || ''
        );
      });
    }
    
    // Apply node colors
    if (data.nodeColors) {
      nodeColors = { ...data.nodeColors };
    }
    
    // Apply customizations
    if (data.nodeCustomizations) {
      nodeCustomizations = { ...data.nodeCustomizations };
    }
    
    // Apply options
    if (data.options) {
      restoreOptionsState(data.options);
    }
    
    updateDiagramFromTableNoUndo();
    closeJSONEditor();
    updateAIStatus('‚úì JSON data applied', 'success');
  } catch (e) {
    console.error('JSON parse error:', e);
    updateAIStatus('Invalid JSON: ' + e.message, 'error');
    alert('Invalid JSON format: ' + e.message);
  }
}

async function copyJSONToClipboard() {
  const textarea = document.getElementById('json-editor-textarea');
  try {
    await navigator.clipboard.writeText(textarea.value);
    updateAIStatus('‚úì Copied to clipboard', 'success');
  } catch (e) {
    textarea.select();
    document.execCommand('copy');
    updateAIStatus('‚úì Copied to clipboard', 'success');
  }
}

async function pasteJSONFromClipboard() {
  try {
    const text = await navigator.clipboard.readText();
    document.getElementById('json-editor-textarea').value = text;
    updateAIStatus('‚úì Pasted from clipboard', 'success');
  } catch (e) {
    updateAIStatus('Cannot access clipboard', 'error');
  }
}

function formatJSON() {
  const textarea = document.getElementById('json-editor-textarea');
  try {
    const data = JSON.parse(textarea.value);
    textarea.value = JSON.stringify(data, null, 2);
    updateAIStatus('‚úì JSON formatted', 'success');
  } catch (e) {
    updateAIStatus('Invalid JSON', 'error');
  }
}

// ============ SETTINGS ============
function openSettingsModal() {
  document.getElementById('settings-modal').classList.add('active');
}

function closeSettingsModal() {
  document.getElementById('settings-modal').classList.remove('active');
}

function saveSettings() {
  const apiKey = document.getElementById('gemini-api-key').value.trim();
  const model = document.getElementById('ai-model').value.trim() || 'gemini-2.0-flash';
  const prompt = document.getElementById('ai-system-prompt').value.trim();
  
  localStorage.setItem('gemini_api_key', apiKey);
  localStorage.setItem('ai_model', model);
  localStorage.setItem('ai_system_prompt', prompt);
  
  closeSettingsModal();
  updateAIStatus(apiKey ? '‚úì Settings saved' : '‚ö†Ô∏è No API key set', apiKey ? 'success' : 'warning');
}

function loadSettings() {
  document.getElementById('gemini-api-key').value = localStorage.getItem('gemini_api_key') || '';
  document.getElementById('ai-model').value = localStorage.getItem('ai_model') || 'gemini-2.0-flash';
  document.getElementById('ai-system-prompt').value = localStorage.getItem('ai_system_prompt') || DEFAULT_SYSTEM_PROMPT;
  
  const hasKey = !!localStorage.getItem('gemini_api_key');
  updateAIStatus(hasKey ? '‚úì API key configured' : '‚ö†Ô∏è Set API key in Settings', hasKey ? 'success' : 'warning');
}

function resetSystemPrompt() {
  document.getElementById('ai-system-prompt').value = DEFAULT_SYSTEM_PROMPT;
}

// ============ FILE OPERATIONS ============
function newDiagram() {
  if (confirm('Create new diagram? Current data will be cleared.')) {
    document.getElementById('data-table-body').innerHTML = '';
    document.getElementById('flows_in').value = '';
    document.getElementById('diagram-title-input').value = 'My Sankey Diagram';
    nodeColors = {};
    nodeCustomizations = {};
    labelPositions = {};
    addDataRowWithValues('', '', '', '');
    renderDiagram();
  }
}

function resetAllNodes() {
  if (typeof resetMovesAndRender === 'function') resetMovesAndRender();
  else if (window.resetMovesAndRender) window.resetMovesAndRender();
}

function resetAllLabels() {
  labelPositions = {};
  if (typeof resetLabelMovesAndRender === 'function') resetLabelMovesAndRender();
  else if (window.resetLabelMovesAndRender) window.resetLabelMovesAndRender();
  else renderDiagram();
}

function exportCSV() {
  const tbody = document.getElementById('data-table-body');
  const rows = tbody.querySelectorAll('tr');
  let csv = 'From,To,Amount,Comparison\n';
  rows.forEach(row => {
    const inputs = row.querySelectorAll('input');
    csv += `"${inputs[0].value}","${inputs[1].value}","${inputs[2].value}","${inputs[3]?.value || ''}"\n`;
  });
  
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'sankey_data.csv';
  a.click();
}

function importCSV(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = function(e) {
    const lines = e.target.result.split('\n');
    document.getElementById('data-table-body').innerHTML = '';
    
    lines.forEach((line, i) => {
      if (i === 0 && line.toLowerCase().includes('from')) return;
      const parts = line.split(',').map(p => p.replace(/"/g, '').trim());
      if (parts.length >= 3 && parts[0] && parts[1]) {
        addDataRowWithValues(parts[0], parts[1], parts[2] || '0', parts[3] || '');
      }
    });
    
    updateDiagramFromTable();
  };
  reader.readAsText(file);
  event.target.value = '';
}
</script>

<script>
// ============ ZOOM CONTROLS ============
function zoomCanvas(delta) {
  currentZoom = Math.max(0.25, Math.min(3, currentZoom + delta));
  document.getElementById('chart').style.transform = `scale(${currentZoom})`;
  document.getElementById('zoom-level').textContent = Math.round(currentZoom * 100) + '%';
}

function resetZoom() {
  currentZoom = 1.0;
  document.getElementById('chart').style.transform = 'scale(1)';
  document.getElementById('zoom-level').textContent = '100%';
}

// ============ UNDO FUNCTIONALITY ============
function saveStateForUndo() {
  const flowsEl = document.getElementById('flows_in');
  const tbodyEl = document.getElementById('data-table-body');
  if (!flowsEl || !tbodyEl) return;
  
  // Capture canvas state (node and label positions) from sankeymatic.js globals
  let nodeMoves = {};
  let labelMoves = {};
  
  // Access glob through window (sankeymatic.js exposes it)
  if (window.rememberedMoves && window.rememberedMoves.size) {
    window.rememberedMoves.forEach((val, key) => { nodeMoves[key] = val; });
  }
  if (window.rememberedLabelMoves && window.rememberedLabelMoves.size) {
    window.rememberedLabelMoves.forEach((val, key) => { labelMoves[key] = val; });
  }
  
  const currentState = {
    flows: flowsEl.value,
    tableHtml: tbodyEl.innerHTML,
    nodeMoves: nodeMoves,
    labelMoves: labelMoves,
    nodeCustomizations: JSON.parse(JSON.stringify(nodeCustomizations)),
    nodeColors: JSON.parse(JSON.stringify(nodeColors)),
    customLayout: JSON.parse(JSON.stringify(customLayout)),
    timestamp: Date.now()
  };
  
  // Only save if something changed
  if (lastSavedState && lastSavedState.flows === currentState.flows && 
      JSON.stringify(lastSavedState.nodeMoves) === JSON.stringify(currentState.nodeMoves) &&
      JSON.stringify(lastSavedState.labelMoves) === JSON.stringify(currentState.labelMoves) &&
      JSON.stringify(lastSavedState.customLayout) === JSON.stringify(currentState.customLayout)) {
    return;
  }
  
  undoStack.push(currentState);
  lastSavedState = currentState;
  if (undoStack.length > MAX_UNDO) undoStack.shift();
}

function undoLastAction() {
  if (undoStack.length <= 1) {
    updateAIStatus('Nothing to undo', 'warning');
    return;
  }
  
  undoStack.pop();
  const state = undoStack[undoStack.length - 1];
  
  const flowsEl = document.getElementById('flows_in');
  const tbodyEl = document.getElementById('data-table-body');
  if (flowsEl) flowsEl.value = state.flows;
  if (tbodyEl) tbodyEl.innerHTML = state.tableHtml;
  
  // Restore canvas state (node and label positions)
  if (window.rememberedMoves) {
    window.rememberedMoves.clear();
    if (state.nodeMoves) {
      Object.entries(state.nodeMoves).forEach(([key, val]) => {
        window.rememberedMoves.set(key, val);
      });
    }
  }
  if (window.rememberedLabelMoves) {
    window.rememberedLabelMoves.clear();
    if (state.labelMoves) {
      Object.entries(state.labelMoves).forEach(([key, val]) => {
        window.rememberedLabelMoves.set(key, val);
      });
    }
  }
  
  // Restore customizations
  if (state.nodeCustomizations) nodeCustomizations = JSON.parse(JSON.stringify(state.nodeCustomizations));
  if (state.nodeColors) nodeColors = JSON.parse(JSON.stringify(state.nodeColors));
  if (state.customLayout) customLayout = JSON.parse(JSON.stringify(state.customLayout));
  
  lastSavedState = state;
  renderDiagram();
  updateAIStatus('‚Ü©Ô∏è Undone', 'success');
}

// ============ STATUS ============
function updateStatus(rowCount) {
  const bar = document.getElementById('status-bar');
  const msg = document.getElementById('status-message');
  
  if (rowCount === 0) {
    bar.className = 'status-bar warning';
    msg.textContent = 'No valid flows - add data to create diagram';
    return;
  }
  
  const imbalanced = checkNodeBalance();
  if (imbalanced.length > 0) {
    bar.className = 'status-bar warning';
    const nodeList = imbalanced.map(n => `${n.node} (${n.diff > 0 ? '+' : ''}${n.diff.toFixed(2)})`).join(', ');
    msg.textContent = `‚ö†Ô∏è ${rowCount} flows ‚Ä¢ Imbalanced: ${nodeList}`;
  } else {
    bar.className = 'status-bar';
    msg.textContent = `‚úì ${rowCount} flows ‚Ä¢ All nodes balanced`;
  }
}

function checkNodeBalance() {
  const tbody = document.getElementById('data-table-body');
  const rows = tbody.querySelectorAll('tr');
  const nodeIn = {}, nodeOut = {};
  
  rows.forEach(row => {
    const inputs = row.querySelectorAll('input');
    const from = inputs[0].value.trim();
    const to = inputs[1].value.trim();
    const amount = parseFloat(inputs[2].value) || 0;
    
    if (from && to && amount > 0) {
      nodeOut[from] = (nodeOut[from] || 0) + amount;
      nodeIn[to] = (nodeIn[to] || 0) + amount;
    }
  });
  
  const allNodes = new Set([...Object.keys(nodeIn), ...Object.keys(nodeOut)]);
  const imbalanced = [];
  
  allNodes.forEach(node => {
    const inFlow = nodeIn[node] || 0;
    const outFlow = nodeOut[node] || 0;
    if (inFlow > 0 && outFlow > 0 && Math.abs(inFlow - outFlow) > 0.01) {
      imbalanced.push({ node, inFlow, outFlow, diff: inFlow - outFlow });
    }
  });
  
  return imbalanced;
}

// ============ SAVE/LOAD PROGRESS ============
const STORAGE_KEY = 'sankey_diagram_progress';

function saveProgressToLocal() {
  const progress = {
    title: document.getElementById('diagram-title-input').value,
    flows: document.getElementById('flows_in').value,
    tableData: getTableData(),
    options: getOptionsState(),
    labelPositions,
    nodeColors,
    nodeCustomizations,
    customLayout,
    zoom: currentZoom,
    savedAt: new Date().toISOString()
  };
  localStorage.setItem(STORAGE_KEY, JSON.stringify(progress));
}

function loadProgressFromLocal() {
  const saved = localStorage.getItem(STORAGE_KEY);
  if (!saved) return false;
  
  try {
    const progress = JSON.parse(saved);
    
    if (progress.title) document.getElementById('diagram-title-input').value = progress.title;
    if (progress.flows) document.getElementById('flows_in').value = progress.flows;
    
    if (progress.tableData && progress.tableData.length > 0) {
      const tbody = document.getElementById('data-table-body');
      tbody.innerHTML = '';
      progress.tableData.forEach(row => {
        addDataRowWithValues(row.from, row.to, row.amount, row.comparison);
      });
    }
    
    if (progress.options) restoreOptionsState(progress.options);
    if (progress.labelPositions) labelPositions = progress.labelPositions;
    if (progress.nodeColors) nodeColors = progress.nodeColors;
    if (progress.nodeCustomizations) nodeCustomizations = progress.nodeCustomizations;
    if (progress.customLayout) customLayout = progress.customLayout;
    
    if (progress.zoom) {
      currentZoom = progress.zoom;
      document.getElementById('chart').style.transform = `scale(${currentZoom})`;
      document.getElementById('zoom-level').textContent = Math.round(currentZoom * 100) + '%';
    }
    
    return true;
  } catch (e) {
    console.error('Failed to load progress:', e);
    return false;
  }
}

function getTableData() {
  const tbody = document.getElementById('data-table-body');
  const rows = tbody.querySelectorAll('tr');
  const data = [];
  rows.forEach(row => {
    const inputs = row.querySelectorAll('input');
    data.push({
      from: inputs[0].value,
      to: inputs[1].value,
      amount: inputs[2].value,
      comparison: inputs[3]?.value || ''
    });
  });
  return data;
}

function getOptionsState() {
  const options = {};
  const optionIds = [
    'opt_labelname_appears', 'opt_labelvalue_appears', 'opt_labels_comparisonline',
    'opt_labelname_size', 'opt_labels_color', 'opt_labels_fontface', 'opt_labels_googlefont',
    'opt_labels_decimalplaces', 'opt_value_prefix', 'opt_value_suffix',
    'opt_node_w', 'opt_node_h', 'opt_node_spacing', 'opt_node_border', 'opt_node_opacity',
    'opt_node_theme', 'opt_node_color',
    'opt_flow_opacity', 'opt_flow_curvature', 'opt_flow_color',
    'opt_size_w', 'opt_size_h',
    'opt_margin_l', 'opt_margin_r', 'opt_margin_t', 'opt_margin_b',
    'opt_bg_color', 'opt_bg_transparent'
  ];
  
  optionIds.forEach(id => {
    const el = document.getElementById(id);
    if (el) options[id] = el.type === 'checkbox' ? el.checked : el.value;
  });
  
  ['opt_flow_outside_in', 'opt_flow_source', 'opt_flow_target', 'opt_flow_single',
   'opt_layout_automatic', 'opt_layout_exact'].forEach(id => {
    const el = document.getElementById(id);
    if (el) options[id] = el.checked;
  });
  
  return options;
}

function restoreOptionsState(options) {
  for (const [id, value] of Object.entries(options)) {
    const el = document.getElementById(id);
    if (el) {
      if (el.type === 'checkbox' || el.type === 'radio') el.checked = value;
      else el.value = value;
    }
  }
}

function setupAutoSave() {
  document.getElementById('diagram-title-input').addEventListener('change', saveProgressToLocal);
  setInterval(saveProgressToLocal, 30000);
  window.addEventListener('beforeunload', saveProgressToLocal);
}
</script>

<script>
// ============ INITIALIZATION ============

document.addEventListener('DOMContentLoaded', function() {
  loadSettings();
  
  const hasProgress = loadProgressFromLocal();
  if (!hasProgress) {
    initializeDataTable();
  }
  
  setupAutoSave();
  
  // Wait for sankeymatic.js to load, then render
  setTimeout(() => {
    renderDiagram();
    saveStateForUndo();
    // Initial setup of handlers
    setTimeout(() => {
      setupNodeClickHandlers();
      applyLabelPositions();
    }, 300);
  }, 500);
  
  // Re-init handlers after each render
  const observer = new MutationObserver(function(mutations) {
    // Debounce to avoid multiple calls
    clearTimeout(window.svgUpdateTimeout);
    window.svgUpdateTimeout = setTimeout(() => {
      setupNodeClickHandlers();
      applyLabelPositions();
    }, 150);
  });
  
  const chartEl = document.getElementById('chart');
  if (chartEl) {
    observer.observe(chartEl, { childList: true, subtree: true });
  }
  
  // Mouse wheel zoom on canvas
  const diagramArea = document.getElementById('diagram-area');
  if (diagramArea) {
    diagramArea.addEventListener('wheel', function(e) {
      if (e.ctrlKey) {
        e.preventDefault();
        zoomCanvas(e.deltaY > 0 ? -0.1 : 0.1);
      }
    }, { passive: false });
  }
  
  // Note: Label dragging is handled by sankeymatic.js D3 drag behavior
  // No additional global handlers needed
  
  // Close popup when clicking outside
  document.getElementById('node-popup-overlay').addEventListener('click', function(e) {
    if (e.target === this) closeNodePopup();
  });
  
  // Keyboard shortcuts
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
      closeNodePopup();
      closeJSONEditor();
      closeSettingsModal();
    }
    if (e.ctrlKey && e.key === 'z') {
      e.preventDefault();
      undoLastAction();
    }
  });
});
</script>
</body>
</html>
