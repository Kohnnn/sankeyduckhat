<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8">
<meta name="viewport" content="initial-scale=1">
<title>Sankey Diagram Builder</title>
<link rel="stylesheet" href="build.css?v=5">
<link rel="stylesheet" href="studio-theme.css?v=5">
<link rel="stylesheet" href="studio-layout.css?v=5">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&family=Manrope:wght@200..800&display=swap" rel="stylesheet">
<!-- Core dependencies -->
<script defer src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/canvg@3/lib/umd.js" crossorigin="anonymous"></script>
<!-- SankeyMATIC core -->
<script defer src="constants.js?v=5"></script>
<script defer src="sankey.js?v=5"></script>
<script defer src="lz-string.min.js?v=5"></script>
<script defer src="color_palettes.js?v=5"></script>
<script defer src="templates.js?v=5"></script>
<!-- Studio UI modules -->
<script defer src="studio-ui.js?v=5"></script>
<script defer src="viewport-controller.js?v=5"></script>
<script defer src="custom-layout-store.js?v=5"></script>
<script defer src="sankey-integration.js?v=5"></script>
<script defer src="selection-manager.js?v=5"></script>
<script defer src="selection-handlers.js?v=5"></script>
<script defer src="properties-panel.js?v=5"></script>
<script defer src="toolbar-controller.js?v=5"></script>
<script defer src="theme-controller.js?v=5"></script>
<script defer src="studio-layout.js?v=5"></script>
<script defer src="data-sync.js?v=5"></script>
<script defer src="undo-manager.js?v=5"></script>
<script defer src="session-manager.js?v=5"></script>
<script defer src="recent-colors-manager.js?v=5"></script>
<script defer src="ai-controller.js?v=5"></script>
<script defer src="validation-utils.js?v=5"></script>
<script defer src="drag-handler.js?v=5"></script>
<script defer src="drag-behaviors.js?v=5"></script>
<script defer src="flow-utils.js?v=5"></script>
<script defer src="studio-init.js?v=5"></script>
<script defer src="sankeymatic.js?v=5"></script>
<style>
* { box-sizing: border-box; }
body { margin: 0; font-family: 'Inter', 'Manrope', sans-serif; font-size: 13px; background: #f5f5f5; }
.app-container { display: flex; flex-direction: column; height: 100vh; overflow: hidden; }

/* Menu Bar */
.menu-bar { display: flex; background: #fff; border-bottom: 1px solid #e0e0e0; padding: 0; align-items: center; height: 40px; flex-shrink: 0; }
.menu-item { position: relative; padding: 10px 16px; cursor: pointer; font-size: 13px; color: #333; border: none; background: none; font-family: inherit; height: 100%; display: flex; align-items: center; }
.menu-item:hover { background: #f0f0f0; }
.menu-dropdown { display: none; position: absolute; top: 100%; left: 0; background: #fff; border: 1px solid #e0e0e0; box-shadow: 0 4px 12px rgba(0,0,0,0.15); min-width: 280px; z-index: 1000; max-height: 80vh; overflow-y: auto; }
.menu-item:hover .menu-dropdown { display: block; }
.menu-section-title { padding: 8px 16px; font-weight: 600; color: #666; background: #f8f8f8; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; }
.menu-dropdown-item { display: flex; align-items: center; padding: 8px 16px; cursor: pointer; font-size: 13px; gap: 8px; }
.menu-dropdown-item:hover { background: #f5f5f5; }
.menu-dropdown-item input[type="checkbox"] { margin: 0; }
.menu-dropdown-item input[type="number"], .menu-dropdown-item input[type="text"], .menu-dropdown-item select { padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; }
.menu-dropdown-item input[type="color"] { width: 30px; height: 24px; padding: 0; border: 1px solid #ddd; }
.menu-dropdown-item label { flex: 1; }
.menu-divider { height: 1px; background: #e0e0e0; margin: 4px 0; }
.menu-spacer { flex: 1; }
.menu-btn { padding: 6px 12px; margin: 0 8px; background: #1a73e8; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; }
.menu-btn:hover { background: #1557b0; }
.menu-btn.secondary { background: #f1f3f4; color: #333; }
.menu-btn.secondary:hover { background: #e8eaed; }

/* Main Content */
.main-content { display: flex; flex: 1; overflow: hidden; }
</style>
</head>
<body>
<div class="app-container studio-container">
<style>
/* Diagram Panel */
.diagram-panel { flex: 1; display: flex; flex-direction: column; background: #fff; overflow: hidden; }
.diagram-title-bar { padding: 12px 20px; border-bottom: 1px solid #e0e0e0; background: #fafafa; }
.diagram-title-input { border: none; font-size: 20px; font-weight: 600; width: 100%; background: transparent; text-align: center; }
.diagram-title-input:focus { outline: 2px solid #1a73e8; border-radius: 4px; }
.diagram-area { flex: 1; display: flex; justify-content: center; align-items: center; overflow: auto; padding: 20px; background: #fff; position: relative; }
#chart_container { position: relative; }
.diagram-footer { padding: 8px 20px; text-align: center; font-size: 11px; color: #999; border-top: 1px solid #e0e0e0; background: #fafafa; }

/* Studio Toolbar */
.studio-toolbar {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  background: linear-gradient(to bottom, #fafafa, #f0f0f0);
  border-bottom: 1px solid #e0e0e0;
  flex-shrink: 0;
}

.toolbar-group {
  display: flex;
  align-items: center;
  gap: 4px;
}

.toolbar-divider {
  width: 1px;
  height: 28px;
  background: #ddd;
  margin: 0 4px;
}

.toolbar-spacer {
  flex: 1;
}

.toolbar-btn {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 6px 10px;
  border: 1px solid #ddd;
  background: #fff;
  border-radius: 6px;
  cursor: pointer;
  font-size: 12px;
  font-family: inherit;
  color: #333;
  transition: all 0.15s ease;
}

.toolbar-btn:hover {
  background: #f0f0f0;
  border-color: #ccc;
}

.toolbar-btn.active {
  background: #1a73e8;
  border-color: #1a73e8;
  color: white;
}

.toolbar-btn.active:hover {
  background: #1557b0;
  border-color: #1557b0;
}

.toolbar-btn:focus {
  outline: 2px solid #1a73e8;
  outline-offset: 1px;
}

.toolbar-btn-secondary {
  background: #f5f5f5;
  font-size: 11px;
  padding: 5px 8px;
}

.toolbar-btn-secondary:hover {
  background: #e8e8e8;
}

.toolbar-icon {
  font-size: 14px;
  line-height: 1;
}

.toolbar-label {
  font-size: 11px;
  font-weight: 500;
}

.zoom-display {
  font-size: 12px;
  min-width: 45px;
  text-align: center;
  color: #666;
  font-variant-numeric: tabular-nums;
}

/* Tool-specific cursor styles */
.diagram-area[data-tool="select"] { cursor: default; }
.diagram-area[data-tool="pan"] { cursor: grab; }
.diagram-area[data-tool="pan"]:active { cursor: grabbing; }
.diagram-area[data-tool="addNode"] { cursor: crosshair; }
.diagram-area[data-tool="addFlow"] { cursor: crosshair; }

/* Flow source selection highlight */
.flow-source-selected {
  stroke: #1a73e8 !important;
  stroke-width: 3px !important;
  stroke-dasharray: 5,3;
  animation: flow-source-pulse 1s ease-in-out infinite;
}

@keyframes flow-source-pulse {
  0%, 100% { stroke-opacity: 1; }
  50% { stroke-opacity: 0.5; }
}

/* Right Panel */
.right-panel { width: 480px; min-width: 480px; border-left: 1px solid #e0e0e0; display: flex; flex-direction: column; background: #fff; overflow: hidden; }
.panel-header { padding: 12px 16px; font-weight: 600; font-size: 14px; background: #f8f9fa; border-bottom: 1px solid #e0e0e0; display: flex; align-items: center; justify-content: space-between; }
.panel-header-actions { display: flex; gap: 8px; }
.panel-header-actions button { padding: 4px 10px; font-size: 11px; border: 1px solid #ddd; background: #fff; border-radius: 4px; cursor: pointer; }
.panel-header-actions button:hover { background: #f5f5f5; }

/* Data Table */
.data-table-wrapper { flex: 1; overflow: auto; }
.data-table { width: 100%; border-collapse: collapse; font-size: 12px; }
.data-table th { background: #f1f3f4; padding: 10px 8px; text-align: left; font-weight: 500; color: #5f6368; border-bottom: 1px solid #e0e0e0; position: sticky; top: 0; z-index: 10; }
.data-table td { padding: 4px; border-bottom: 1px solid #f0f0f0; }
.data-table input { width: 100%; border: 1px solid transparent; padding: 6px 8px; font-size: 12px; background: transparent; border-radius: 4px; }
.data-table input:focus { border-color: #1a73e8; outline: none; background: #fff; }
.data-table .delete-btn { color: #dc3545; cursor: pointer; padding: 4px 8px; border: none; background: none; font-size: 16px; }
.data-table .delete-btn:hover { background: #fee; border-radius: 4px; }
.add-row-section { padding: 12px 16px; border-top: 1px solid #e0e0e0; display: flex; align-items: center; gap: 8px; background: #fafafa; }
.add-row-btn { padding: 6px 12px; border: 1px solid #ddd; background: #fff; cursor: pointer; font-size: 12px; border-radius: 4px; display: flex; align-items: center; gap: 4px; }
.add-row-btn:hover { background: #f5f5f5; }

/* AI Section */
.ai-section { border-top: 1px solid #e0e0e0; background: #f8f9fa; }
.ai-section-header { padding: 12px 16px; font-weight: 600; font-size: 13px; display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid #e0e0e0; background: #fff; }
.ai-settings-btn { padding: 4px 8px; background: none; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 12px; }
.ai-settings-btn:hover { background: #f5f5f5; }
.ai-chat-area { padding: 12px 16px; }
.ai-chat-input-wrapper { display: flex; gap: 8px; margin-bottom: 8px; }
.ai-chat-input { flex: 1; padding: 10px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 13px; resize: none; min-height: 60px; }
.ai-chat-input:focus { outline: none; border-color: #1a73e8; }
.ai-chat-btn { padding: 10px 20px; background: #1a73e8; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; align-self: flex-end; }
.ai-chat-btn:hover { background: #1557b0; }
.ai-chat-btn:disabled { background: #ccc; cursor: not-allowed; }
.ai-status { font-size: 12px; padding: 8px 0; }
.ai-status.success { color: #0d6efd; }
.ai-status.error { color: #dc3545; }
.ai-status.warning { color: #fd7e14; }

/* Status Bar */
.status-bar { padding: 10px 20px; background: #e8f5e9; border-top: 1px solid #c8e6c9; display: flex; align-items: center; gap: 8px; font-size: 13px; color: #2e7d32; flex-shrink: 0; }
.status-bar.warning { background: #fff3e0; border-color: #ffe0b2; color: #e65100; }
.status-bar.error { background: #ffebee; border-color: #ffcdd2; color: #c62828; }
</style>
<style>
/* Node Customization Popup */
.node-popup-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.3); z-index: 2000; }
.node-popup-overlay.active { display: flex; justify-content: center; align-items: center; }
.node-popup { background: #fff; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.2); width: 380px; max-width: 95%; max-height: 90vh; overflow: auto; }
.node-popup-header { padding: 16px 20px; border-bottom: 1px solid #e0e0e0; display: flex; justify-content: space-between; align-items: center; background: #f8f9fa; border-radius: 12px 12px 0 0; }
.node-popup-header h3 { margin: 0; font-size: 16px; font-weight: 600; }
.node-popup-close { background: none; border: none; font-size: 24px; cursor: pointer; color: #666; padding: 0; line-height: 1; }
.node-popup-body { padding: 20px; }
.node-popup-section { margin-bottom: 20px; }
.node-popup-section h4 { margin: 0 0 12px; font-size: 13px; font-weight: 600; color: #333; text-transform: uppercase; letter-spacing: 0.5px; }
.node-popup-row { display: flex; align-items: center; gap: 12px; margin-bottom: 12px; }
.node-popup-row label { flex: 0 0 100px; font-size: 13px; color: #666; }
.node-popup-row input[type="text"], .node-popup-row input[type="number"] { flex: 1; padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 13px; }
.node-popup-row input[type="color"] { width: 50px; height: 36px; padding: 2px; border: 1px solid #ddd; border-radius: 6px; cursor: pointer; }
.node-popup-row input:focus { outline: none; border-color: #1a73e8; }
.node-popup-toggle { display: flex; align-items: center; gap: 8px; }
.node-popup-toggle input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; }
.node-popup-alignment { display: flex; gap: 4px; }
.node-popup-alignment button { padding: 8px 12px; border: 1px solid #ddd; background: #fff; cursor: pointer; font-size: 12px; }
.node-popup-alignment button:first-child { border-radius: 6px 0 0 6px; }
.node-popup-alignment button:last-child { border-radius: 0 6px 6px 0; }
.node-popup-alignment button.active { background: #1a73e8; color: white; border-color: #1a73e8; }
.node-popup-footer { padding: 16px 20px; border-top: 1px solid #e0e0e0; display: flex; justify-content: flex-end; gap: 8px; background: #f8f9fa; border-radius: 0 0 12px 12px; }
.btn { padding: 10px 20px; border-radius: 6px; font-size: 13px; cursor: pointer; font-weight: 500; }
.btn-secondary { background: #f1f3f4; border: 1px solid #ddd; color: #333; }
.btn-primary { background: #1a73e8; border: 1px solid #1a73e8; color: white; }
.btn:hover { opacity: 0.9; }

/* Modal Overlay */
.modal-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 2000; justify-content: center; align-items: center; }
.modal-overlay.active { display: flex; }
.modal { background: #fff; border-radius: 12px; width: 500px; max-width: 90%; max-height: 90vh; overflow: auto; box-shadow: 0 8px 32px rgba(0,0,0,0.2); }
.modal-header { padding: 16px 20px; border-bottom: 1px solid #e0e0e0; display: flex; justify-content: space-between; align-items: center; position: sticky; top: 0; background: #fff; }
.modal-header h3 { margin: 0; font-size: 16px; }
.modal-close { background: none; border: none; font-size: 24px; cursor: pointer; color: #666; padding: 0; line-height: 1; }
.modal-body { padding: 20px; }
.form-group { margin-bottom: 16px; }
.form-group label { display: block; margin-bottom: 6px; font-size: 13px; font-weight: 500; }
.form-group input, .form-group select, .form-group textarea { width: 100%; padding: 10px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 13px; }
.form-group input:focus, .form-group select:focus, .form-group textarea:focus { outline: none; border-color: #1a73e8; }
.form-group .hint { font-size: 11px; color: #666; margin-top: 4px; }
.form-group .hint a { color: #1a73e8; }
.modal-footer { padding: 16px 20px; border-top: 1px solid #e0e0e0; display: flex; justify-content: flex-end; gap: 8px; position: sticky; bottom: 0; background: #fff; }

/* JSON Editor Modal */
.json-editor-modal { width: 700px; }
.json-editor-textarea { font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; font-size: 12px; min-height: 300px; resize: vertical; }
.json-editor-actions { display: flex; gap: 8px; margin-bottom: 12px; }

/* Multi-image upload */
.image-upload-area { border: 2px dashed #ddd; border-radius: 8px; padding: 20px; text-align: center; cursor: pointer; transition: all 0.2s; }
.image-upload-area:hover { border-color: #1a73e8; background: #f8f9ff; }
.image-upload-area.dragover { border-color: #1a73e8; background: #e3f2fd; }
.image-previews { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 12px; }
.image-preview-item { position: relative; width: 80px; height: 80px; border-radius: 8px; overflow: hidden; border: 1px solid #ddd; }
.image-preview-item img { width: 100%; height: 100%; object-fit: cover; }
.image-preview-item .remove-btn { position: absolute; top: 2px; right: 2px; width: 20px; height: 20px; background: rgba(220,53,69,0.9); color: white; border: none; border-radius: 50%; cursor: pointer; font-size: 12px; line-height: 1; }
.upload-progress { margin-top: 8px; }
.progress-bar { height: 4px; background: #e0e0e0; border-radius: 2px; overflow: hidden; }
.progress-bar-fill { height: 100%; background: #1a73e8; transition: width 0.3s; }

/* Hide old elements */
.header, .footer, .center_basic, .skm_grid { display: none !important; }
</style>

  <!-- Menu Bar -->
  <div class="menu-bar studio-menu-bar">
    <div class="menu-item">
      File
      <div class="menu-dropdown">
        <div class="menu-dropdown-item" onclick="newDiagram()">üìÑ New Diagram</div>
        <div class="menu-dropdown-item" onclick="document.getElementById('load_file_input').click()">üìÇ Open File...</div>
        <div class="menu-dropdown-item" onclick="saveDiagramToFile()">üíæ Save As...</div>
        <div class="menu-divider"></div>
        <div class="menu-dropdown-item" onclick="saveDiagramAsPNG(2)">üñºÔ∏è Export as PNG</div>
        <div class="menu-dropdown-item" onclick="saveDiagramAsPNG(4)">üñºÔ∏è Export as PNG (Large)</div>
        <div class="menu-dropdown-item" onclick="saveDiagramAsSVG()">üìê Export as SVG</div>
      </div>
    </div>
    
    <div class="menu-item">
      Labels
      <div class="menu-dropdown">
        <div class="menu-section-title">Display</div>
        <div class="menu-dropdown-item"><input type="checkbox" id="opt_labelname_appears" checked onchange="updateOption()"><label for="opt_labelname_appears">Show Names</label></div>
        <div class="menu-dropdown-item"><input type="checkbox" id="opt_labelvalue_appears" checked onchange="updateOption()"><label for="opt_labelvalue_appears">Show Values</label></div>
        <div class="menu-dropdown-item"><input type="checkbox" id="opt_labels_comparisonline" onchange="updateOption()"><label for="opt_labels_comparisonline">Show Comparison %</label></div>
        <div class="menu-divider"></div>
        <div class="menu-section-title">Typography</div>
        <div class="menu-dropdown-item"><label>Font Size</label><input type="number" id="opt_labelname_size" value="16" min="8" max="36" style="width:60px" onchange="updateOption()"></div>
        <div class="menu-dropdown-item"><label>Color</label><input type="color" id="opt_labels_color" value="#000000" onchange="updateOption()"></div>
        <div class="menu-dropdown-item"><label>Font</label><select id="opt_labels_fontface" onchange="updateFontOption()" style="width:120px"><option value="sans-serif">Sans-serif</option><option value="serif">Serif</option><option value="monospace">Monospace</option></select></div>
        <div class="menu-dropdown-item"><label>Google Font</label><select id="opt_labels_googlefont" onchange="updateOption()" style="width:120px"><option value="">None</option><option value="Inter">Inter</option><option value="Manrope">Manrope</option><option value="Roboto">Roboto</option><option value="Open Sans">Open Sans</option><option value="Lato">Lato</option><option value="Montserrat">Montserrat</option><option value="Poppins">Poppins</option></select></div>
        <div class="menu-divider"></div>
        <div class="menu-section-title">Number Format</div>
        <div class="menu-dropdown-item"><label>Decimal Places</label><select id="opt_labels_decimalplaces" onchange="updateOption()" style="width:60px"><option value="0">0</option><option value="1">1</option><option value="2" selected>2</option></select></div>
        <div class="menu-dropdown-item"><label>Prefix</label><input type="text" id="opt_value_prefix" value="" style="width:60px" onchange="updateOption()" placeholder="$"></div>
        <div class="menu-dropdown-item"><label>Suffix</label><input type="text" id="opt_value_suffix" value="" style="width:60px" onchange="updateOption()"></div>
      </div>
    </div>
    
    <div class="menu-item">
      Nodes
      <div class="menu-dropdown">
        <div class="menu-section-title">Dimensions</div>
        <div class="menu-dropdown-item"><label>Width</label><input type="number" id="opt_node_w" value="12" min="0" max="100" style="width:60px" onchange="updateOption()"></div>
        <div class="menu-dropdown-item"><label>Height %</label><input type="number" id="opt_node_h" value="50" min="0" max="100" style="width:60px" onchange="updateOption()"></div>
        <div class="menu-dropdown-item"><label>Spacing %</label><input type="number" id="opt_node_spacing" value="75" min="0" max="100" style="width:60px" onchange="updateOption()"></div>
        <div class="menu-dropdown-item"><label>Border</label><input type="number" id="opt_node_border" value="0" min="0" max="10" style="width:60px" onchange="updateOption()"></div>
        <div class="menu-dropdown-item"><label>Opacity %</label><input type="number" id="opt_node_opacity" value="100" min="0" max="100" style="width:60px" onchange="updateOption()"></div>
        <div class="menu-divider"></div>
        <div class="menu-section-title">Colors</div>
        <div class="menu-dropdown-item"><label>Theme</label><select id="opt_node_theme" onchange="updateOption()" style="width:100px"><option value="a">Theme A</option><option value="b">Theme B</option><option value="c">Theme C</option><option value="d">Theme D</option><option value="none">Single Color</option></select></div>
        <div class="menu-dropdown-item"><label>Single Color</label><input type="color" id="opt_node_color" value="#888888" onchange="updateOption()"></div>
      </div>
    </div>
    
    <div class="menu-item">
      Flows
      <div class="menu-dropdown">
        <div class="menu-section-title">Appearance</div>
        <div class="menu-dropdown-item"><label>Opacity %</label><input type="number" id="opt_flow_opacity" value="45" min="0" max="100" style="width:60px" onchange="updateOption()"></div>
        <div class="menu-dropdown-item"><label>Curviness %</label><input type="number" id="opt_flow_curvature" value="50" min="10" max="90" style="width:60px" onchange="updateOption()"></div>
        <div class="menu-divider"></div>
        <div class="menu-section-title">Color Source</div>
        <div class="menu-dropdown-item"><input type="radio" name="flow_color" id="opt_flow_outside_in" checked onchange="updateOption()"><label for="opt_flow_outside_in">From outermost nodes</label></div>
        <div class="menu-dropdown-item"><input type="radio" name="flow_color" id="opt_flow_source" onchange="updateOption()"><label for="opt_flow_source">From source node</label></div>
        <div class="menu-dropdown-item"><input type="radio" name="flow_color" id="opt_flow_target" onchange="updateOption()"><label for="opt_flow_target">From target node</label></div>
        <div class="menu-dropdown-item"><input type="radio" name="flow_color" id="opt_flow_single" onchange="updateOption()"><label for="opt_flow_single">Single color</label><input type="color" id="opt_flow_color" value="#999999" onchange="updateOption()"></div>
      </div>
    </div>
    
    <div class="menu-item">
      Layout
      <div class="menu-dropdown">
        <div class="menu-section-title">Diagram Size</div>
        <div class="menu-dropdown-item"><label>Width</label><input type="number" id="opt_size_w" value="700" min="100" max="2000" style="width:80px" onchange="updateOption()"></div>
        <div class="menu-dropdown-item"><label>Height</label><input type="number" id="opt_size_h" value="500" min="100" max="2000" style="width:80px" onchange="updateOption()"></div>
        <div class="menu-divider"></div>
        <div class="menu-section-title">Margins</div>
        <div class="menu-dropdown-item"><label>Left</label><input type="number" id="opt_margin_l" value="80" min="0" style="width:50px" onchange="updateOption()"><label>Right</label><input type="number" id="opt_margin_r" value="80" min="0" style="width:50px" onchange="updateOption()"></div>
        <div class="menu-dropdown-item"><label>Top</label><input type="number" id="opt_margin_t" value="30" min="0" style="width:50px" onchange="updateOption()"><label>Bottom</label><input type="number" id="opt_margin_b" value="30" min="0" style="width:50px" onchange="updateOption()"></div>
        <div class="menu-divider"></div>
        <div class="menu-section-title">Background</div>
        <div class="menu-dropdown-item"><label>Color</label><input type="color" id="opt_bg_color" value="#FFFFFF" onchange="updateOption()"><input type="checkbox" id="opt_bg_transparent" onchange="updateOption()"><label for="opt_bg_transparent">Transparent</label></div>
        <div class="menu-divider"></div>
        <div class="menu-dropdown-item" onclick="resetAllNodes()">üîÑ Reset Node Positions</div>
        <div class="menu-dropdown-item" onclick="resetAllLabels()">üîÑ Reset Label Positions</div>
      </div>
    </div>
    
    <div class="menu-spacer"></div>
    <button class="menu-btn secondary" onclick="openJSONEditor()">üìã JSON Editor</button>
    <button class="menu-btn secondary" onclick="openSettingsModal()">‚öôÔ∏è AI Settings</button>
  </div>

  <!-- Main Content -->
  <div class="main-content studio-main">
    <!-- Diagram Panel (Canvas Container) -->
    <div class="diagram-panel studio-canvas-container">
      <div class="diagram-title-bar studio-canvas-title">
        <input type="text" class="diagram-title-input studio-canvas-title-input" id="diagram-title-input" value="My Sankey Diagram" placeholder="Enter diagram title...">
      </div>
      
      <!-- Studio Toolbar -->
      <div class="studio-toolbar studio-toolbar-container" id="studio-toolbar">
        <!-- Tool Buttons Group -->
        <div class="toolbar-group toolbar-tools">
          <button class="toolbar-btn active" data-tool="select" title="Select Tool (V)" aria-pressed="true">
            <span class="toolbar-icon">üîç</span>
            <span class="toolbar-label">Select</span>
          </button>
          <button class="toolbar-btn" data-tool="pan" title="Pan Tool (H)" aria-pressed="false">
            <span class="toolbar-icon">‚úã</span>
            <span class="toolbar-label">Pan</span>
          </button>
          <button class="toolbar-btn" data-tool="addNode" title="Add Node Tool (N)" aria-pressed="false">
            <span class="toolbar-icon">‚¨ú</span>
            <span class="toolbar-label">Add Node</span>
          </button>
          <button class="toolbar-btn" data-tool="addFlow" title="Add Flow Tool (F)" aria-pressed="false">
            <span class="toolbar-icon">‚ÜóÔ∏è</span>
            <span class="toolbar-label">Add Flow</span>
          </button>
        </div>

        <div class="toolbar-divider"></div>

        <!-- Zoom Controls Group -->
        <div class="toolbar-group toolbar-zoom">
          <button class="toolbar-btn" onclick="zoomCanvas(-0.1)" title="Zoom Out (Ctrl+Scroll)">
            <span class="toolbar-icon">‚ûñ</span>
          </button>
          <span id="zoom-level" class="zoom-display">100%</span>
          <button class="toolbar-btn" onclick="zoomCanvas(0.1)" title="Zoom In (Ctrl+Scroll)">
            <span class="toolbar-icon">‚ûï</span>
          </button>
          <button class="toolbar-btn" onclick="fitToScreen()" title="Fit to Screen">
            <span class="toolbar-icon">üìê</span>
            <span class="toolbar-label">Fit</span>
          </button>
          <button class="toolbar-btn" onclick="resetZoom()" title="Reset Zoom">
            <span class="toolbar-icon">üîÑ</span>
          </button>
        </div>

        <div class="toolbar-divider"></div>

        <!-- Action Buttons Group -->
        <div class="toolbar-group toolbar-actions">
          <button class="toolbar-btn" data-action="undo" title="Undo (Ctrl+Z)">
            <span class="toolbar-icon">‚Ü©Ô∏è</span>
            <span class="toolbar-label">Undo</span>
          </button>
          <button class="toolbar-btn" data-action="redo" title="Redo (Ctrl+Y)">
            <span class="toolbar-icon">‚Ü™Ô∏è</span>
            <span class="toolbar-label">Redo</span>
          </button>
          <button class="toolbar-btn" data-action="export" title="Export Diagram">
            <span class="toolbar-icon">üíæ</span>
            <span class="toolbar-label">Export</span>
          </button>
          <button class="toolbar-btn" data-action="reset-session" title="Reset Session - Start Fresh">
            <span class="toolbar-icon">üóëÔ∏è</span>
            <span class="toolbar-label">New</span>
          </button>
        </div>

        <div class="toolbar-spacer"></div>

        <!-- Reset Controls -->
        <div class="toolbar-group toolbar-reset">
          <button class="toolbar-btn toolbar-btn-secondary" data-action="reset-nodes" title="Reset Node Positions">
            Reset Nodes
          </button>
          <button class="toolbar-btn toolbar-btn-secondary" data-action="reset-labels" title="Reset Label Positions">
            Reset Labels
          </button>
          <button class="toolbar-btn toolbar-btn-secondary" data-action="factory-reset" title="Factory Reset - Return to Initial State" style="color:#dc3545;">
            üîÑ Factory Reset
          </button>
        </div>

        <div class="toolbar-divider"></div>

        <!-- Theme Toggle -->
        <div class="toolbar-group toolbar-theme">
          <button class="toolbar-btn toolbar-btn-secondary" id="theme-toggle-btn" onclick="toggleTheme()" title="Toggle Dark/Light Theme">
            <span class="toolbar-icon" id="theme-icon">üåô</span>
            <span class="toolbar-label" id="theme-label">Dark</span>
          </button>
        </div>
      </div>
      
      <div class="diagram-area studio-canvas-viewport" id="diagram-area" style="overflow:auto;">
        <!-- Canvas grid background (fixed, doesn't pan/zoom) -->
        <div class="canvas-grid-background" id="canvas-grid"></div>
        <div id="chart" style="transform-origin:center center;transition:transform 0.2s;">
          <svg id="sankey_svg" height="500" width="700" xmlns="http://www.w3.org/2000/svg"></svg>
        </div>
        <svg id="svg_scratch" height="500" width="700" xmlns="http://www.w3.org/2000/svg" style="display:none;"></svg>
        <canvas id="png_preview" height="500" width="700" style="display:none;"></canvas>
      </div>
      
      <div class="diagram-footer studio-canvas-footer">
        ‚¨ú Click node to edit appearance ‚Ä¢ üè∑Ô∏è Double-click label to edit text/style ‚Ä¢ Drag nodes and labels freely
      </div>
    </div>

    <!-- Right Panel - Data Editor -->
    <div class="right-panel studio-data-panel">
      <div class="panel-header studio-properties-header">
        <span class="studio-properties-header-title">
          <span class="studio-properties-header-icon">üìä</span>
          Data Editor
        </span>
        <div class="panel-header-actions studio-properties-header-actions">
          <button class="studio-properties-header-btn" onclick="exportCSV()">Export CSV</button>
          <button class="studio-properties-header-btn" onclick="document.getElementById('csv_import').click()">Import CSV</button>
          <button class="studio-properties-header-btn" id="toggle-data-panel-btn" onclick="toggleDataPanel()" title="Toggle Panel (Ctrl+Shift+\)">
            <span class="toggle-icon" id="toggle-panel-icon">‚óÄ</span>
          </button>
        </div>
      </div>
      
      <!-- Data Panel Tabs -->
      <div class="studio-data-tabs">
        <button class="studio-data-tab active" data-tab="data-editor">üìä Data</button>
        <button class="studio-data-tab" data-tab="ai-assistant">ü§ñ AI Assistant</button>
      </div>
      
      <!-- Data Panel Content -->
      <div class="studio-data-content">
        <!-- Data Editor Tab Content -->
        <div class="studio-data-tab-content active" data-tab-content="data-editor">
          <div class="data-table-wrapper">
            <table class="data-table">
              <thead>
                <tr>
                  <th style="width:25%">From</th>
                  <th style="width:25%">To</th>
                  <th style="width:20%">Amount</th>
                  <th style="width:15%">Comparison</th>
                  <th style="width:15%"></th>
                </tr>
              </thead>
              <tbody id="data-table-body"></tbody>
            </table>
          </div>
          
          <div class="add-row-section">
            <button class="add-row-btn" onclick="addDataRow()">+ Add</button>
            <input type="number" id="add-row-count" value="1" min="1" max="20" style="width:50px">
            <span>rows</span>
            <div style="flex:1"></div>
            <button class="add-row-btn" onclick="clearAllRows()">Clear All</button>
          </div>
        </div>
        
        <!-- AI Assistant Tab Content -->
        <div class="studio-data-tab-content" data-tab-content="ai-assistant">
          <div class="ai-section">
            <div class="ai-chat-area">
              <!-- Chat History -->
              <div id="ai-chat-history" style="max-height:200px;overflow-y:auto;margin-bottom:8px;font-size:12px;border:1px solid var(--studio-border-light, #e0e0e0);border-radius:6px;padding:8px;background:var(--studio-bg-primary, #fff);min-height:80px;">
                <div style="color:var(--studio-text-tertiary, #999);font-size:11px;text-align:center;">Chat with AI about your data, or upload images to extract flows</div>
              </div>
              
              <!-- Multi-Image Upload Area -->
              <div class="image-upload-area" id="image-upload-area" onclick="document.getElementById('ai-image-input').click()">
                <div>üì∑ Drop images here or click to upload</div>
                <div style="font-size:11px;color:var(--studio-text-tertiary, #999);margin-top:4px;">Supports multiple images ‚Ä¢ Ctrl+V to paste</div>
              </div>
              <div class="image-previews" id="image-previews"></div>
              <div class="upload-progress" id="upload-progress" style="display:none;">
                <div class="progress-bar"><div class="progress-bar-fill" id="progress-bar-fill" style="width:0%"></div></div>
                <div style="font-size:11px;color:var(--studio-text-secondary, #666);margin-top:4px;" id="progress-text">Processing...</div>
              </div>
              
              <div class="ai-chat-input-wrapper" style="margin-top:12px;">
                <textarea class="ai-chat-input" id="ai-chat-input" placeholder="Describe your data, ask questions, or type 'parse: [data]' to extract flows..."></textarea>
              </div>
              <div style="display:flex;gap:8px;align-items:center;margin-top:8px;">
                <input type="file" id="ai-image-input" accept="image/*" multiple style="display:none" onchange="handleMultiImageUpload(event)">
                <button class="add-row-btn" onclick="pasteFromClipboard()" title="Paste from clipboard">üìã Paste</button>
                <button class="add-row-btn" onclick="openSettingsModal()" title="AI Settings">‚öôÔ∏è Settings</button>
                <button class="ai-chat-btn" id="ai-send-btn" onclick="processAIChat()">üí¨ Send</button>
                <div class="ai-status" id="ai-status"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Status Bar -->
  <div class="status-bar studio-status-bar" id="status-bar">
    <span class="studio-status-icon">‚úì</span>
    <span class="studio-status-message" id="status-message">Ready - Add data to create your Sankey diagram</span>
  </div>
</div>

<!-- Node Settings Popup (Node appearance only) -->
<div class="node-popup-overlay" id="node-popup-overlay">
  <div class="node-popup">
    <div class="node-popup-header">
      <h3>‚¨ú Node Settings</h3>
      <button class="node-popup-close" onclick="closeNodePopup()">&times;</button>
    </div>
    <div class="node-popup-body">
      <div class="node-popup-section">
        <h4>Node Identity</h4>
        <div class="node-popup-row">
          <label>Name</label>
          <input type="text" id="popup-node-name" placeholder="Node name">
        </div>
      </div>
      
      <div class="node-popup-section">
        <h4>Appearance</h4>
        <div class="node-popup-row">
          <label>Fill Color</label>
          <div style="display:flex;gap:8px;align-items:center;flex:1;">
            <input type="color" id="popup-node-fill" value="#888888" onchange="syncNodeColorToHex('fill')">
            <input type="text" id="popup-node-fill-hex" placeholder="#RRGGBB" maxlength="7" style="width:80px;" oninput="syncNodeHexToColor('fill')">
          </div>
        </div>
        <div class="node-popup-row">
          <label>Recent Colors</label>
          <div id="recent-colors-container" style="display:flex;flex-wrap:wrap;gap:4px;flex:1;"></div>
        </div>
        <div class="node-popup-row">
          <label>Border Color</label>
          <div style="display:flex;gap:8px;align-items:center;flex:1;">
            <input type="color" id="popup-node-border" value="#666666" onchange="syncNodeColorToHex('border')">
            <input type="text" id="popup-node-border-hex" placeholder="#RRGGBB" maxlength="7" style="width:80px;" oninput="syncNodeHexToColor('border')">
          </div>
        </div>
        <div class="node-popup-row">
          <label>Fill Opacity %</label>
          <input type="number" id="popup-node-opacity" value="100" min="0" max="100" style="width:80px">
        </div>
        <div class="node-popup-row">
          <label>Border Opacity %</label>
          <div style="display:flex;gap:8px;align-items:center;flex:1;">
            <input type="range" id="popup-node-border-opacity" min="0" max="100" value="100" style="flex:1;" oninput="updateBorderOpacityDisplay()">
            <span id="popup-node-border-opacity-value" style="min-width:40px;text-align:right;">100%</span>
          </div>
        </div>
      </div>
      
      <div class="node-popup-section">
        <h4>Quick Actions</h4>
        <div class="node-popup-row">
          <button class="btn btn-secondary" style="flex:1" onclick="openLabelPopupFromNode()">üè∑Ô∏è Edit Label Settings</button>
        </div>
      </div>
    </div>
    <div class="node-popup-footer">
      <button class="btn btn-secondary" onclick="resetNodeToDefault()">Reset</button>
      <button class="btn btn-secondary" onclick="closeNodePopup()">Cancel</button>
      <button class="btn btn-primary" onclick="applyNodeCustomization()">Apply</button>
    </div>
  </div>
</div>

<!-- Label Settings Popup (Label appearance and position) -->
<div class="node-popup-overlay" id="label-popup-overlay">
  <div class="node-popup">
    <div class="node-popup-header">
      <h3>üè∑Ô∏è Label Settings</h3>
      <button class="node-popup-close" onclick="closeLabelPopup()">&times;</button>
    </div>
    <div class="node-popup-body">
      <div class="node-popup-section">
        <h4>Label Text</h4>
        <div class="node-popup-row">
          <label>Display Text</label>
          <textarea id="popup-label-text" placeholder="Custom label (use Enter for multi-line)" rows="3" style="width:100%;resize:vertical;font-family:inherit;"></textarea>
        </div>
        <div class="node-popup-row">
          <span style="font-size:11px;color:#888;">üí° Use Enter for line breaks. Type your complete label text including any values you want to display.</span>
        </div>
        <div class="node-popup-row">
          <label>For Node</label>
          <input type="text" id="popup-label-node-ref" readonly style="background:#f5f5f5;color:#666;">
        </div>
      </div>
      
      <div class="node-popup-section">
        <h4>Typography</h4>
        <div class="node-popup-row">
          <label>Font Size</label>
          <input type="number" id="popup-label-fontsize" value="16" min="8" max="72" style="width:80px">
          <span style="font-size:11px;color:#666;">px</span>
        </div>
        <div class="node-popup-row">
          <label>Text Color</label>
          <input type="color" id="popup-label-color" value="#000000">
        </div>
        <div class="node-popup-row">
          <label>Style</label>
          <div class="node-popup-alignment">
            <button type="button" onclick="toggleLabelBold()" id="label-bold" title="Bold">B</button>
            <button type="button" onclick="toggleLabelItalic()" id="label-italic" title="Italic" style="font-style:italic;">I</button>
          </div>
        </div>
        <div class="node-popup-row">
          <label>Alignment</label>
          <div class="node-popup-alignment">
            <button type="button" onclick="setLabelAlignment('left')" id="align-left">Left</button>
            <button type="button" onclick="setLabelAlignment('center')" id="align-center" class="active">Center</button>
            <button type="button" onclick="setLabelAlignment('right')" id="align-right">Right</button>
          </div>
        </div>
      </div>
      
      <div class="node-popup-section">
        <h4>Background Box</h4>
        <div class="node-popup-row">
          <label>Enable</label>
          <div class="node-popup-toggle">
            <input type="checkbox" id="popup-label-bg-enabled">
            <span style="font-size:11px;">Show background</span>
          </div>
        </div>
        <div class="node-popup-row">
          <label>BG Color</label>
          <input type="color" id="popup-label-bg" value="#ffffff">
        </div>
        <div class="node-popup-row">
          <label>BG Opacity</label>
          <div style="display:flex;gap:8px;align-items:center;flex:1;">
            <input type="range" id="popup-label-bg-opacity" min="0" max="100" value="95" style="flex:1;">
            <span id="popup-label-bg-opacity-value" style="min-width:40px;text-align:right;">95%</span>
          </div>
        </div>
      </div>
      
      <div class="node-popup-section">
        <h4>Text Margins (Padding)</h4>
        <div class="node-popup-row">
          <label>Top</label>
          <input type="number" id="popup-label-margin-top" value="0" min="0" max="100" style="width:60px">
          <label style="margin-left:10px;">Right</label>
          <input type="number" id="popup-label-margin-right" value="0" min="0" max="100" style="width:60px">
        </div>
        <div class="node-popup-row">
          <label>Bottom</label>
          <input type="number" id="popup-label-margin-bottom" value="0" min="0" max="100" style="width:60px">
          <label style="margin-left:10px;">Left</label>
          <input type="number" id="popup-label-margin-left" value="0" min="0" max="100" style="width:60px">
        </div>
        <div class="node-popup-row">
          <span style="font-size:11px;color:#888;">üí° Margins add padding around the label text</span>
        </div>
      </div>
      
      <div class="node-popup-section">
        <h4>Position</h4>
        <div class="node-popup-row">
          <label>X Offset</label>
          <input type="number" id="popup-label-x" value="0" style="width:80px">
          <span style="font-size:11px;color:#666;">px from default</span>
        </div>
        <div class="node-popup-row">
          <label>Y Offset</label>
          <input type="number" id="popup-label-y" value="0" style="width:80px">
          <span style="font-size:11px;color:#666;">px from default</span>
        </div>
        <div class="node-popup-row">
          <span style="font-size:11px;color:#888;">üí° Tip: Drag labels directly on the diagram to reposition them</span>
        </div>
      </div>
    </div>
    <div class="node-popup-footer">
      <button class="btn btn-secondary" onclick="resetLabelToDefault()">Reset</button>
      <button class="btn btn-secondary" onclick="closeLabelPopup()">Cancel</button>
      <button class="btn btn-primary" onclick="applyLabelCustomization()">Apply</button>
    </div>
  </div>
</div>

<!-- JSON Editor Modal -->
<div class="modal-overlay" id="json-editor-modal">
  <div class="modal json-editor-modal">
    <div class="modal-header">
      <h3>üìã JSON Data Editor</h3>
      <button class="modal-close" onclick="closeJSONEditor()">&times;</button>
    </div>
    <div class="modal-body">
      <div class="json-editor-actions">
        <button class="btn btn-secondary" onclick="copyJSONToClipboard()">üìã Copy to Clipboard</button>
        <button class="btn btn-secondary" onclick="pasteJSONFromClipboard()">üì• Paste from Clipboard</button>
        <button class="btn btn-secondary" onclick="formatJSON()">‚ú® Format</button>
      </div>
      <div class="form-group">
        <label>Diagram Data (JSON)</label>
        <textarea id="json-editor-textarea" class="json-editor-textarea" placeholder='{"flows": [{"from": "Source", "to": "Target", "amount": 100}]}'></textarea>
        <div class="hint">Edit the JSON directly or paste data from clipboard. AI can also modify this structure.</div>
      </div>
    </div>
    <div class="modal-footer">
      <button class="btn btn-secondary" onclick="closeJSONEditor()">Cancel</button>
      <button class="btn btn-primary" onclick="applyJSONData()">Apply Changes</button>
    </div>
  </div>
</div>

<!-- Export Options Modal -->
<div class="modal-overlay" id="export-modal">
  <div class="modal" style="width: 400px;">
    <div class="modal-header">
      <h3>üíæ Export Diagram</h3>
      <button class="modal-close" onclick="closeExportModal()">&times;</button>
    </div>
    <div class="modal-body">
      <div style="display: flex; flex-direction: column; gap: 12px;">
        <button class="btn btn-primary" onclick="exportAsPNG(2); closeExportModal();" style="padding: 16px; font-size: 14px;">
          üñºÔ∏è Export as PNG (Standard)
        </button>
        <button class="btn btn-secondary" onclick="exportAsPNG(4); closeExportModal();" style="padding: 16px; font-size: 14px;">
          üñºÔ∏è Export as PNG (Large 4x)
        </button>
        <button class="btn btn-secondary" onclick="exportAsSVG(); closeExportModal();" style="padding: 16px; font-size: 14px;">
          üìê Export as SVG (Vector)
        </button>
      </div>
      <div class="hint" style="margin-top: 16px; text-align: center;">
        PNG is best for sharing. SVG is best for editing in design tools.
      </div>
    </div>
  </div>
</div>

<!-- Settings Modal -->
<div class="modal-overlay" id="settings-modal">
  <div class="modal">
    <div class="modal-header">
      <h3>‚öôÔ∏è AI Settings</h3>
      <button class="modal-close" onclick="closeSettingsModal()">&times;</button>
    </div>
    <div class="modal-body">
      <div class="form-group">
        <label>Gemini API Key</label>
        <input type="password" id="gemini-api-key" placeholder="Enter your Gemini API key...">
        <div class="hint">Get your API key from <a href="https://aistudio.google.com/app/apikey" target="_blank">Google AI Studio</a></div>
      </div>
      <div class="form-group">
        <label>Model Name</label>
        <input type="text" id="ai-model" value="gemini-2.0-flash">
        <div class="hint">Common options: gemini-2.0-flash, gemini-1.5-pro, gemini-1.5-flash</div>
      </div>
      <div class="form-group">
        <label>System Prompt</label>
        <textarea id="ai-system-prompt" rows="8" style="font-size:11px;"></textarea>
        <div class="hint">Customize how the AI interprets your data.</div>
        <button type="button" class="btn btn-secondary" style="margin-top:8px;padding:6px 12px;font-size:11px;" onclick="resetSystemPrompt()">Reset to Default</button>
      </div>
    </div>
    <div class="modal-footer">
      <button class="btn btn-secondary" onclick="closeSettingsModal()">Cancel</button>
      <button class="btn btn-primary" onclick="saveSettings()">Save Settings</button>
    </div>
  </div>
</div>

<!-- Hidden inputs -->
<input type="file" id="load_file_input" accept=".txt,.skm" style="display:none" onchange="loadDiagramFile()">
<input type="file" id="csv_import" accept=".csv" style="display:none" onchange="importCSV(event)">

<!-- Hidden message areas required by sankeymatic.js -->
<div style="display:none">
  <div id="issue_messages"></div>
  <div id="imbalance_messages"></div>
  <div id="totals_area"></div>
  <div id="info_messages"></div>
  <div id="console_area"><div id="console_lines"></div></div>
  <span id="theme_a_guide"></span><span id="theme_a_label"></span>
  <span id="theme_b_guide"></span><span id="theme_b_label"></span>
  <span id="theme_c_guide"></span><span id="theme_c_label"></span>
  <span id="theme_d_guide"></span><span id="theme_d_label"></span>
  <button id="reset_all_moved_nodes"></button>
  <button id="reset_all_moved_labels"></button>
  <button id="save_as_png_1x" title=""></button>
  <button id="save_as_png_2x" title=""></button>
  <button id="save_as_png_4x" title=""></button>
  <button id="save_as_png_6x" title=""></button>
  <span id="scale_figures"></span>
  <div id="imbalances_area"></div>
</div>

<!-- Hidden textarea for DSL -->
<textarea id="flows_in" style="display:none">Wages [1500] Budget
Other [250] Budget
Budget [450] Taxes
Budget [420] Housing
Budget [400] Food
Budget [255] Transportation
Budget [160] Other Necessities
Budget [65] Savings</textarea>

<!-- Hidden form for compatibility with existing sankeymatic.js -->
<form id="skm_form" style="display:none">
  <input id="size_w" value="700"><input id="size_h" value="500">
  <input id="bg_color" value="#FFFFFF"><input type="checkbox" id="bg_transparent">
  <input id="margin_l" value="80"><input id="margin_r" value="80">
  <input id="margin_t" value="30"><input id="margin_b" value="30">
  <input id="node_w" value="12"><input id="node_h" value="50">
  <input id="node_spacing" value="75"><input id="node_border" value="0">
  <input id="node_opacity" value="1.0"><input id="node_color" value="#888888">
  <input id="flow_opacity" value="0.45"><input id="flow_curvature" value="0.5">
  <input id="flow_color" value="#999999">
  <input id="labelname_size" value="16"><input id="labels_color" value="#000000">
  <input type="checkbox" id="labelname_appears" checked>
  <input type="checkbox" id="labelvalue_appears" checked>
  <input type="checkbox" id="labels_comparisonline">
  <input id="labels_decimalplaces" value="2">
  <input id="value_prefix" value=""><input id="value_suffix" value="">
  <input id="value_format" value=",.">
  <input id="labels_hide" type="checkbox">
  <input id="labels_highlight" value="0.75">
  <input id="labels_googlefont_hidden" value="">
  <input id="labels_valuemode" value="absolute">
  <input id="labels_linespacing" value="0.15">
  <input id="labels_relativesize" value="100">
  <input id="labels_magnify" value="100">
  <input id="labelname_weight" value="400">
  <input id="labelvalue_fullprecision" type="checkbox" checked>
  <input id="labelvalue_weight" value="400">
  <input id="labelposition_autoalign" value="0">
  <input id="labelposition_breakpoint" value="9999">
  <input id="layout_justifyorigins" type="checkbox">
  <input id="layout_justifyends" type="checkbox">
  <input id="layout_reversegraph" type="checkbox">
  <input id="meta_mentionsankeymatic" type="checkbox">
  <input id="meta_listimbalances" type="checkbox" checked>
  <input id="internal_revealshadows" type="checkbox">
  <input type="radio" name="labels_fontface" id="labels_fontface_sans" value="sans-serif" checked>
  <input type="radio" name="labels_fontface" id="labels_fontface_serif" value="serif">
  <input type="radio" name="labels_fontface" id="labels_fontface_mono" value="monospace">
  <input type="radio" name="labelposition_scheme" id="labelposition_scheme_auto" value="auto" checked>
  <input type="radio" name="labelposition_scheme" id="labelposition_scheme_per_stage" value="per_stage">
  <input type="radio" name="labelposition_first" id="labelposition_first_before" value="before" checked>
  <input type="radio" name="labelposition_first" id="labelposition_first_after" value="after">
  <input type="radio" name="layout_attachincompletesto" id="layout_attach_leading" value="leading">
  <input type="radio" name="layout_attachincompletesto" id="layout_attach_nearest" value="nearest" checked>
  <input type="radio" name="layout_attachincompletesto" id="layout_attach_trailing" value="trailing">
  <input type="radio" name="labels_fontface" id="sans_serif" value="sans-serif" checked>
  <input type="radio" name="node_theme" id="theme_a_radio" value="a" checked>
  <input type="radio" name="node_theme" id="theme_b_radio" value="b">
  <input type="radio" name="node_theme" id="theme_c_radio" value="c">
  <input type="radio" name="node_theme" id="theme_d_radio" value="d">
  <input type="radio" name="node_theme" id="theme_none_radio" value="none">
  <input type="radio" name="flow_inheritfrom" id="flow_inherit_outside_in" value="outside-in" checked>
  <input type="radio" name="flow_inheritfrom" id="flow_inherit_from_source" value="source">
  <input type="radio" name="flow_inheritfrom" id="flow_inherit_from_target" value="target">
  <input type="radio" name="flow_inheritfrom" id="flow_inherit_none" value="none">
  <input type="radio" name="layout_order" id="layout_order_automatic" value="automatic" checked>
  <input type="radio" name="layout_order" id="layout_order_exact" value="exact">
  <input type="radio" name="labelvalue_position" id="labelvalue_below" value="below" checked>
  <input id="internal_iterations" value="25">
  <input id="themeoffset_a" value="6"><input id="themeoffset_b" value="0">
  <input id="themeoffset_c" value="0"><input id="themeoffset_d" value="0">
  <input id="labels_fontface" value="sans-serif">
  <input id="labels_googlefont" value="">
  <input type="radio" name="layout_attachincompletesto" id="layout_attachto_leading" value="leading">
  <input type="radio" name="layout_attachincompletesto" id="layout_attachto_trailing" value="trailing">
  <input type="radio" name="layout_attachincompletesto" id="layout_attachto_nearest" value="nearest" checked>
</form>

<script>
// ============ GLOBAL STATE ============
let currentZoom = 1.0;
let undoStack = [];
let lastSavedState = null;
const MAX_UNDO = 20;
let nodeColors = {};
let nodeCustomizations = {}; // Store per-node customizations
let labelPositions = {};
let currentEditingNodeName = null;
let uploadedImages = []; // Multi-image support

// ============ CUSTOM LAYOUT STATE ============
// Independent state management for nodes and labels
// Structure: customLayout["NodeName"] = { 
//   nodeX, nodeY, labelX, labelY, labelW, labelH,
//   labelColor, labelBg, labelBgEnabled, labelAlign, labelFontSize,
//   nodeColor, nodeBorder, nodeOpacity
// }
let customLayout = {};
let labelDragEnabled = true; // Global toggle for label dragging

// ============ DEFAULT SYSTEM PROMPT ============
const DEFAULT_SYSTEM_PROMPT = `You are a financial data parser for Sankey diagrams.
Parse the input and extract flows between nodes.

CRITICAL JSON FORMATTING RULES:
1. Return ONLY valid JSON - no markdown, no explanations before or after
2. Use this EXACT format: {"flows": [{"from": "Source", "to": "Target", "amount": 1000}]}
3. All amounts must be plain numbers (no quotes, no commas, no currency symbols)
4. Keep node names short and clean (no special characters)
5. Ensure the JSON is complete and properly closed with ]}

SANKEY DIAGRAM RULES:
- Each flow has: source (from), destination (to), and amount
- For income statements: Revenue flows to Gross Profit, Gross Profit flows to Operating Profit, etc.
- For balance sheets: Assets flow to categories, Liabilities flow to categories
- Amounts should be positive numbers
- Parse numbers: $100M = 100000000, $1.5B = 1500000000, 1,500 = 1500

RESPONSE FORMAT (return ONLY this, nothing else):
{"flows": [{"from": "Source Name", "to": "Destination Name", "amount": 1000}]}

For modifications:
{"action": "modify", "modifications": [{"node": "NodeName", "newAmount": 500}]}

For rebalancing:
{"action": "rebalance", "targetNode": "NodeName", "newTotal": 1000}

Example:
Input: "Revenue $100M, COGS $40M, Operating Expenses $30M"
Output: {"flows": [{"from": "Revenue", "to": "Gross Profit", "amount": 60000000}, {"from": "Revenue", "to": "COGS", "amount": 40000000}, {"from": "Gross Profit", "to": "Operating Profit", "amount": 30000000}]}`;

// ============ UTILITY FUNCTIONS ============
function escapeHtml(str) {
  if (!str) return '';
  return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

function updateAIStatus(msg, type) {
  const el = document.getElementById('ai-status');
  el.textContent = msg;
  el.className = 'ai-status ' + (type || '');
}

function addToChatHistory(role, message) {
  const history = document.getElementById('ai-chat-history');
  const div = document.createElement('div');
  div.style.cssText = `padding:6px 8px;margin-bottom:4px;border-radius:4px;background:${role === 'user' ? '#e3f2fd' : '#f5f5f5'};`;
  div.innerHTML = `<strong>${role === 'user' ? 'üë§' : 'ü§ñ'}</strong> ${escapeHtml(message.substring(0, 300))}${message.length > 300 ? '...' : ''}`;
  history.appendChild(div);
  history.scrollTop = history.scrollHeight;
}

// ============ DATA TABLE ============
function initializeDataTable() {
  const tbody = document.getElementById('data-table-body');
  const flowsText = document.getElementById('flows_in').value;
  const lines = flowsText.split('\n').filter(line => {
    const t = line.trim();
    return t && !t.startsWith('//') && !t.startsWith(':') && !t.startsWith("'");
  });
  
  tbody.innerHTML = '';
  lines.forEach(line => {
    const match = line.match(/^(.+?)\s*\[([^\]]+)\]\s*(.+?)(?:\s+(#[a-f0-9]{3,6}))?$/i);
    if (match) {
      addDataRowWithValues(match[1].trim(), match[3].trim(), match[2].trim(), '');
    }
  });
  
  if (tbody.children.length === 0) {
    addDataRowWithValues('', '', '', '');
  }
}

function addDataRow() {
  saveStateForUndo();
  const count = parseInt(document.getElementById('add-row-count').value) || 1;
  for (let i = 0; i < count; i++) {
    addDataRowWithValues('', '', '', '');
  }
}

function addDataRowWithValues(from, to, amount, comparison) {
  const tbody = document.getElementById('data-table-body');
  const row = document.createElement('tr');
  row.innerHTML = `
    <td><input type="text" value="${escapeHtml(from)}" onfocus="saveStateForUndo()" onchange="updateDiagramFromTableNoUndo()" placeholder="Source"></td>
    <td><input type="text" value="${escapeHtml(to)}" onfocus="saveStateForUndo()" onchange="updateDiagramFromTableNoUndo()" placeholder="Target"></td>
    <td><input type="text" value="${escapeHtml(amount)}" onfocus="saveStateForUndo()" onchange="updateDiagramFromTableNoUndo()" placeholder="0"></td>
    <td><input type="text" value="${escapeHtml(comparison)}" onfocus="saveStateForUndo()" onchange="updateDiagramFromTableNoUndo()" placeholder="Prev"></td>
    <td style="display:flex;gap:4px;">
      <button class="delete-btn" onclick="saveStateForUndo(); deleteDataRow(this)" title="Delete">√ó</button>
    </td>
  `;
  tbody.appendChild(row);
}

function deleteDataRow(btn) {
  btn.closest('tr').remove();
  updateDiagramFromTableNoUndo();
}

function clearAllRows() {
  if (confirm('Clear all data rows?')) {
    saveStateForUndo();
    document.getElementById('data-table-body').innerHTML = '';
    addDataRowWithValues('', '', '', '');
    updateDiagramFromTableNoUndo();
  }
}
</script>

<script>
// ============ DIAGRAM RENDERING ============
function updateDiagramFromTable() {
  saveStateForUndo();
  updateDiagramFromTableNoUndo();
}

function updateDiagramFromTableNoUndo() {
  const tbody = document.getElementById('data-table-body');
  const rows = tbody.querySelectorAll('tr');
  let dsl = '';
  let validRows = 0;
  
  // Add node color definitions at the top
  for (const [nodeName, color] of Object.entries(nodeColors)) {
    dsl += `:${nodeName} ${color}\n`;
  }
  if (Object.keys(nodeColors).length > 0) dsl += '\n';
  
  rows.forEach(row => {
    const inputs = row.querySelectorAll('input');
    const from = inputs[0].value.trim();
    const to = inputs[1].value.trim();
    const amount = inputs[2].value.trim();
    
    if (from && to && amount) {
      dsl += `${from} [${amount}] ${to}\n`;
      validRows++;
    }
  });
  
  document.getElementById('flows_in').value = dsl;
  renderDiagram();
  updateStatus(validRows);
  saveProgressToLocal();
}

function renderDiagram() {
  syncOptionsToForm();
  const processFn = window.process_sankey || (typeof process_sankey !== 'undefined' ? process_sankey : null);
  
  if (processFn) {
    try {
      processFn();
      setTimeout(() => {
        setupNodeClickHandlers();
        applyLabelPositions();
      }, 100);
    } catch (e) {
      console.error('Render error:', e);
      document.getElementById('status-message').textContent = 'Error: ' + e.message;
      document.getElementById('status-bar').className = 'status-bar error';
    }
  } else {
    setTimeout(renderDiagram, 200);
  }
}

function renderDiagramOnly() {
  syncOptionsToForm();
  const processFn = window.process_sankey || (typeof process_sankey !== 'undefined' ? process_sankey : null);
  if (processFn) {
    try { processFn(); } catch (e) { console.error('Render error:', e); }
  }
}

// ============ OPTIONS SYNC ============
function syncOptionsToForm() {
  const el = id => document.getElementById(id);
  
  if (el('opt_labelname_appears')) el('labelname_appears').checked = el('opt_labelname_appears').checked;
  if (el('opt_labelvalue_appears')) el('labelvalue_appears').checked = el('opt_labelvalue_appears').checked;
  if (el('opt_labels_comparisonline')) el('labels_comparisonline').checked = el('opt_labels_comparisonline').checked;
  if (el('opt_labelname_size')) el('labelname_size').value = el('opt_labelname_size').value;
  if (el('opt_labels_color')) el('labels_color').value = el('opt_labels_color').value;
  if (el('opt_labels_decimalplaces')) el('labels_decimalplaces').value = el('opt_labels_decimalplaces').value;
  if (el('opt_value_prefix')) el('value_prefix').value = el('opt_value_prefix').value;
  if (el('opt_value_suffix')) el('value_suffix').value = el('opt_value_suffix').value;
  
  if (el('opt_labels_fontface')) {
    const fontValue = el('opt_labels_fontface').value;
    const radioId = 'labels_fontface_' + (fontValue === 'sans-serif' ? 'sans' : fontValue === 'serif' ? 'serif' : 'mono');
    const radio = el(radioId);
    if (radio) radio.checked = true;
  }
  if (el('opt_labels_googlefont')) {
    const googleFont = el('opt_labels_googlefont').value;
    el('labels_googlefont').value = googleFont;
    if (googleFont) loadGoogleFont(googleFont);
  }
  
  if (el('opt_node_w')) el('node_w').value = el('opt_node_w').value;
  if (el('opt_node_h')) el('node_h').value = el('opt_node_h').value;
  if (el('opt_node_spacing')) el('node_spacing').value = el('opt_node_spacing').value;
  if (el('opt_node_border')) el('node_border').value = el('opt_node_border').value;
  if (el('opt_node_opacity')) el('node_opacity').value = el('opt_node_opacity').value / 100;
  if (el('opt_node_color')) el('node_color').value = el('opt_node_color').value;
  if (el('opt_node_theme')) {
    const theme = el('opt_node_theme').value;
    const radioId = 'theme_' + theme + '_radio';
    const radio = el(radioId);
    if (radio) radio.checked = true;
  }
  
  if (el('opt_flow_opacity')) el('flow_opacity').value = el('opt_flow_opacity').value / 100;
  if (el('opt_flow_curvature')) el('flow_curvature').value = el('opt_flow_curvature').value / 100;
  if (el('opt_flow_color')) el('flow_color').value = el('opt_flow_color').value;
  if (el('opt_flow_outside_in')?.checked) el('flow_inherit_outside_in').checked = true;
  if (el('opt_flow_source')?.checked) el('flow_inherit_from_source').checked = true;
  if (el('opt_flow_target')?.checked) el('flow_inherit_from_target').checked = true;
  if (el('opt_flow_single')?.checked) el('flow_inherit_none').checked = true;
  
  if (el('opt_size_w')) el('size_w').value = el('opt_size_w').value;
  if (el('opt_size_h')) el('size_h').value = el('opt_size_h').value;
  if (el('opt_margin_l')) el('margin_l').value = el('opt_margin_l').value;
  if (el('opt_margin_r')) el('margin_r').value = el('opt_margin_r').value;
  if (el('opt_margin_t')) el('margin_t').value = el('opt_margin_t').value;
  if (el('opt_margin_b')) el('margin_b').value = el('opt_margin_b').value;
  if (el('opt_bg_color')) el('bg_color').value = el('opt_bg_color').value;
  if (el('opt_bg_transparent')) el('bg_transparent').checked = el('opt_bg_transparent').checked;
  if (el('opt_layout_automatic')?.checked) el('layout_order_automatic').checked = true;
  if (el('opt_layout_exact')?.checked) el('layout_order_exact').checked = true;
  
  const svg = document.getElementById('sankey_svg');
  if (svg && el('opt_size_w') && el('opt_size_h')) {
    svg.setAttribute('width', el('opt_size_w').value);
    svg.setAttribute('height', el('opt_size_h').value);
  }
}

function updateOption() { renderDiagram(); }
function updateFontOption() {
  const fontSelect = document.getElementById('opt_labels_fontface');
  const fontValue = fontSelect.value;
  const radioId = 'labels_fontface_' + (fontValue === 'sans-serif' ? 'sans' : fontValue === 'serif' ? 'serif' : 'mono');
  const radio = document.getElementById(radioId);
  if (radio) radio.checked = true;
  renderDiagram();
}

function loadGoogleFont(fontName) {
  if (!fontName) return;
  const fontId = 'google-font-' + fontName.replace(/\s+/g, '-');
  if (document.getElementById(fontId)) return;
  const link = document.createElement('link');
  link.id = fontId;
  link.rel = 'stylesheet';
  link.href = `https://fonts.googleapis.com/css2?family=${encodeURIComponent(fontName)}:wght@400;500;600;700&display=swap`;
  document.head.appendChild(link);
}
</script>

<script>
// ============ NODE CUSTOMIZATION POPUP ============
function setupNodeClickHandlers() {
  const svg = document.getElementById('sankey_svg');
  if (!svg) return;
  
  // Add click handlers to nodes (rects) - for node customization
  svg.querySelectorAll('rect').forEach(rect => {
    // Skip label background rects and drag handles
    if (rect.classList.contains('custom-label-bg') || rect.classList.contains('drag-handle')) return;
    
    rect.style.cursor = 'pointer';
    rect.onclick = function(e) {
      e.stopPropagation();
      const title = this.querySelector('title');
      if (title) {
        const nodeName = title.textContent.split(':')[0].trim();
        openNodePopup(nodeName, this);
      }
    };
  });
  
  // Setup independent label dragging using D3
  setupIndependentLabelDragging();
}

// ============ INDEPENDENT LABEL DRAGGING SYSTEM ============
function setupIndependentLabelDragging() {
  const svg = d3.select('#sankey_svg');
  if (!svg.node()) return;
  
  // Find all label groups (created by sankeymatic.js)
  const labelGroups = svg.selectAll('g[id$="_group"]');
  
  labelGroups.each(function() {
    const group = d3.select(this);
    const groupId = group.attr('id');
    const textEl = group.select('text');
    if (!textEl.node()) return;
    
    // Extract node name from data-label-for attribute (ALWAYS use this - it's the node identity)
    // This is set by sankeymatic.js and represents the actual node name in the data
    // The group ID format is "label0_group", "label1_group" etc. - NOT the node name!
    let nodeName = group.attr('data-label-for');
    
    // IMPORTANT: Do NOT fall back to group ID or text content
    // The data-label-for attribute is the ONLY reliable source of node identity
    // If it's not set, skip this label
    if (!nodeName) {
      console.warn('Could not determine node name for label group (missing data-label-for):', groupId);
      return;
    }
    
    // Store original position if not already stored
    if (!customLayout[nodeName]) {
      const transform = group.attr('transform') || '';
      const match = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
      if (match) {
        customLayout[nodeName] = {
          originalX: parseFloat(match[1]),
          originalY: parseFloat(match[2]),
          labelX: parseFloat(match[1]),
          labelY: parseFloat(match[2]),
          labelW: 0,
          labelH: 0
        };
      }
    }
    
    // Set cursor style
    group.style('cursor', 'move');
    
    // Remove any existing drag behavior first
    group.on('.drag', null);
    
    // Apply custom D3 drag behavior
    const dragBehavior = d3.drag()
      .on('start', function(event) {
        // Store starting position
        const transform = d3.select(this).attr('transform') || '';
        const match = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
        if (match) {
          event.subject.startX = parseFloat(match[1]);
          event.subject.startY = parseFloat(match[2]);
        } else {
          event.subject.startX = 0;
          event.subject.startY = 0;
        }
        d3.select(this).raise().classed('dragging', true);
      })
      .on('drag', function(event) {
        // Calculate new position
        const newX = event.subject.startX + event.dx;
        const newY = event.subject.startY + event.dy;
        
        // Update transform
        d3.select(this).attr('transform', `translate(${newX}, ${newY})`);
        
        // Update stored position
        event.subject.startX = newX;
        event.subject.startY = newY;
      })
      .on('end', function(event) {
        d3.select(this).classed('dragging', false);
        
        // Get final position
        const transform = d3.select(this).attr('transform') || '';
        const match = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
        if (match) {
          const finalX = parseFloat(match[1]);
          const finalY = parseFloat(match[2]);
          
          // Store in customLayout
          if (!customLayout[nodeName]) {
            customLayout[nodeName] = {};
          }
          customLayout[nodeName].labelX = finalX;
          customLayout[nodeName].labelY = finalY;
          
          // Also store in sankeymatic's rememberedLabelMoves for persistence
          if (window.rememberedLabelMoves && customLayout[nodeName].originalX !== undefined) {
            const offsetX = finalX - customLayout[nodeName].originalX;
            const offsetY = finalY - customLayout[nodeName].originalY;
            window.rememberedLabelMoves.set(nodeName, [offsetX, offsetY]);
          }
          
          // Update nodeCustomizations for popup sync
          if (!nodeCustomizations[nodeName]) {
            nodeCustomizations[nodeName] = {};
          }
          nodeCustomizations[nodeName].labelX = finalX - (customLayout[nodeName].originalX || 0);
          nodeCustomizations[nodeName].labelY = finalY - (customLayout[nodeName].originalY || 0);
          
          saveProgressToLocal();
        }
      });
    
    group.call(dragBehavior);
    
    // Double-click to open popup
    group.on('dblclick', function(event) {
      event.stopPropagation();
      event.preventDefault();
      openNodePopup(nodeName, textEl.node());
    });
  });
}

// Reset a specific label to its default position
function resetLabel(nodeName) {
  if (customLayout[nodeName] && customLayout[nodeName].originalX !== undefined) {
    customLayout[nodeName].labelX = customLayout[nodeName].originalX;
    customLayout[nodeName].labelY = customLayout[nodeName].originalY;
    
    // Clear from rememberedLabelMoves
    if (window.rememberedLabelMoves) {
      window.rememberedLabelMoves.delete(nodeName);
    }
    
    // Clear from nodeCustomizations
    if (nodeCustomizations[nodeName]) {
      nodeCustomizations[nodeName].labelX = 0;
      nodeCustomizations[nodeName].labelY = 0;
    }
    
    // Re-render to apply
    renderDiagram();
  }
}

// Reset all labels to default positions
function resetAllLabelsCustom() {
  Object.keys(customLayout).forEach(nodeName => {
    if (customLayout[nodeName].originalX !== undefined) {
      customLayout[nodeName].labelX = customLayout[nodeName].originalX;
      customLayout[nodeName].labelY = customLayout[nodeName].originalY;
    }
  });
  
  // Clear all remembered label moves
  if (window.rememberedLabelMoves) {
    window.rememberedLabelMoves.clear();
  }
  
  // Clear label positions from nodeCustomizations
  Object.keys(nodeCustomizations).forEach(nodeName => {
    if (nodeCustomizations[nodeName]) {
      nodeCustomizations[nodeName].labelX = 0;
      nodeCustomizations[nodeName].labelY = 0;
    }
  });
  
  renderDiagram();
}

// Track which node/label is being edited
let currentEditingLabelName = null;

// Sync color picker to hex input
function syncNodeColorToHex(type) {
  const colorInput = document.getElementById('popup-node-' + type);
  const hexInput = document.getElementById('popup-node-' + type + '-hex');
  if (colorInput && hexInput) {
    hexInput.value = colorInput.value;
  }
}

// Sync hex input to color picker with validation
function syncNodeHexToColor(type) {
  const colorInput = document.getElementById('popup-node-' + type);
  const hexInput = document.getElementById('popup-node-' + type + '-hex');
  if (colorInput && hexInput) {
    const hex = hexInput.value;
    
    // Use ValidationUtils if available
    if (typeof ValidationUtils !== 'undefined') {
      const result = ValidationUtils.validateHexColor(hex);
      if (result.isValid) {
        colorInput.value = result.normalized;
        ValidationUtils.clearError(hexInput);
      } else {
        ValidationUtils.showError(hexInput, result.error);
      }
    } else {
      // Fallback to basic validation
      if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
        colorInput.value = hex;
      }
    }
  }
}

// Update border opacity display
function updateBorderOpacityDisplay() {
  const slider = document.getElementById('popup-node-border-opacity');
  const display = document.getElementById('popup-node-border-opacity-value');
  if (slider && display) {
    display.textContent = slider.value + '%';
  }
}

// Apply recent color to fill
function applyRecentColorToFill(color) {
  const colorInput = document.getElementById('popup-node-fill');
  const hexInput = document.getElementById('popup-node-fill-hex');
  if (colorInput) colorInput.value = color;
  if (hexInput) hexInput.value = color;
}

function openNodePopup(nodeName, element) {
  currentEditingNodeName = nodeName;
  const popup = document.getElementById('node-popup-overlay');
  
  // Load existing customizations or defaults
  const custom = nodeCustomizations[nodeName] || {};
  
  // Get current node color from SVG if not stored
  let currentFillColor = custom.fillColor || nodeColors[nodeName] || '#888888';
  const svg = document.getElementById('sankey_svg');
  if (svg && !custom.fillColor) {
    svg.querySelectorAll('rect').forEach(rect => {
      const title = rect.querySelector('title');
      if (title && title.textContent.startsWith(nodeName + ':')) {
        currentFillColor = rect.getAttribute('fill') || currentFillColor;
      }
    });
  }
  
  document.getElementById('popup-node-name').value = nodeName;
  document.getElementById('popup-node-fill').value = currentFillColor;
  document.getElementById('popup-node-fill-hex').value = currentFillColor;
  document.getElementById('popup-node-border').value = custom.borderColor || '#666666';
  document.getElementById('popup-node-border-hex').value = custom.borderColor || '#666666';
  document.getElementById('popup-node-opacity').value = custom.opacity || 100;
  document.getElementById('popup-node-border-opacity').value = custom.borderOpacity || 100;
  updateBorderOpacityDisplay();
  
  // Render recent colors
  const recentContainer = document.getElementById('recent-colors-container');
  if (typeof RecentColorsManager !== 'undefined' && recentContainer) {
    RecentColorsManager.renderRecentColors(recentContainer, applyRecentColorToFill);
  }
  
  popup.classList.add('active');
}

function closeNodePopup() {
  document.getElementById('node-popup-overlay').classList.remove('active');
  currentEditingNodeName = null;
}

// Open label popup from node popup
function openLabelPopupFromNode() {
  const nodeName = currentEditingNodeName;
  closeNodePopup();
  if (nodeName) {
    openLabelPopup(nodeName);
  }
}

// Open label popup directly (for clicking on labels)
function openLabelPopup(nodeName, element) {
  currentEditingLabelName = nodeName;
  const popup = document.getElementById('label-popup-overlay');
  
  // Load existing customizations or defaults
  const custom = nodeCustomizations[nodeName] || {};
  
  // Get current label position from sankeymatic.js's rememberedLabelMoves
  let currentLabelX = custom.labelX || 0;
  let currentLabelY = custom.labelY || 0;
  
  // Check if there's a remembered label move from dragging
  if (window.rememberedLabelMoves && window.rememberedLabelMoves.has(nodeName)) {
    const [offsetX, offsetY] = window.rememberedLabelMoves.get(nodeName);
    currentLabelX = Math.round(offsetX);
    currentLabelY = Math.round(offsetY);
  }
  
  document.getElementById('popup-label-node-ref').value = nodeName;
  document.getElementById('popup-label-text').value = custom.labelText !== undefined ? custom.labelText : nodeName;
  document.getElementById('popup-label-fontsize').value = custom.labelFontSize || 16;
  document.getElementById('popup-label-bg').value = custom.labelBg || '#ffffff';
  document.getElementById('popup-label-bg-enabled').checked = custom.labelBgEnabled === true;
  document.getElementById('popup-label-color').value = custom.labelColor || '#000000';
  
  // Load background opacity
  const bgOpacity = custom.labelBgOpacity !== undefined ? custom.labelBgOpacity : 95;
  document.getElementById('popup-label-bg-opacity').value = bgOpacity;
  document.getElementById('popup-label-bg-opacity-value').textContent = bgOpacity + '%';
  
  // Load text margins
  document.getElementById('popup-label-margin-top').value = custom.labelMarginTop || 0;
  document.getElementById('popup-label-margin-right').value = custom.labelMarginRight || 0;
  document.getElementById('popup-label-margin-bottom').value = custom.labelMarginBottom || 0;
  document.getElementById('popup-label-margin-left').value = custom.labelMarginLeft || 0;
  
  document.getElementById('popup-label-x').value = Math.round(currentLabelX);
  document.getElementById('popup-label-y').value = Math.round(currentLabelY);
  
  setLabelAlignment(custom.labelAlign || 'center');
  
  // Load bold/italic state
  setLabelBold(custom.labelBold === true);
  setLabelItalic(custom.labelItalic === true);
  
  popup.classList.add('active');
}

function closeLabelPopup() {
  document.getElementById('label-popup-overlay').classList.remove('active');
  currentEditingLabelName = null;
}

// Bold/Italic toggle functions
function toggleLabelBold() {
  const btn = document.getElementById('label-bold');
  btn.classList.toggle('active');
}

function toggleLabelItalic() {
  const btn = document.getElementById('label-italic');
  btn.classList.toggle('active');
}

function setLabelBold(isBold) {
  const btn = document.getElementById('label-bold');
  if (btn) btn.classList.toggle('active', isBold);
}

function setLabelItalic(isItalic) {
  const btn = document.getElementById('label-italic');
  if (btn) btn.classList.toggle('active', isItalic);
}

function getLabelBold() {
  return document.getElementById('label-bold')?.classList.contains('active') || false;
}

function getLabelItalic() {
  return document.getElementById('label-italic')?.classList.contains('active') || false;
}

function setLabelAlignment(align) {
  ['left', 'center', 'right'].forEach(a => {
    document.getElementById('align-' + a).classList.toggle('active', a === align);
  });
}

function getLabelAlignment() {
  if (document.getElementById('align-left').classList.contains('active')) return 'left';
  if (document.getElementById('align-right').classList.contains('active')) return 'right';
  return 'center';
}

function applyNodeCustomization() {
  if (!currentEditingNodeName) return;
  
  const nodeName = currentEditingNodeName;
  const newName = document.getElementById('popup-node-name').value.trim();
  
  // Get input elements for validation error display
  const fillHexInput = document.getElementById('popup-node-fill-hex');
  const borderHexInput = document.getElementById('popup-node-border-hex');
  const opacityInput = document.getElementById('popup-node-opacity');
  const borderOpacityInput = document.getElementById('popup-node-border-opacity');
  
  // Clear previous errors
  if (typeof ValidationUtils !== 'undefined') {
    ValidationUtils.clearError(fillHexInput);
    ValidationUtils.clearError(borderHexInput);
    ValidationUtils.clearError(opacityInput);
  }
  
  // Get existing customizations to preserve label settings
  const existingCustom = nodeCustomizations[nodeName] || {};
  
  // Collect raw values
  const rawSettings = {
    fillColor: document.getElementById('popup-node-fill').value,
    borderColor: document.getElementById('popup-node-border').value,
    opacity: document.getElementById('popup-node-opacity').value,
    borderOpacity: document.getElementById('popup-node-border-opacity').value
  };
  
  // Validate and clamp values using ValidationUtils
  let validatedSettings = rawSettings;
  if (typeof ValidationUtils !== 'undefined') {
    const result = ValidationUtils.validateNodeSettings(rawSettings);
    validatedSettings = result.validated;
    
    // Show errors if any values were adjusted
    if (result.errors.length > 0) {
      result.errors.forEach(error => {
        if (error.includes('Fill color')) ValidationUtils.showError(fillHexInput, error);
        if (error.includes('Border color')) ValidationUtils.showError(borderHexInput, error);
        if (error.includes('Opacity')) ValidationUtils.showError(opacityInput, error);
      });
    }
  }
  
  // Store node-only customizations (preserve existing label settings)
  const custom = {
    ...existingCustom,
    fillColor: validatedSettings.fillColor || rawSettings.fillColor,
    borderColor: validatedSettings.borderColor || rawSettings.borderColor,
    opacity: validatedSettings.opacity !== undefined ? validatedSettings.opacity : parseInt(rawSettings.opacity),
    borderOpacity: validatedSettings.borderOpacity !== undefined ? validatedSettings.borderOpacity : parseInt(rawSettings.borderOpacity)
  };
  
  nodeCustomizations[nodeName] = custom;
  nodeColors[nodeName] = custom.fillColor;
  
  // Add fill color to recent colors
  if (typeof RecentColorsManager !== 'undefined') {
    RecentColorsManager.addColor(custom.fillColor);
  }
  
  // Apply changes directly to SVG elements
  applyNodeCustomizationToSVG(nodeName, custom);
  
  // If name changed, update table and migrate customizations
  if (newName && newName !== nodeName) {
    const tbody = document.getElementById('data-table-body');
    tbody.querySelectorAll('tr').forEach(row => {
      const inputs = row.querySelectorAll('input');
      if (inputs[0].value === nodeName) inputs[0].value = newName;
      if (inputs[1].value === nodeName) inputs[1].value = newName;
    });
    
    // Migrate all customization data to new name
    nodeColors[newName] = nodeColors[nodeName];
    delete nodeColors[nodeName];
    nodeCustomizations[newName] = nodeCustomizations[nodeName];
    delete nodeCustomizations[nodeName];
    customLayout[newName] = customLayout[nodeName];
    delete customLayout[nodeName];
    
    if (window.rememberedLabelMoves && window.rememberedLabelMoves.has(nodeName)) {
      const move = window.rememberedLabelMoves.get(nodeName);
      window.rememberedLabelMoves.delete(nodeName);
      window.rememberedLabelMoves.set(newName, move);
    }
    
    updateDiagramFromTableNoUndo();
  }
  
  closeNodePopup();
  saveProgressToLocal();
}

// Apply label customization from the label popup
function applyLabelCustomization() {
  if (!currentEditingLabelName) return;
  
  const nodeName = currentEditingLabelName;
  
  // Get input elements for validation error display
  const fontSizeInput = document.getElementById('popup-label-fontsize');
  const marginTopInput = document.getElementById('popup-label-margin-top');
  const marginRightInput = document.getElementById('popup-label-margin-right');
  const marginBottomInput = document.getElementById('popup-label-margin-bottom');
  const marginLeftInput = document.getElementById('popup-label-margin-left');
  const labelXInput = document.getElementById('popup-label-x');
  const labelYInput = document.getElementById('popup-label-y');
  
  // Clear previous errors
  if (typeof ValidationUtils !== 'undefined') {
    ValidationUtils.clearError(fontSizeInput);
    ValidationUtils.clearError(marginTopInput);
    ValidationUtils.clearError(marginRightInput);
    ValidationUtils.clearError(marginBottomInput);
    ValidationUtils.clearError(marginLeftInput);
    ValidationUtils.clearError(labelXInput);
    ValidationUtils.clearError(labelYInput);
  }
  
  // Get existing customizations to preserve node settings
  const existingCustom = nodeCustomizations[nodeName] || {};
  
  // Collect raw values
  const rawSettings = {
    labelText: document.getElementById('popup-label-text').value,
    labelBg: document.getElementById('popup-label-bg').value,
    labelBgEnabled: document.getElementById('popup-label-bg-enabled').checked,
    labelBgOpacity: parseInt(document.getElementById('popup-label-bg-opacity').value) || 95,
    labelColor: document.getElementById('popup-label-color').value,
    labelAlign: getLabelAlignment(),
    labelBold: getLabelBold(),
    labelItalic: getLabelItalic(),
    labelMarginTop: document.getElementById('popup-label-margin-top').value,
    labelMarginRight: document.getElementById('popup-label-margin-right').value,
    labelMarginBottom: document.getElementById('popup-label-margin-bottom').value,
    labelMarginLeft: document.getElementById('popup-label-margin-left').value,
    labelX: document.getElementById('popup-label-x').value,
    labelY: document.getElementById('popup-label-y').value,
    labelFontSize: document.getElementById('popup-label-fontsize')?.value
  };
  
  // Validate and clamp values using ValidationUtils
  let validatedSettings = rawSettings;
  if (typeof ValidationUtils !== 'undefined') {
    const result = ValidationUtils.validateLabelSettings(rawSettings);
    validatedSettings = result.validated;
    
    // Show errors if any values were adjusted
    if (result.errors.length > 0) {
      result.errors.forEach(error => {
        if (error.includes('Font size')) ValidationUtils.showError(fontSizeInput, error);
        if (error.includes('labelMarginTop')) ValidationUtils.showError(marginTopInput, error);
        if (error.includes('labelMarginRight')) ValidationUtils.showError(marginRightInput, error);
        if (error.includes('labelMarginBottom')) ValidationUtils.showError(marginBottomInput, error);
        if (error.includes('labelMarginLeft')) ValidationUtils.showError(marginLeftInput, error);
        if (error.includes('X offset')) ValidationUtils.showError(labelXInput, error);
        if (error.includes('Y offset')) ValidationUtils.showError(labelYInput, error);
      });
    }
  }
  
  // Store label-only customizations (preserve existing node settings)
  const custom = {
    ...existingCustom,
    labelText: validatedSettings.labelText || rawSettings.labelText || nodeName,
    labelBg: rawSettings.labelBg,
    labelBgEnabled: rawSettings.labelBgEnabled,
    labelBgOpacity: rawSettings.labelBgOpacity,
    labelColor: validatedSettings.labelColor || rawSettings.labelColor,
    labelAlign: rawSettings.labelAlign,
    labelBold: rawSettings.labelBold,
    labelItalic: rawSettings.labelItalic,
    labelMarginTop: validatedSettings.labelMarginTop !== undefined ? validatedSettings.labelMarginTop : (parseInt(rawSettings.labelMarginTop) || 0),
    labelMarginRight: validatedSettings.labelMarginRight !== undefined ? validatedSettings.labelMarginRight : (parseInt(rawSettings.labelMarginRight) || 0),
    labelMarginBottom: validatedSettings.labelMarginBottom !== undefined ? validatedSettings.labelMarginBottom : (parseInt(rawSettings.labelMarginBottom) || 0),
    labelMarginLeft: validatedSettings.labelMarginLeft !== undefined ? validatedSettings.labelMarginLeft : (parseInt(rawSettings.labelMarginLeft) || 0),
    labelX: validatedSettings.labelX !== undefined ? validatedSettings.labelX : (parseInt(rawSettings.labelX) || 0),
    labelY: validatedSettings.labelY !== undefined ? validatedSettings.labelY : (parseInt(rawSettings.labelY) || 0),
    labelFontSize: validatedSettings.labelFontSize !== undefined ? validatedSettings.labelFontSize : (parseInt(rawSettings.labelFontSize) || 16)
  };
  
  nodeCustomizations[nodeName] = custom;
  
  // Update rememberedLabelMoves for sankeymatic.js persistence
  if (window.rememberedLabelMoves) {
    if (custom.labelX !== 0 || custom.labelY !== 0) {
      window.rememberedLabelMoves.set(nodeName, [custom.labelX, custom.labelY]);
    } else {
      window.rememberedLabelMoves.delete(nodeName);
    }
  }
  
  // Apply changes directly to SVG elements
  applyLabelCustomizationToSVG(nodeName, custom);
  
  closeLabelPopup();
  saveProgressToLocal();
}

// Reset label to default position and settings
function resetLabelPosition(nodeName) {
  // Clear label customizations but preserve node settings
  if (nodeCustomizations[nodeName]) {
    const nodeSettings = {
      fillColor: nodeCustomizations[nodeName].fillColor,
      borderColor: nodeCustomizations[nodeName].borderColor,
      opacity: nodeCustomizations[nodeName].opacity
    };
    nodeCustomizations[nodeName] = nodeSettings;
  }
  
  // Clear from rememberedLabelMoves
  if (window.rememberedLabelMoves) {
    window.rememberedLabelMoves.delete(nodeName);
  }
  
  // Clear customLayout label position
  if (customLayout[nodeName]) {
    delete customLayout[nodeName].originalX;
    delete customLayout[nodeName].originalY;
  }
  
  // Re-render to apply changes
  if (typeof renderDiagram === 'function') {
    renderDiagram();
  } else if (typeof process_sankey === 'function') {
    process_sankey();
  } else if (window.process_sankey) {
    window.process_sankey();
  }
  
  saveProgressToLocal();
}

// Reset label to default
function resetLabelToDefault() {
  if (!currentEditingLabelName) return;
  resetLabelPosition(currentEditingLabelName);
  closeLabelPopup();
}

// Apply node-only customization to SVG
function applyNodeCustomizationToSVG(nodeName, custom) {
  const svg = document.getElementById('sankey_svg');
  if (!svg) return;
  
  // Find and update the node rectangle
  svg.querySelectorAll('rect').forEach(rect => {
    const title = rect.querySelector('title');
    if (title && title.textContent.startsWith(nodeName + ':')) {
      rect.setAttribute('fill', custom.fillColor);
      rect.setAttribute('stroke', custom.borderColor);
      rect.setAttribute('stroke-width', '1');
      rect.setAttribute('opacity', custom.opacity / 100);
      // Apply border opacity
      const borderOpacity = custom.borderOpacity !== undefined ? custom.borderOpacity / 100 : 1;
      rect.setAttribute('stroke-opacity', borderOpacity);
    }
  });
}

// Apply label-only customization to SVG
/**
 * SVG-based Label Customization System
 * 
 * This approach modifies the existing SVG text elements directly for:
 * - Proper text formatting (bold, italic, alignment)
 * - Clean separation of name and value
 * - Proper padding/margin support via background rect
 * - Compatible with existing drag handlers
 */
let _applyingLabelCustomization = false; // Guard against re-entry
window._applyingLabelCustomizations = false; // Global flag for MutationObserver

function applyLabelCustomizationToSVG(nodeName, custom) {
  // Guard against re-entry (e.g., from MutationObserver)
  if (_applyingLabelCustomization) return;
  
  const svg = document.getElementById('sankey_svg');
  if (!svg) return;
  
  _applyingLabelCustomization = true;
  window._applyingLabelCustomizations = true;
  
  try {
    // === FIRST: Check if we already have the original value stored ===
    // Use a special marker to distinguish "not yet extracted" from "extracted but empty"
    const VALUE_NOT_EXTRACTED = Symbol.for('VALUE_NOT_EXTRACTED');
    let storedValue = VALUE_NOT_EXTRACTED;
    
    if (nodeCustomizations[nodeName] && nodeCustomizations[nodeName]._originalValue !== undefined) {
      storedValue = nodeCustomizations[nodeName]._originalValue;
    } else if (custom._originalValue !== undefined) {
      storedValue = custom._originalValue;
    }
    
    // Find the label group and text element using data-label-for attribute (most reliable)
    let labelGroup = null;
    let textEl = null;
    
    // Method 1: Use data-label-for attribute (preferred - most reliable)
    // Escape special characters in nodeName for CSS selector
    // Use CSS.escape if available, otherwise use a simple escape function
    const escapedNodeName = typeof CSS !== 'undefined' && CSS.escape 
      ? CSS.escape(nodeName) 
      : nodeName.replace(/([!"#$%&'()*+,.\/:;<=>?@[\\\]^`{|}~])/g, '\\$1');
    
    try {
      labelGroup = svg.querySelector(`.sankey-label[data-label-for="${escapedNodeName}"]`);
    } catch (e) {
      console.warn('CSS selector failed for:', escapedNodeName, e);
    }
    
    if (labelGroup) {
      textEl = labelGroup.querySelector('text');
    }
    
    // Method 2: Look for groups with ID ending in _group (fallback for original sankeymatic labels)
    if (!labelGroup || !textEl) {
      svg.querySelectorAll('g[id$="_group"]').forEach(group => {
        if (labelGroup && textEl) return; // Already found
        const dataLabelFor = group.getAttribute('data-label-for');
        if (dataLabelFor === nodeName) {
          labelGroup = group;
          textEl = group.querySelector('text');
        }
      });
    }
    
    // Method 3: Skip text content search - it's unreliable when display text differs from node name
    // If we can't find the label by data-label-for, log a warning
    if (!labelGroup || !textEl) {
      console.warn('Label not found for node:', nodeName);
      return;
    }
    
    // === EXTRACT VALUE ONLY IF NOT ALREADY STORED ===
    if (storedValue === VALUE_NOT_EXTRACTED) {
      storedValue = ''; // Default to empty string
      
      // First check for existing tspans with just numbers (value is typically in a separate tspan)
      const tspans = textEl.querySelectorAll('tspan');
      tspans.forEach(tspan => {
        const content = tspan.textContent?.trim() || '';
        // Match numbers with optional commas and decimal points
        if (/^[\d,]+\.?\d*$/.test(content) && storedValue === '') {
          storedValue = content;
        }
      });
      
      // If no tspan value found, try to extract from the main text element
      // But only if the text hasn't been customized yet (first time extraction)
      if (storedValue === '' && !nodeCustomizations[nodeName]?._valueExtracted) {
        // Get the first tspan or direct text content
        const firstTspan = textEl.querySelector('tspan');
        const mainText = firstTspan ? firstTspan.textContent : textEl.textContent;
        
        // Only extract if the text starts with the node name followed by a number
        // This handles cases like "Budget1,750" where name and value are concatenated
        if (mainText && mainText.startsWith(nodeName)) {
          const afterName = mainText.slice(nodeName.length).trim();
          // Match a number at the start (with optional commas and decimals)
          const valueMatch = afterName.match(/^([\d,]+\.?\d*)/);
          if (valueMatch) {
            storedValue = valueMatch[1];
          }
        }
      }
      
      // Mark that we've attempted extraction
      if (!nodeCustomizations[nodeName]) {
        nodeCustomizations[nodeName] = {};
      }
      nodeCustomizations[nodeName]._valueExtracted = true;
    }
    
    // Store the extracted value permanently (only if not already stored)
    if (!nodeCustomizations[nodeName]) {
      nodeCustomizations[nodeName] = {};
    }
    if (nodeCustomizations[nodeName]._originalValue === undefined) {
      nodeCustomizations[nodeName]._originalValue = storedValue === VALUE_NOT_EXTRACTED ? '' : storedValue;
    }
    custom._originalValue = nodeCustomizations[nodeName]._originalValue;
    
    // === GET CUSTOMIZATION SETTINGS ===
    const fontSize = parseInt(custom.labelFontSize) || 16;
    const paddingTop = parseInt(custom.labelMarginTop) || 0;
    const paddingRight = parseInt(custom.labelMarginRight) || 0;
    const paddingBottom = parseInt(custom.labelMarginBottom) || 0;
    const paddingLeft = parseInt(custom.labelMarginLeft) || 0;
    const alignment = custom.labelAlign || 'center';
    const displayName = custom.labelText || nodeName;
    const finalStoredValue = nodeCustomizations[nodeName]._originalValue || '';
    const isBold = custom.labelBold === true;
    const isItalic = custom.labelItalic === true;
    const textColor = custom.labelColor || '#000000';
    
    // === CLEAR AND REBUILD TEXT CONTENT ===
    // Remove all existing tspans
    while (textEl.firstChild) {
      textEl.removeChild(textEl.firstChild);
    }
    
    // Set text-level attributes
    textEl.setAttribute('font-size', fontSize + 'px');
    textEl.setAttribute('fill', textColor);
    
    // Set text anchor based on alignment
    const textAnchor = alignment === 'left' ? 'start' : alignment === 'right' ? 'end' : 'middle';
    textEl.setAttribute('text-anchor', textAnchor);
    
    // Calculate x position based on alignment and padding
    let xPos = 0;
    if (alignment === 'left') {
      xPos = paddingLeft;
    } else if (alignment === 'right') {
      xPos = -paddingRight;
    }
    
    // Add name line(s) - split by newline character
    const nameLines = displayName.split(/\r?\n/);
    let currentDy = 0;
    
    nameLines.forEach((line, index) => {
      if (line.trim() === '' && index > 0) {
        // Empty line - just add spacing
        currentDy += fontSize * 1.2;
        return;
      }
      
      const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
      tspan.textContent = line || ' '; // Use space for empty lines to maintain height
      tspan.setAttribute('x', xPos.toString());
      
      if (index === 0) {
        tspan.setAttribute('dy', paddingTop.toString());
      } else {
        tspan.setAttribute('dy', (fontSize * 1.2).toString());
      }
      
      // Apply bold/italic
      if (isBold) {
        tspan.setAttribute('font-weight', 'bold');
      }
      if (isItalic) {
        tspan.setAttribute('font-style', 'italic');
      }
      
      // Apply text color to each tspan
      tspan.setAttribute('fill', textColor);
      
      textEl.appendChild(tspan);
    });
    
    // Don't add the stored value as a separate line - the user's custom text should be the complete label
    // The value was only extracted for backwards compatibility
    
    // === APPLY POSITION OFFSET ===
    const offsetX = parseInt(custom.labelX) || 0;
    const offsetY = parseInt(custom.labelY) || 0;
    
    // Store original position if not already stored
    if (!customLayout[nodeName]) {
      customLayout[nodeName] = {};
    }
    
    const currentTransform = labelGroup.getAttribute('transform') || '';
    const match = currentTransform.match(/translate\(([^,]+),\s*([^)]+)\)/);
    if (match) {
      const currentX = parseFloat(match[1]);
      const currentY = parseFloat(match[2]);
      
      if (customLayout[nodeName].originalX === undefined) {
        // Check if there's a remembered move
        if (window.rememberedLabelMoves && window.rememberedLabelMoves.has(nodeName)) {
          const [remOffsetX, remOffsetY] = window.rememberedLabelMoves.get(nodeName);
          customLayout[nodeName].originalX = currentX - remOffsetX;
          customLayout[nodeName].originalY = currentY - remOffsetY;
        } else {
          customLayout[nodeName].originalX = currentX;
          customLayout[nodeName].originalY = currentY;
        }
      }
      
      // Apply offset from original position
      const newX = customLayout[nodeName].originalX + offsetX;
      const newY = customLayout[nodeName].originalY + offsetY;
      labelGroup.setAttribute('transform', `translate(${newX}, ${newY})`);
    }
    
    // === APPLY BACKGROUND BOX ===
    // Remove any existing background first
    const existingBg = labelGroup.querySelector('.custom-label-bg');
    if (existingBg) existingBg.remove();
    
    // Hide the original sankeymatic label background (label-bg class) to prevent white box
    // This includes both the label-bg and drag-handle elements
    labelGroup.querySelectorAll('.label-bg, .drag-handle').forEach(el => {
      el.style.display = 'none';
    });
    
    if (custom.labelBgEnabled) {
      // Wait for text to render, then add background
      setTimeout(() => {
        drawSmartLabelBackground(textEl, labelGroup, custom, paddingTop, paddingRight, paddingBottom, paddingLeft);
      }, 50);
    }
    
    // Ensure label is on top of flows
    const labelsLayer = svg.querySelector('#sankey_labels');
    if (labelsLayer && labelGroup.parentElement !== labelsLayer) {
      labelsLayer.appendChild(labelGroup);
    }
    
  } finally {
    _applyingLabelCustomization = false;
    // Reset global flag after a short delay to allow all pending operations to complete
    setTimeout(() => {
      window._applyingLabelCustomizations = false;
    }, 200);
  }
}

/**
 * Draw background box around label text (legacy SVG approach)
 */
function drawSmartLabelBackground(textEl, labelGroup, custom, paddingTop, paddingRight, paddingBottom, paddingLeft) {
  if (!textEl || !labelGroup) return;
  
  const existingBg = labelGroup.querySelector('.custom-label-bg');
  if (existingBg) existingBg.remove();
  
  let bbox;
  try {
    bbox = textEl.getBBox();
  } catch (e) {
    return;
  }
  
  if (bbox.width === 0 || bbox.height === 0) return;
  
  const bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
  bgRect.setAttribute('class', 'custom-label-bg');
  bgRect.setAttribute('x', bbox.x - paddingLeft);
  bgRect.setAttribute('y', bbox.y - paddingTop);
  bgRect.setAttribute('width', bbox.width + paddingLeft + paddingRight);
  bgRect.setAttribute('height', bbox.height + paddingTop + paddingBottom);
  bgRect.setAttribute('fill', custom.labelBg || '#ffffff');
  bgRect.setAttribute('rx', '4');
  bgRect.setAttribute('ry', '4');
  // Use custom opacity if provided, otherwise default to 95%
  const bgOpacity = custom.labelBgOpacity !== undefined ? (custom.labelBgOpacity / 100) : 0.95;
  bgRect.setAttribute('opacity', bgOpacity.toString());
  
  labelGroup.insertBefore(bgRect, textEl);
}

// Legacy function name for compatibility
function applyLabelBackground(textEl, labelGroup, custom) {
  const paddingTop = custom.labelMarginTop || 4;
  const paddingRight = custom.labelMarginRight || 6;
  const paddingBottom = custom.labelMarginBottom || 4;
  const paddingLeft = custom.labelMarginLeft || 6;
  drawSmartLabelBackground(textEl, labelGroup, custom, paddingTop, paddingRight, paddingBottom, paddingLeft);
}
      
function resetNodeToDefault() {
  if (!currentEditingNodeName) return;
  
  const nodeName = currentEditingNodeName;
  
  // Clear all customizations for this node
  delete nodeCustomizations[nodeName];
  delete nodeColors[nodeName];
  delete labelPositions[nodeName];
  
  // Reset customLayout to original position
  if (customLayout[nodeName] && customLayout[nodeName].originalX !== undefined) {
    customLayout[nodeName].labelX = customLayout[nodeName].originalX;
    customLayout[nodeName].labelY = customLayout[nodeName].originalY;
    customLayout[nodeName].labelW = 0;
    customLayout[nodeName].labelH = 0;
  }
  
  // Clear from rememberedLabelMoves
  if (window.rememberedLabelMoves) {
    window.rememberedLabelMoves.delete(nodeName);
  }
  
  closeNodePopup();
  renderDiagram();
}

// ============ LABEL & NODE CUSTOMIZATION APPLICATION ============
function applyLabelPositions() {
  // Prevent re-entry and MutationObserver loops
  if (window._applyingLabelCustomizations) return;
  window._applyingLabelCustomizations = true;
  
  try {
    const svg = document.getElementById('sankey_svg');
    if (!svg) return;
    
    // First, capture original positions for all label groups
    svg.querySelectorAll('g[id$="_group"]').forEach(group => {
      const textEl = group.querySelector('text');
      if (!textEl) return;
      
    // Get node name from data-label-for attribute (ALWAYS use this - it's the node identity)
    // The group ID format is "label0_group", "label1_group" etc. - NOT the node name!
    let nodeName = group.getAttribute('data-label-for');
    
    // IMPORTANT: Do NOT fall back to group ID or text content
    // The data-label-for attribute is the ONLY reliable source of node identity
    if (!nodeName) return;
    
    // Store original position if not already stored
    const transform = group.getAttribute('transform') || '';
    const match = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
    if (match) {
      if (!customLayout[nodeName]) {
        customLayout[nodeName] = {
          originalX: parseFloat(match[1]),
          originalY: parseFloat(match[2]),
          labelX: parseFloat(match[1]),
          labelY: parseFloat(match[2]),
          labelW: 0,
          labelH: 0
        };
      } else if (customLayout[nodeName].originalX === undefined) {
        customLayout[nodeName].originalX = parseFloat(match[1]);
        customLayout[nodeName].originalY = parseFloat(match[2]);
      }
    }
  });
  
  // Apply stored customizations to all labels and nodes
  Object.keys(nodeCustomizations).forEach(nodeName => {
    const custom = nodeCustomizations[nodeName];
    // Apply node customizations
    if (custom.fillColor || custom.borderColor || custom.opacity !== undefined) {
      applyNodeCustomizationToSVG(nodeName, custom);
    }
    // Apply label customizations - check for any label-related property
    const hasLabelCustomization = 
      custom.labelText !== undefined ||
      custom.labelColor !== undefined ||
      custom.labelFontSize !== undefined ||
      custom.labelBold !== undefined ||
      custom.labelItalic !== undefined ||
      custom.labelAlign !== undefined ||
      custom.labelBgEnabled !== undefined ||
      custom.labelBg !== undefined ||
      custom.labelX !== undefined ||
      custom.labelY !== undefined ||
      custom.labelMarginTop !== undefined ||
      custom.labelMarginRight !== undefined ||
      custom.labelMarginBottom !== undefined ||
      custom.labelMarginLeft !== undefined;
    
    if (hasLabelCustomization) {
      applyLabelCustomizationToSVG(nodeName, custom);
    }
  });
  
  // Setup independent label dragging
  setupIndependentLabelDragging();
  
  } finally {
    // Reset global flag after a short delay
    setTimeout(() => {
      window._applyingLabelCustomizations = false;
    }, 300);
  }
}
</script>

<script>
// ============ MULTI-IMAGE UPLOAD ============
function handleMultiImageUpload(event) {
  const files = Array.from(event.target.files);
  if (!files.length) return;
  
  files.forEach(file => processImageFile(file));
  event.target.value = '';
}

function processImageFile(file) {
  const reader = new FileReader();
  reader.onload = function(e) {
    const base64 = e.target.result.split(',')[1];
    const imageData = { 
      type: file.type, 
      base64: base64, 
      name: file.name || 'image',
      dataUrl: e.target.result
    };
    uploadedImages.push(imageData);
    renderImagePreviews();
    updateAIStatus(`üì∑ ${uploadedImages.length} image(s) ready`, 'success');
  };
  reader.readAsDataURL(file);
}

function renderImagePreviews() {
  const container = document.getElementById('image-previews');
  container.innerHTML = '';
  
  uploadedImages.forEach((img, index) => {
    const div = document.createElement('div');
    div.className = 'image-preview-item';
    div.innerHTML = `
      <img src="${img.dataUrl}" alt="${img.name}">
      <button class="remove-btn" onclick="removeImage(${index})">√ó</button>
    `;
    container.appendChild(div);
  });
}

function removeImage(index) {
  uploadedImages.splice(index, 1);
  renderImagePreviews();
  updateAIStatus(uploadedImages.length ? `üì∑ ${uploadedImages.length} image(s) ready` : '', uploadedImages.length ? 'success' : '');
}

function clearAllImages() {
  uploadedImages = [];
  renderImagePreviews();
  updateAIStatus('', '');
}

// Drag and drop support
document.addEventListener('DOMContentLoaded', function() {
  const uploadArea = document.getElementById('image-upload-area');
  if (uploadArea) {
    uploadArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadArea.classList.add('dragover');
    });
    uploadArea.addEventListener('dragleave', () => {
      uploadArea.classList.remove('dragover');
    });
    uploadArea.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadArea.classList.remove('dragover');
      const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
      files.forEach(file => processImageFile(file));
    });
  }
  
  // Paste support
  const chatInput = document.getElementById('ai-chat-input');
  if (chatInput) {
    chatInput.addEventListener('paste', function(e) {
      const items = e.clipboardData?.items;
      if (!items) return;
      for (let i = 0; i < items.length; i++) {
        if (items[i].type.startsWith('image/')) {
          e.preventDefault();
          const file = items[i].getAsFile();
          if (file) processImageFile(file);
          break;
        }
      }
    });
  }
});

async function pasteFromClipboard() {
  try {
    const clipboardItems = await navigator.clipboard.read();
    for (const item of clipboardItems) {
      const imageType = item.types.find(type => type.startsWith('image/'));
      if (imageType) {
        const blob = await item.getType(imageType);
        const file = new File([blob], 'pasted-image.png', { type: imageType });
        processImageFile(file);
        return;
      }
      // Also try to paste text as JSON
      if (item.types.includes('text/plain')) {
        const blob = await item.getType('text/plain');
        const text = await blob.text();
        document.getElementById('ai-chat-input').value = text;
        return;
      }
    }
    updateAIStatus('No image or text in clipboard', 'warning');
  } catch (err) {
    console.error('Clipboard error:', err);
    updateAIStatus('Cannot access clipboard', 'error');
  }
}

// ============ AI API WITH ROBUST JSON PARSING ============
async function callGeminiAPI(apiKey, model, text, customPrompt, images) {
  const systemPrompt = customPrompt || DEFAULT_SYSTEM_PROMPT;
  
  let contents;
  if (images && images.length > 0) {
    // With images - build parts array
    const parts = [{ text: systemPrompt + '\n\nAnalyze these images and extract financial flows:\n' + text }];
    images.forEach(img => {
      parts.push({ inline_data: { mime_type: img.type, data: img.base64 } });
    });
    contents = [{ parts }];
  } else {
    contents = [{ parts: [{ text: systemPrompt + '\n\nData to parse:\n' + text }] }];
  }

  const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      contents: contents,
      generationConfig: { temperature: 0.1, maxOutputTokens: 8192 }
    })
  });
  
  if (!response.ok) {
    const err = await response.json();
    throw new Error(err.error?.message || 'API request failed');
  }
  
  const data = await response.json();
  const responseText = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
  
  addToChatHistory('ai', responseText.substring(0, 200) + '...');
  
  // Robust JSON extraction with error handling
  return parseAIResponse(responseText);
}

function parseAIResponse(responseText) {
  console.log('Parsing AI response:', responseText.substring(0, 500));
  
  // If response is empty or just whitespace
  if (!responseText || !responseText.trim()) {
    console.log('Empty response from AI');
    return { chatResponse: 'AI returned empty response', flows: [] };
  }
  
  // Try to extract JSON from response with multiple strategies
  let jsonStr = '';
  
  // Method 1: Find JSON block in markdown code fence
  const codeBlockMatch = responseText.match(/```(?:json)?\s*([\s\S]*?)```/);
  if (codeBlockMatch) {
    jsonStr = codeBlockMatch[1].trim();
    console.log('Found JSON in code block');
  }
  
  // Method 2: Find raw JSON object - be more careful with nested structures
  if (!jsonStr) {
    const startIdx = responseText.indexOf('{');
    if (startIdx !== -1) {
      let depth = 0;
      let endIdx = startIdx;
      let inString = false;
      let escapeNext = false;
      
      for (let i = startIdx; i < responseText.length; i++) {
        const char = responseText[i];
        
        if (escapeNext) {
          escapeNext = false;
          continue;
        }
        
        if (char === '\\') {
          escapeNext = true;
          continue;
        }
        
        if (char === '"' && !escapeNext) {
          inString = !inString;
          continue;
        }
        
        if (!inString) {
          if (char === '{') depth++;
          else if (char === '}') {
            depth--;
            if (depth === 0) {
              endIdx = i + 1;
              break;
            }
          }
        }
      }
      
      if (depth === 0 && endIdx > startIdx) {
        jsonStr = responseText.substring(startIdx, endIdx);
        console.log('Found JSON object in response');
      }
    }
  }
  
  // Method 3: Try to find flows pattern directly in text (no JSON wrapper)
  if (!jsonStr) {
    // Look for patterns like: Source [amount] Target or Source -> Target: amount
    const textFlows = extractFlowsFromText(responseText);
    if (textFlows.length > 0) {
      console.log('Extracted flows from text patterns');
      return { flows: textFlows };
    }
  }
  
  if (!jsonStr) {
    // Return a helpful message instead of throwing
    console.log('No JSON found, returning chat response');
    return { chatResponse: responseText, flows: [] };
  }
  
  // Clean up common JSON issues
  jsonStr = cleanJSON(jsonStr);
  
  // Multiple parsing attempts with progressive fixes
  const parseAttempts = [
    // Attempt 1: Direct parse
    () => JSON.parse(jsonStr),
    // Attempt 2: Fix trailing commas
    () => JSON.parse(jsonStr.replace(/,(\s*[}\]])/g, '$1')),
    // Attempt 3: Fix unquoted keys and trailing commas
    () => {
      let fixed = jsonStr.replace(/,(\s*[}\]])/g, '$1');
      fixed = fixed.replace(/([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)(\s*:)/g, '$1"$2"$3');
      return JSON.parse(fixed);
    },
    // Attempt 4: Extract flows with flexible regex - handles various orderings and formats
    () => {
      const flows = [];
      // More flexible patterns that handle various orderings and large numbers
      const patterns = [
        // Standard format with any order of keys
        /"from"\s*:\s*"([^"]+)"[\s\S]*?"to"\s*:\s*"([^"]+)"[\s\S]*?"amount"\s*:\s*(\d+(?:\.\d+)?(?:e[+-]?\d+)?)/gi,
        // Reversed order (amount first)
        /"amount"\s*:\s*(\d+(?:\.\d+)?(?:e[+-]?\d+)?)[\s\S]*?"from"\s*:\s*"([^"]+)"[\s\S]*?"to"\s*:\s*"([^"]+)"/gi,
        // source/target naming
        /"source"\s*:\s*"([^"]+)"[\s\S]*?"target"\s*:\s*"([^"]+)"[\s\S]*?"(?:amount|value)"\s*:\s*(\d+(?:\.\d+)?(?:e[+-]?\d+)?)/gi,
        // Simple object format
        /\{\s*"from"\s*:\s*"([^"]+)"\s*,\s*"to"\s*:\s*"([^"]+)"\s*,\s*"amount"\s*:\s*(\d+)/g
      ];
      
      for (const pattern of patterns) {
        let match;
        pattern.lastIndex = 0; // Reset regex state
        while ((match = pattern.exec(jsonStr)) !== null) {
          // Handle different capture group orders
          if (pattern.source.startsWith('"amount"')) {
            flows.push({ from: match[2], to: match[3], amount: parseFloat(match[1]) });
          } else {
            flows.push({ from: match[1], to: match[2], amount: parseFloat(match[3]) });
          }
        }
        if (flows.length > 0) break;
      }
      
      if (flows.length > 0) return { flows };
      throw new Error('No flows found');
    },
    // Attempt 5: Try to extract individual flow objects from truncated JSON
    () => {
      const flows = [];
      // Match individual flow objects even if the array is incomplete
      const flowObjPattern = /\{\s*"from"\s*:\s*"([^"]+)"\s*,\s*"to"\s*:\s*"([^"]+)"\s*,\s*"amount"\s*:\s*(\d+(?:\.\d+)?(?:e[+-]?\d+)?)\s*\}/gi;
      let match;
      while ((match = flowObjPattern.exec(responseText)) !== null) {
        flows.push({ from: match[1], to: match[2], amount: parseFloat(match[3]) });
      }
      if (flows.length > 0) return { flows };
      throw new Error('No flows found');
    }
  ];
  
  for (let i = 0; i < parseAttempts.length; i++) {
    try {
      const result = parseAttempts[i]();
      console.log(`JSON parsed successfully with attempt ${i + 1}`);
      return result;
    } catch (e) {
      console.log(`Parse attempt ${i + 1} failed:`, e.message);
    }
  }
  
  // If all parsing fails, return the response as chat
  console.log('All JSON parsing failed, returning as chat response');
  return { chatResponse: responseText, flows: [] };
}

// Extract flows from natural text patterns
function extractFlowsFromText(text) {
  const flows = [];
  
  // Pattern: "Source [amount] Target" (SankeyMATIC format)
  const sankeyPattern = /([A-Za-z][A-Za-z0-9\s]*?)\s*\[(\d+(?:\.\d+)?)\]\s*([A-Za-z][A-Za-z0-9\s]*)/g;
  let match;
  while ((match = sankeyPattern.exec(text)) !== null) {
    flows.push({ from: match[1].trim(), to: match[3].trim(), amount: parseFloat(match[2]) });
  }
  
  // Pattern: "Source -> Target: amount" or "Source to Target: amount"
  const arrowPattern = /([A-Za-z][A-Za-z0-9\s]*?)\s*(?:->|‚Üí|to)\s*([A-Za-z][A-Za-z0-9\s]*?):\s*\$?(\d+(?:,\d{3})*(?:\.\d+)?)/gi;
  while ((match = arrowPattern.exec(text)) !== null) {
    const amount = parseFloat(match[3].replace(/,/g, ''));
    flows.push({ from: match[1].trim(), to: match[2].trim(), amount });
  }
  
  return flows;
}

function cleanJSON(str) {
  // Remove BOM and other invisible characters
  str = str.replace(/^\uFEFF/, '');
  // Remove control characters except newlines and tabs
  str = str.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '');
  // Remove any text before the first { or after the last }
  const firstBrace = str.indexOf('{');
  const lastBrace = str.lastIndexOf('}');
  if (firstBrace !== -1 && lastBrace !== -1) {
    str = str.substring(firstBrace, lastBrace + 1);
  }
  // Normalize whitespace
  str = str.trim();
  return str;
}
</script>

<script>
// ============ AI CHAT PROCESSING ============
// Enhanced AI chat integration with AIController
// Requirements: 5.1, 5.3 - AI reads/modifies diagram data with preview

/**
 * Get comprehensive diagram context for AI
 * Passes all diagram data to AI context (Requirement 5.1, 5.7)
 */
function getAIDiagramContext() {
  if (typeof AIController === 'undefined') {
    return { context: '', data: null };
  }
  
  const data = AIController.getDiagramData();
  
  // Use the enhanced getDiagramStateForAI method for comprehensive context
  const context = AIController.getDiagramStateForAI();
  
  return { context, data };
}

/**
 * Handle AI modification response using AIController
 * Validates and applies changes with undo support (Requirement 5.2, 5.6)
 */
async function handleAIModification(result, previewTitle) {
  if (!result.flows || result.flows.length === 0) {
    return { success: false, message: 'No flows to apply' };
  }
  
  // Normalize flow format
  const normalizedFlows = result.flows.map(f => ({
    source: f.from || f.source,
    target: f.to || f.target,
    amount: parseFloat(f.amount || f.value || 0)
  }));
  
  // Validate using AIController
  if (typeof AIController !== 'undefined') {
    const validation = AIController.validateDiagramData({ flows: normalizedFlows });
    if (!validation.isValid) {
      return { 
        success: false, 
        message: 'Invalid data: ' + validation.errors.join(', ')
      };
    }
  }
  
  // Generate preview diff
  const currentData = typeof AIController !== 'undefined' ? AIController.getDiagramData() : { flows: [] };
  const previewContent = generateAIDiff(currentData.flows, normalizedFlows);
  
  // Show preview and get user confirmation (Requirement 5.3)
  const userApproved = await showAIPreviewWithDiff(previewTitle, previewContent, normalizedFlows);
  
  if (!userApproved) {
    return { success: false, message: 'Cancelled by user' };
  }
  
  // Apply using AIController for proper undo support (Requirement 5.6, 5.8)
  if (typeof AIController !== 'undefined') {
    const applyResult = AIController.applyDiagramData({ flows: normalizedFlows }, true);
    return {
      success: applyResult.success,
      message: applyResult.success 
        ? `Applied ${normalizedFlows.length} flows` 
        : 'Failed: ' + (applyResult.errors || []).join(', '),
      flowCount: normalizedFlows.length
    };
  }
  
  // Fallback if AIController not available
  saveStateForUndo();
  normalizedFlows.forEach(f => {
    addDataRowWithValues(f.source, f.target, String(f.amount), '');
  });
  updateDiagramFromTableNoUndo();
  
  return { success: true, message: `Added ${normalizedFlows.length} flows`, flowCount: normalizedFlows.length };
}

/**
 * Generate a diff between current and new flows
 */
function generateAIDiff(currentFlows, newFlows) {
  const lines = [];
  
  // Find removed flows
  currentFlows.forEach(cf => {
    const exists = newFlows.some(nf => 
      nf.source === cf.source && nf.target === cf.target
    );
    if (!exists) {
      lines.push(`- REMOVED: ${cf.source} ‚Üí ${cf.target}: ${cf.amount}`);
    }
  });
  
  // Find added or modified flows
  newFlows.forEach(nf => {
    const existing = currentFlows.find(cf => 
      cf.source === nf.source && cf.target === nf.target
    );
    if (!existing) {
      lines.push(`+ ADDED: ${nf.source} ‚Üí ${nf.target}: ${nf.amount}`);
    } else if (existing.amount !== nf.amount) {
      lines.push(`~ MODIFIED: ${nf.source} ‚Üí ${nf.target}: ${existing.amount} ‚Üí ${nf.amount}`);
    } else {
      lines.push(`  UNCHANGED: ${nf.source} ‚Üí ${nf.target}: ${nf.amount}`);
    }
  });
  
  return lines.join('\n');
}

async function processAIChat() {
  const input = document.getElementById('ai-chat-input');
  const btn = document.getElementById('ai-send-btn');
  const text = input.value.trim();
  
  if (!text && uploadedImages.length === 0) {
    updateAIStatus('Please enter text or upload images', 'error');
    return;
  }
  
  const apiKey = localStorage.getItem('gemini_api_key');
  if (!apiKey) {
    updateAIStatus('‚ö†Ô∏è Please set API key in Settings', 'warning');
    openSettingsModal();
    return;
  }
  
  btn.disabled = true;
  addToChatHistory('user', text || `[${uploadedImages.length} image(s) uploaded]`);
  
  // Show progress
  const progressEl = document.getElementById('upload-progress');
  const progressBar = document.getElementById('progress-bar-fill');
  const progressText = document.getElementById('progress-text');
  progressEl.style.display = 'block';
  progressBar.style.width = '30%';
  progressText.textContent = 'Sending to AI...';
  
  try {
    const model = localStorage.getItem('ai_model') || 'gemini-2.0-flash';
    const customPrompt = localStorage.getItem('ai_system_prompt') || '';
    
    progressBar.style.width = '60%';
    progressText.textContent = 'Processing...';
    
    // Check if user wants to parse/modify data
    const parseKeywords = ['parse', 'extract', 'convert', 'add', 'create', 'generate', 'modify', 'change', 'update', 'rebalance', 'balance', 'analyze', 'summary', 'scale', 'multiply', 'divide'];
    const shouldParse = parseKeywords.some(kw => text.toLowerCase().includes(kw)) || uploadedImages.length > 0;
    
    // Check for AIController-specific commands
    if (typeof AIController !== 'undefined') {
      const lowerText = text.toLowerCase();
      
      // Handle analyze/summary commands
      if (lowerText.includes('analyze') || lowerText.includes('summary') || (lowerText.includes('balance') && !lowerText.includes('rebalance'))) {
        const summary = AIController.getSummary();
        const balance = AIController.analyzeFlowBalance();
        
        let response = summary;
        if (balance.imbalanced.length > 0) {
          response += '\n\nSuggested fixes:\n';
          balance.imbalanced.forEach(ib => {
            response += `‚Ä¢ ${ib.suggestion}\n`;
          });
        }
        
        addToChatHistory('ai', response);
        updateAIStatus('‚úì Analysis complete', 'success');
        input.value = '';
        btn.disabled = false;
        progressEl.style.display = 'none';
        return;
      }
      
      // Handle unit conversion commands (Requirement 5.4)
      const convertMatch = text.match(/(?:convert|scale|multiply)\s+(?:units?\s+)?(?:by\s+)?(\d+(?:\.\d+)?)/i);
      const divideMatch = text.match(/divide\s+(?:by\s+)?(\d+(?:\.\d+)?)/i);
      
      if (convertMatch || divideMatch) {
        let factor = convertMatch ? parseFloat(convertMatch[1]) : 1 / parseFloat(divideMatch[1]);
        
        // Show preview before conversion
        const currentData = AIController.getDiagramData();
        const previewFlows = currentData.flows.map(f => ({
          source: f.source,
          target: f.target,
          oldAmount: f.amount,
          newAmount: f.amount * factor
        }));
        
        const previewContent = previewFlows.map(f => 
          `${f.source} ‚Üí ${f.target}: ${f.oldAmount} ‚Üí ${f.newAmount.toFixed(2)}`
        ).join('\n');
        
        if (await showAIPreviewWithDiff('Unit Conversion', previewContent, null)) {
          const result = AIController.convertUnits(factor);
          if (result.success) {
            addToChatHistory('ai', `‚úÖ Converted all flow amounts by factor ${factor.toFixed(4)}`);
            updateAIStatus(`‚úì Converted by ${factor}x`, 'success');
          } else {
            addToChatHistory('ai', `‚ùå Conversion failed: ${result.error}`);
            updateAIStatus('Conversion failed', 'error');
          }
        } else {
          addToChatHistory('ai', '‚ùå Conversion cancelled by user');
          updateAIStatus('Cancelled', 'warning');
        }
        input.value = '';
        btn.disabled = false;
        progressEl.style.display = 'none';
        return;
      }
      
      // Handle add flow command directly
      const addFlowMatch = text.match(/add\s+(?:flow\s+)?(?:from\s+)?["']?([^"']+?)["']?\s+(?:to\s+)?["']?([^"']+?)["']?\s*[:=]?\s*(\d+(?:\.\d+)?)/i);
      if (addFlowMatch) {
        const source = addFlowMatch[1].trim();
        const target = addFlowMatch[2].trim();
        const amount = parseFloat(addFlowMatch[3]);
        
        const previewContent = `+ ADDED: ${source} ‚Üí ${target}: ${amount}`;
        if (await showAIPreviewWithDiff('Add Flow', previewContent, null)) {
          const result = AIController.addFlow(source, target, amount);
          if (result.success) {
            addToChatHistory('ai', `‚úÖ Added flow: ${source} ‚Üí ${target}: ${amount}`);
            updateAIStatus('‚úì Flow added', 'success');
          } else {
            addToChatHistory('ai', `‚ùå Failed to add flow: ${(result.errors || []).join(', ')}`);
            updateAIStatus('Failed', 'error');
          }
        } else {
          addToChatHistory('ai', '‚ùå Flow addition cancelled by user');
          updateAIStatus('Cancelled', 'warning');
        }
        input.value = '';
        btn.disabled = false;
        progressEl.style.display = 'none';
        return;
      }
    }
    
    if (shouldParse) {
      // Include comprehensive diagram context for AI (Requirement 5.1, 5.7)
      const { context: diagramContext } = getAIDiagramContext();
      
      const result = await callGeminiAPI(apiKey, model, text + diagramContext, customPrompt, uploadedImages);
      
      progressBar.style.width = '90%';
      progressText.textContent = 'Applying changes...';
      
      if (result.chatResponse && (!result.flows || result.flows.length === 0)) {
        // AI returned a chat response instead of flows - show it to user
        addToChatHistory('ai', result.chatResponse.substring(0, 500));
        updateAIStatus('üí¨ AI responded - try being more specific about the data format', 'warning');
      } else if (result.action === 'modify' && result.modifications) {
        // Show preview before applying modifications
        const preview = result.modifications.map(m => 
          m.from && m.to ? `~ ${m.from} ‚Üí ${m.to}: ${m.newAmount}` : `~ ${m.node}: ${m.newAmount}`
        ).join('\n');
        
        if (await showAIPreviewWithDiff('Modifications', preview, null)) {
          applyModifications(result.modifications);
          addToChatHistory('ai', `‚úÖ Applied ${result.modifications.length} modifications`);
          updateAIStatus(`‚úì Modified ${result.modifications.length} items`, 'success');
        } else {
          addToChatHistory('ai', '‚ùå Modifications cancelled by user');
          updateAIStatus('Cancelled', 'warning');
        }
      } else if (result.action === 'rebalance' && result.targetNode) {
        // Handle rebalancing with preview
        const previewContent = `Rebalance ${result.targetNode} to total: ${result.newTotal}`;
        if (await showAIPreviewWithDiff('Rebalance Node', previewContent, null)) {
          rebalanceNode(result.targetNode, result.newTotal);
          addToChatHistory('ai', `‚úÖ Rebalanced ${result.targetNode}`);
          updateAIStatus(`‚úì Rebalanced node`, 'success');
        } else {
          addToChatHistory('ai', '‚ùå Rebalance cancelled by user');
          updateAIStatus('Cancelled', 'warning');
        }
      } else if (result.flows && result.flows.length > 0) {
        // Handle new flows using enhanced handler
        const modResult = await handleAIModification(result, 'AI Suggested Flows');
        
        if (modResult.success) {
          addToChatHistory('ai', `‚úÖ ${modResult.message}`);
          updateAIStatus(`‚úì ${modResult.message}`, 'success');
        } else {
          addToChatHistory('ai', `‚ùå ${modResult.message}`);
          updateAIStatus(modResult.message, modResult.message === 'Cancelled by user' ? 'warning' : 'error');
        }
      } else {
        addToChatHistory('ai', 'No flows found. Try: "parse: Revenue 100 to Expenses 50" or upload an image.');
        updateAIStatus('No flows found', 'warning');
      }
    } else {
      // Chat mode - include diagram context
      let contextText = text;
      if (typeof AIController !== 'undefined') {
        contextText += '\n\n[Context: ' + AIController.getSummary() + ']';
      }
      const chatResponse = await callGeminiChatAPI(apiKey, model, contextText);
      addToChatHistory('ai', chatResponse);
      updateAIStatus('', '');
    }
    
    input.value = '';
    clearAllImages();
  } catch (err) {
    console.error('AI Error:', err);
    addToChatHistory('ai', '‚ùå Error: ' + err.message);
    updateAIStatus('Error: ' + err.message.substring(0, 50), 'error');
  } finally {
    btn.disabled = false;
    progressEl.style.display = 'none';
    progressBar.style.width = '0%';
  }
}

// Show enhanced preview modal for AI modifications with diff display
// Requirement 5.3 - Show preview before applying changes
async function showAIPreviewWithDiff(title, content, flowsData) {
  return new Promise((resolve) => {
    const modal = document.createElement('div');
    modal.className = 'modal-overlay ai-preview-modal';
    modal.style.cssText = 'display:flex;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);z-index:10000;align-items:center;justify-content:center;';
    
    // Color-code the diff lines
    const coloredContent = content.split('\n').map(line => {
      if (line.startsWith('+') || line.startsWith('+ ')) {
        return `<span style="color:#22c55e;font-weight:500;">${escapeHtml(line)}</span>`;
      } else if (line.startsWith('-') || line.startsWith('- ')) {
        return `<span style="color:#ef4444;font-weight:500;">${escapeHtml(line)}</span>`;
      } else if (line.startsWith('~') || line.startsWith('~ ')) {
        return `<span style="color:#f59e0b;font-weight:500;">${escapeHtml(line)}</span>`;
      }
      return `<span style="color:#666;">${escapeHtml(line)}</span>`;
    }).join('\n');
    
    modal.innerHTML = `
      <div style="background:var(--studio-bg-primary, white);border-radius:12px;padding:0;max-width:550px;width:90%;max-height:80vh;overflow:hidden;box-shadow:0 20px 60px rgba(0,0,0,0.3);">
        <div style="padding:16px 20px;border-bottom:1px solid var(--studio-border-light, #e0e0e0);background:var(--studio-bg-secondary, #f8f9fa);">
          <h3 style="margin:0;font-size:16px;display:flex;align-items:center;gap:8px;">
            <span>ü§ñ</span> AI Preview: ${escapeHtml(title)}
          </h3>
        </div>
        <div style="padding:20px;max-height:400px;overflow-y:auto;">
          <div style="margin-bottom:12px;font-size:12px;color:var(--studio-text-secondary, #666);">
            <span style="display:inline-block;margin-right:12px;"><span style="color:#22c55e;">+</span> Added</span>
            <span style="display:inline-block;margin-right:12px;"><span style="color:#ef4444;">-</span> Removed</span>
            <span style="display:inline-block;"><span style="color:#f59e0b;">~</span> Modified</span>
          </div>
          <pre style="background:var(--studio-bg-tertiary, #f5f5f5);padding:12px;border-radius:8px;font-size:12px;white-space:pre-wrap;max-height:300px;overflow:auto;margin:0;font-family:'Monaco','Menlo','Ubuntu Mono',monospace;line-height:1.5;">${coloredContent}</pre>
        </div>
        <div style="padding:16px 20px;border-top:1px solid var(--studio-border-light, #e0e0e0);display:flex;gap:10px;justify-content:flex-end;background:var(--studio-bg-secondary, #f8f9fa);">
          <button id="ai-preview-cancel" style="padding:10px 20px;border:1px solid var(--studio-border-medium, #ccc);border-radius:6px;background:var(--studio-bg-primary, white);cursor:pointer;font-size:13px;font-weight:500;">Cancel</button>
          <button id="ai-preview-apply" style="padding:10px 20px;border:none;border-radius:6px;background:#1a73e8;color:white;cursor:pointer;font-size:13px;font-weight:500;">Apply Changes</button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Focus the apply button for keyboard accessibility
    setTimeout(() => modal.querySelector('#ai-preview-apply').focus(), 100);
    
    modal.querySelector('#ai-preview-cancel').onclick = () => {
      modal.remove();
      resolve(false);
    };
    
    modal.querySelector('#ai-preview-apply').onclick = () => {
      modal.remove();
      resolve(true);
    };
    
    // Handle keyboard events
    modal.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        modal.remove();
        resolve(false);
      } else if (e.key === 'Enter' && !e.shiftKey) {
        modal.remove();
        resolve(true);
      }
    });
    
    modal.onclick = (e) => {
      if (e.target === modal) {
        modal.remove();
        resolve(false);
      }
    };
  });
}

// Helper to escape HTML for safe display
function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// Legacy function for backward compatibility
async function showAIPreview(title, content) {
  return showAIPreviewWithDiff(title, content, null);
}

function applyModifications(modifications) {
  const tbody = document.getElementById('data-table-body');
  
  // Use AIController if available for better handling
  if (typeof AIController !== 'undefined') {
    AIController.modifyFlows(
      (flow) => modifications.some(mod => 
        (mod.from && mod.to && flow.source === mod.from && flow.target === mod.to) ||
        (mod.node && (flow.source === mod.node || flow.target === mod.node))
      ),
      (flow) => {
        const mod = modifications.find(m => 
          (m.from && m.to && flow.source === m.from && flow.target === m.to) ||
          (m.node && (flow.source === m.node || flow.target === m.node))
        );
        if (mod && mod.newAmount !== undefined) {
          flow.amount = mod.newAmount;
        }
        return flow;
      }
    );
    return;
  }
  
  // Fallback to direct DOM manipulation
  modifications.forEach(mod => {
    tbody.querySelectorAll('tr').forEach(row => {
      const inputs = row.querySelectorAll('input');
      if (mod.node && (inputs[0].value === mod.node || inputs[1].value === mod.node)) {
        if (mod.newAmount !== undefined) inputs[2].value = mod.newAmount;
      }
      if (mod.from && mod.to && inputs[0].value === mod.from && inputs[1].value === mod.to) {
        if (mod.newAmount !== undefined) inputs[2].value = mod.newAmount;
      }
    });
  });
  updateDiagramFromTableNoUndo();
}

function rebalanceNode(nodeName, newTotal) {
  const tbody = document.getElementById('data-table-body');
  const rows = tbody.querySelectorAll('tr');
  let currentTotal = 0;
  const affectedRows = [];
  
  rows.forEach(row => {
    const inputs = row.querySelectorAll('input');
    if (inputs[0].value === nodeName) {
      currentTotal += parseFloat(inputs[2].value) || 0;
      affectedRows.push({ row, inputs, type: 'out' });
    }
  });
  
  if (affectedRows.length > 0 && currentTotal > 0) {
    const ratio = newTotal / currentTotal;
    affectedRows.forEach(({ inputs }) => {
      const oldVal = parseFloat(inputs[2].value) || 0;
      inputs[2].value = Math.round(oldVal * ratio * 100) / 100;
    });
    updateDiagramFromTableNoUndo();
  }
}

async function callGeminiChatAPI(apiKey, model, text) {
  // Get diagram context from AIController if available
  let diagramData = 'No data yet';
  if (typeof AIController !== 'undefined') {
    const data = AIController.getDiagramData();
    if (data.flows.length > 0) {
      diagramData = data.flows.map(f => `${f.source} [${f.amount}] ${f.target}`).join('\n');
    }
  } else {
    diagramData = document.getElementById('flows_in')?.value || 'No data yet';
  }
  
  const chatPrompt = `You are a helpful assistant for creating Sankey diagrams. Help users understand their data.

Current diagram data:
${diagramData}

User question: ${text}

Respond helpfully and concisely. Keep responses under 150 words.`;

  const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      contents: [{ parts: [{ text: chatPrompt }] }],
      generationConfig: { temperature: 0.7, maxOutputTokens: 500 }
    })
  });
  
  if (!response.ok) {
    const err = await response.json();
    throw new Error(err.error?.message || 'API request failed');
  }
  
  const data = await response.json();
  return data.candidates?.[0]?.content?.parts?.[0]?.text || 'Sorry, I couldn\'t generate a response.';
}
</script>

<script>
// ============ JSON EDITOR ============
function openJSONEditor() {
  const modal = document.getElementById('json-editor-modal');
  const textarea = document.getElementById('json-editor-textarea');
  
  // Convert current data to JSON
  const jsonData = getCurrentDataAsJSON();
  textarea.value = JSON.stringify(jsonData, null, 2);
  
  modal.classList.add('active');
}

function closeJSONEditor() {
  document.getElementById('json-editor-modal').classList.remove('active');
}

// ============ EXPORT MODAL ============
function openExportModal() {
  document.getElementById('export-modal').classList.add('active');
}

function closeExportModal() {
  document.getElementById('export-modal').classList.remove('active');
}

function exportAsPNG(scale) {
  if (typeof saveDiagramAsPNG === 'function') {
    saveDiagramAsPNG(scale);
  }
}

function exportAsSVG() {
  if (typeof saveDiagramAsSVG === 'function') {
    saveDiagramAsSVG();
  }
}

function getCurrentDataAsJSON() {
  const tbody = document.getElementById('data-table-body');
  const rows = tbody.querySelectorAll('tr');
  const flows = [];
  
  rows.forEach(row => {
    const inputs = row.querySelectorAll('input');
    const from = inputs[0].value.trim();
    const to = inputs[1].value.trim();
    const amount = parseFloat(inputs[2].value) || 0;
    const comparison = inputs[3]?.value.trim() || '';
    
    if (from && to && amount) {
      flows.push({ from, to, amount, comparison: comparison || undefined });
    }
  });
  
  return {
    title: document.getElementById('diagram-title-input').value,
    flows,
    nodeColors,
    nodeCustomizations,
    options: getOptionsState()
  };
}

function applyJSONData() {
  const textarea = document.getElementById('json-editor-textarea');
  let jsonStr = textarea.value.trim();
  
  try {
    jsonStr = cleanJSON(jsonStr);
    const data = JSON.parse(jsonStr);
    
    saveStateForUndo();
    
    // Clear existing data
    document.getElementById('data-table-body').innerHTML = '';
    
    // Apply title
    if (data.title) {
      document.getElementById('diagram-title-input').value = data.title;
    }
    
    // Apply flows
    if (data.flows && Array.isArray(data.flows)) {
      data.flows.forEach(f => {
        addDataRowWithValues(
          f.from || f.source || '',
          f.to || f.target || '',
          String(f.amount || f.value || 0),
          f.comparison || ''
        );
      });
    }
    
    // Apply node colors
    if (data.nodeColors) {
      nodeColors = { ...data.nodeColors };
    }
    
    // Apply customizations
    if (data.nodeCustomizations) {
      nodeCustomizations = { ...data.nodeCustomizations };
    }
    
    // Apply options
    if (data.options) {
      restoreOptionsState(data.options);
    }
    
    updateDiagramFromTableNoUndo();
    closeJSONEditor();
    updateAIStatus('‚úì JSON data applied', 'success');
  } catch (e) {
    console.error('JSON parse error:', e);
    updateAIStatus('Invalid JSON: ' + e.message, 'error');
    alert('Invalid JSON format: ' + e.message);
  }
}

async function copyJSONToClipboard() {
  const textarea = document.getElementById('json-editor-textarea');
  try {
    await navigator.clipboard.writeText(textarea.value);
    updateAIStatus('‚úì Copied to clipboard', 'success');
  } catch (e) {
    textarea.select();
    document.execCommand('copy');
    updateAIStatus('‚úì Copied to clipboard', 'success');
  }
}

async function pasteJSONFromClipboard() {
  try {
    const text = await navigator.clipboard.readText();
    document.getElementById('json-editor-textarea').value = text;
    updateAIStatus('‚úì Pasted from clipboard', 'success');
  } catch (e) {
    updateAIStatus('Cannot access clipboard', 'error');
  }
}

function formatJSON() {
  const textarea = document.getElementById('json-editor-textarea');
  try {
    const data = JSON.parse(textarea.value);
    textarea.value = JSON.stringify(data, null, 2);
    updateAIStatus('‚úì JSON formatted', 'success');
  } catch (e) {
    updateAIStatus('Invalid JSON', 'error');
  }
}

// ============ SETTINGS ============
function openSettingsModal() {
  document.getElementById('settings-modal').classList.add('active');
}

function closeSettingsModal() {
  document.getElementById('settings-modal').classList.remove('active');
}

function saveSettings() {
  const apiKey = document.getElementById('gemini-api-key').value.trim();
  const model = document.getElementById('ai-model').value.trim() || 'gemini-2.0-flash';
  const prompt = document.getElementById('ai-system-prompt').value.trim();
  
  localStorage.setItem('gemini_api_key', apiKey);
  localStorage.setItem('ai_model', model);
  localStorage.setItem('ai_system_prompt', prompt);
  
  closeSettingsModal();
  updateAIStatus(apiKey ? '‚úì Settings saved' : '‚ö†Ô∏è No API key set', apiKey ? 'success' : 'warning');
}

function loadSettings() {
  document.getElementById('gemini-api-key').value = localStorage.getItem('gemini_api_key') || '';
  document.getElementById('ai-model').value = localStorage.getItem('ai_model') || 'gemini-2.0-flash';
  document.getElementById('ai-system-prompt').value = localStorage.getItem('ai_system_prompt') || DEFAULT_SYSTEM_PROMPT;
  
  const hasKey = !!localStorage.getItem('gemini_api_key');
  updateAIStatus(hasKey ? '‚úì API key configured' : '‚ö†Ô∏è Set API key in Settings', hasKey ? 'success' : 'warning');
}

function resetSystemPrompt() {
  document.getElementById('ai-system-prompt').value = DEFAULT_SYSTEM_PROMPT;
}

// ============ FILE OPERATIONS ============
function newDiagram() {
  if (confirm('Create new diagram? Current data will be cleared.')) {
    document.getElementById('data-table-body').innerHTML = '';
    document.getElementById('flows_in').value = '';
    document.getElementById('diagram-title-input').value = 'My Sankey Diagram';
    nodeColors = {};
    nodeCustomizations = {};
    labelPositions = {};
    addDataRowWithValues('', '', '', '');
    renderDiagram();
  }
}

function resetAllNodes() {
  if (typeof resetMovesAndRender === 'function') resetMovesAndRender();
  else if (window.resetMovesAndRender) window.resetMovesAndRender();
}

function resetAllLabels() {
  labelPositions = {};
  if (typeof resetLabelMovesAndRender === 'function') resetLabelMovesAndRender();
  else if (window.resetLabelMovesAndRender) window.resetLabelMovesAndRender();
  else renderDiagram();
}

function exportCSV() {
  const tbody = document.getElementById('data-table-body');
  const rows = tbody.querySelectorAll('tr');
  let csv = 'From,To,Amount,Comparison\n';
  rows.forEach(row => {
    const inputs = row.querySelectorAll('input');
    csv += `"${inputs[0].value}","${inputs[1].value}","${inputs[2].value}","${inputs[3]?.value || ''}"\n`;
  });
  
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'sankey_data.csv';
  a.click();
}

function importCSV(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = function(e) {
    const lines = e.target.result.split('\n');
    document.getElementById('data-table-body').innerHTML = '';
    
    lines.forEach((line, i) => {
      if (i === 0 && line.toLowerCase().includes('from')) return;
      const parts = line.split(',').map(p => p.replace(/"/g, '').trim());
      if (parts.length >= 3 && parts[0] && parts[1]) {
        addDataRowWithValues(parts[0], parts[1], parts[2] || '0', parts[3] || '');
      }
    });
    
    updateDiagramFromTable();
  };
  reader.readAsText(file);
  event.target.value = '';
}
</script>

<script>
// ============ ZOOM CONTROLS ============
// Uses ViewportController for proper SVG-based zoom with center point preservation
// Requirements: 1.2, 1.3, 1.4

function zoomCanvas(delta) {
  // Use ViewportController if available, otherwise fall back to CSS transform
  if (typeof ViewportController !== 'undefined' && ViewportController.isInitialized()) {
    if (delta > 0) {
      ViewportController.zoomIn();
    } else {
      ViewportController.zoomOut();
    }
  } else {
    // Fallback to CSS transform for backward compatibility
    currentZoom = Math.max(0.25, Math.min(3, currentZoom + delta));
    document.getElementById('chart').style.transform = `scale(${currentZoom})`;
    document.getElementById('zoom-level').textContent = Math.round(currentZoom * 100) + '%';
  }
}

function resetZoom() {
  // Use ViewportController if available
  if (typeof ViewportController !== 'undefined' && ViewportController.isInitialized()) {
    ViewportController.reset();
  } else {
    // Fallback to CSS transform
    currentZoom = 1.0;
    document.getElementById('chart').style.transform = 'scale(1)';
    document.getElementById('zoom-level').textContent = '100%';
  }
}

function fitToScreen() {
  // Fit diagram to screen using ViewportController
  if (typeof ViewportController !== 'undefined' && ViewportController.isInitialized()) {
    ViewportController.fitToScreen();
  }
}

// ============ UNDO FUNCTIONALITY ============
function saveStateForUndo() {
  const flowsEl = document.getElementById('flows_in');
  const tbodyEl = document.getElementById('data-table-body');
  if (!flowsEl || !tbodyEl) return;
  
  // Capture canvas state (node and label positions) from sankeymatic.js globals
  let nodeMoves = {};
  let labelMoves = {};
  
  // Access glob through window (sankeymatic.js exposes it)
  if (window.rememberedMoves && window.rememberedMoves.size) {
    window.rememberedMoves.forEach((val, key) => { nodeMoves[key] = val; });
  }
  if (window.rememberedLabelMoves && window.rememberedLabelMoves.size) {
    window.rememberedLabelMoves.forEach((val, key) => { labelMoves[key] = val; });
  }
  
  const currentState = {
    flows: flowsEl.value,
    tableHtml: tbodyEl.innerHTML,
    nodeMoves: nodeMoves,
    labelMoves: labelMoves,
    nodeCustomizations: JSON.parse(JSON.stringify(nodeCustomizations)),
    nodeColors: JSON.parse(JSON.stringify(nodeColors)),
    customLayout: JSON.parse(JSON.stringify(customLayout)),
    timestamp: Date.now()
  };
  
  // Only save if something changed
  if (lastSavedState && lastSavedState.flows === currentState.flows && 
      JSON.stringify(lastSavedState.nodeMoves) === JSON.stringify(currentState.nodeMoves) &&
      JSON.stringify(lastSavedState.labelMoves) === JSON.stringify(currentState.labelMoves) &&
      JSON.stringify(lastSavedState.customLayout) === JSON.stringify(currentState.customLayout)) {
    return;
  }
  
  undoStack.push(currentState);
  lastSavedState = currentState;
  if (undoStack.length > MAX_UNDO) undoStack.shift();
}

function undoLastAction() {
  if (undoStack.length <= 1) {
    updateAIStatus('Nothing to undo', 'warning');
    return;
  }
  
  // Move current state to redo stack
  const currentState = undoStack.pop();
  if (!window.redoStack) window.redoStack = [];
  window.redoStack.push(currentState);
  
  const state = undoStack[undoStack.length - 1];
  
  const flowsEl = document.getElementById('flows_in');
  const tbodyEl = document.getElementById('data-table-body');
  if (flowsEl) flowsEl.value = state.flows;
  if (tbodyEl) tbodyEl.innerHTML = state.tableHtml;
  
  // Restore canvas state (node and label positions)
  if (window.rememberedMoves) {
    window.rememberedMoves.clear();
    if (state.nodeMoves) {
      Object.entries(state.nodeMoves).forEach(([key, val]) => {
        window.rememberedMoves.set(key, val);
      });
    }
  }
  if (window.rememberedLabelMoves) {
    window.rememberedLabelMoves.clear();
    if (state.labelMoves) {
      Object.entries(state.labelMoves).forEach(([key, val]) => {
        window.rememberedLabelMoves.set(key, val);
      });
    }
  }
  
  // Restore customizations
  if (state.nodeCustomizations) nodeCustomizations = JSON.parse(JSON.stringify(state.nodeCustomizations));
  if (state.nodeColors) nodeColors = JSON.parse(JSON.stringify(state.nodeColors));
  if (state.customLayout) customLayout = JSON.parse(JSON.stringify(state.customLayout));
  
  lastSavedState = state;
  renderDiagram();
  updateAIStatus('‚Ü©Ô∏è Undone', 'success');
}

function redoLastAction() {
  if (!window.redoStack || window.redoStack.length === 0) {
    updateAIStatus('Nothing to redo', 'warning');
    return;
  }
  
  const state = window.redoStack.pop();
  undoStack.push(state);
  
  const flowsEl = document.getElementById('flows_in');
  const tbodyEl = document.getElementById('data-table-body');
  if (flowsEl) flowsEl.value = state.flows;
  if (tbodyEl) tbodyEl.innerHTML = state.tableHtml;
  
  // Restore canvas state (node and label positions)
  if (window.rememberedMoves) {
    window.rememberedMoves.clear();
    if (state.nodeMoves) {
      Object.entries(state.nodeMoves).forEach(([key, val]) => {
        window.rememberedMoves.set(key, val);
      });
    }
  }
  if (window.rememberedLabelMoves) {
    window.rememberedLabelMoves.clear();
    if (state.labelMoves) {
      Object.entries(state.labelMoves).forEach(([key, val]) => {
        window.rememberedLabelMoves.set(key, val);
      });
    }
  }
  
  // Restore customizations
  if (state.nodeCustomizations) nodeCustomizations = JSON.parse(JSON.stringify(state.nodeCustomizations));
  if (state.nodeColors) nodeColors = JSON.parse(JSON.stringify(state.nodeColors));
  if (state.customLayout) customLayout = JSON.parse(JSON.stringify(state.customLayout));
  
  lastSavedState = state;
  renderDiagram();
  updateAIStatus('‚Ü™Ô∏è Redone', 'success');
}

// ============ STATUS ============
function updateStatus(rowCount) {
  const bar = document.getElementById('status-bar');
  const msg = document.getElementById('status-message');
  
  if (rowCount === 0) {
    bar.className = 'status-bar warning';
    msg.textContent = 'No valid flows - add data to create diagram';
    return;
  }
  
  const imbalanced = checkNodeBalance();
  if (imbalanced.length > 0) {
    bar.className = 'status-bar warning';
    const nodeList = imbalanced.map(n => `${n.node} (${n.diff > 0 ? '+' : ''}${n.diff.toFixed(2)})`).join(', ');
    msg.textContent = `‚ö†Ô∏è ${rowCount} flows ‚Ä¢ Imbalanced: ${nodeList}`;
  } else {
    bar.className = 'status-bar';
    msg.textContent = `‚úì ${rowCount} flows ‚Ä¢ All nodes balanced`;
  }
}

function checkNodeBalance() {
  const tbody = document.getElementById('data-table-body');
  const rows = tbody.querySelectorAll('tr');
  const nodeIn = {}, nodeOut = {};
  
  rows.forEach(row => {
    const inputs = row.querySelectorAll('input');
    const from = inputs[0].value.trim();
    const to = inputs[1].value.trim();
    const amount = parseFloat(inputs[2].value) || 0;
    
    if (from && to && amount > 0) {
      nodeOut[from] = (nodeOut[from] || 0) + amount;
      nodeIn[to] = (nodeIn[to] || 0) + amount;
    }
  });
  
  const allNodes = new Set([...Object.keys(nodeIn), ...Object.keys(nodeOut)]);
  const imbalanced = [];
  
  allNodes.forEach(node => {
    const inFlow = nodeIn[node] || 0;
    const outFlow = nodeOut[node] || 0;
    if (inFlow > 0 && outFlow > 0 && Math.abs(inFlow - outFlow) > 0.01) {
      imbalanced.push({ node, inFlow, outFlow, diff: inFlow - outFlow });
    }
  });
  
  return imbalanced;
}

// ============ SAVE/LOAD PROGRESS ============
const STORAGE_KEY = 'sankey_diagram_progress';

function saveProgressToLocal() {
  const progress = {
    title: document.getElementById('diagram-title-input').value,
    flows: document.getElementById('flows_in').value,
    tableData: getTableData(),
    options: getOptionsState(),
    labelPositions,
    nodeColors,
    nodeCustomizations,
    customLayout,
    zoom: currentZoom,
    savedAt: new Date().toISOString()
  };
  localStorage.setItem(STORAGE_KEY, JSON.stringify(progress));
}

function loadProgressFromLocal() {
  const saved = localStorage.getItem(STORAGE_KEY);
  if (!saved) return false;
  
  try {
    const progress = JSON.parse(saved);
    
    if (progress.title) document.getElementById('diagram-title-input').value = progress.title;
    if (progress.flows) document.getElementById('flows_in').value = progress.flows;
    
    if (progress.tableData && progress.tableData.length > 0) {
      const tbody = document.getElementById('data-table-body');
      tbody.innerHTML = '';
      progress.tableData.forEach(row => {
        addDataRowWithValues(row.from, row.to, row.amount, row.comparison);
      });
    }
    
    if (progress.options) restoreOptionsState(progress.options);
    if (progress.labelPositions) labelPositions = progress.labelPositions;
    
    // Clean up corrupted nodeColors keys
    if (progress.nodeColors) {
      const cleanedColors = {};
      Object.keys(progress.nodeColors).forEach(key => {
        const numberPattern = /(\d{1,3}(?:,\d{3})*(?:\.\d+)?)\1/;
        if (!numberPattern.test(key)) {
          cleanedColors[key] = progress.nodeColors[key];
        } else {
          console.warn('Removed corrupted nodeColors key:', key);
        }
      });
      nodeColors = cleanedColors;
    }
    
    // Clean up corrupted nodeCustomizations keys (keys with duplicate numbers like "Budget1,7501,750")
    if (progress.nodeCustomizations) {
      const cleanedCustomizations = {};
      Object.keys(progress.nodeCustomizations).forEach(key => {
        // Check if key looks corrupted (contains repeated number patterns)
        // A corrupted key would have patterns like "1,7501,750" or "250250"
        const numberPattern = /(\d{1,3}(?:,\d{3})*(?:\.\d+)?)\1/;
        if (!numberPattern.test(key)) {
          cleanedCustomizations[key] = progress.nodeCustomizations[key];
        } else {
          console.warn('Removed corrupted nodeCustomizations key:', key);
        }
      });
      nodeCustomizations = cleanedCustomizations;
    }
    
    // Clean up corrupted customLayout keys as well
    if (progress.customLayout) {
      const cleanedLayout = {};
      Object.keys(progress.customLayout).forEach(key => {
        const numberPattern = /(\d{1,3}(?:,\d{3})*(?:\.\d+)?)\1/;
        if (!numberPattern.test(key)) {
          cleanedLayout[key] = progress.customLayout[key];
        } else {
          console.warn('Removed corrupted customLayout key:', key);
        }
      });
      customLayout = cleanedLayout;
    }
    
    if (progress.zoom) {
      currentZoom = progress.zoom;
      document.getElementById('chart').style.transform = `scale(${currentZoom})`;
      document.getElementById('zoom-level').textContent = Math.round(currentZoom * 100) + '%';
    }
    
    return true;
  } catch (e) {
    console.error('Failed to load progress:', e);
    return false;
  }
}

function getTableData() {
  const tbody = document.getElementById('data-table-body');
  const rows = tbody.querySelectorAll('tr');
  const data = [];
  rows.forEach(row => {
    const inputs = row.querySelectorAll('input');
    data.push({
      from: inputs[0].value,
      to: inputs[1].value,
      amount: inputs[2].value,
      comparison: inputs[3]?.value || ''
    });
  });
  return data;
}

function getOptionsState() {
  const options = {};
  const optionIds = [
    'opt_labelname_appears', 'opt_labelvalue_appears', 'opt_labels_comparisonline',
    'opt_labelname_size', 'opt_labels_color', 'opt_labels_fontface', 'opt_labels_googlefont',
    'opt_labels_decimalplaces', 'opt_value_prefix', 'opt_value_suffix',
    'opt_node_w', 'opt_node_h', 'opt_node_spacing', 'opt_node_border', 'opt_node_opacity',
    'opt_node_theme', 'opt_node_color',
    'opt_flow_opacity', 'opt_flow_curvature', 'opt_flow_color',
    'opt_size_w', 'opt_size_h',
    'opt_margin_l', 'opt_margin_r', 'opt_margin_t', 'opt_margin_b',
    'opt_bg_color', 'opt_bg_transparent'
  ];
  
  optionIds.forEach(id => {
    const el = document.getElementById(id);
    if (el) options[id] = el.type === 'checkbox' ? el.checked : el.value;
  });
  
  ['opt_flow_outside_in', 'opt_flow_source', 'opt_flow_target', 'opt_flow_single',
   'opt_layout_automatic', 'opt_layout_exact'].forEach(id => {
    const el = document.getElementById(id);
    if (el) options[id] = el.checked;
  });
  
  return options;
}

function restoreOptionsState(options) {
  for (const [id, value] of Object.entries(options)) {
    const el = document.getElementById(id);
    if (el) {
      if (el.type === 'checkbox' || el.type === 'radio') el.checked = value;
      else el.value = value;
    }
  }
}

function setupAutoSave() {
  document.getElementById('diagram-title-input').addEventListener('change', saveProgressToLocal);
  setInterval(saveProgressToLocal, 30000);
  window.addEventListener('beforeunload', saveProgressToLocal);
}
</script>

<script>
// ============ INITIALIZATION ============

// Toggle data panel expand/collapse
let dataPanelCollapsed = false;

function toggleDataPanel() {
  const rightPanel = document.querySelector('.right-panel');
  const toggleIcon = document.getElementById('toggle-panel-icon');
  
  if (!rightPanel) return;
  
  dataPanelCollapsed = !dataPanelCollapsed;
  
  if (dataPanelCollapsed) {
    rightPanel.style.width = '50px';
    rightPanel.style.minWidth = '50px';
    rightPanel.classList.add('collapsed');
    if (toggleIcon) toggleIcon.textContent = '‚ñ∂';
  } else {
    rightPanel.style.width = '480px';
    rightPanel.style.minWidth = '480px';
    rightPanel.classList.remove('collapsed');
    if (toggleIcon) toggleIcon.textContent = '‚óÄ';
  }
}

// Tab switching for data panel
function initDataPanelTabs() {
  const tabs = document.querySelectorAll('.studio-data-tab');
  const contents = document.querySelectorAll('.studio-data-tab-content');
  
  tabs.forEach(tab => {
    tab.addEventListener('click', function() {
      const targetTab = this.getAttribute('data-tab');
      
      // Update tab active states
      tabs.forEach(t => t.classList.remove('active'));
      this.classList.add('active');
      
      // Update content visibility
      contents.forEach(content => {
        if (content.getAttribute('data-tab-content') === targetTab) {
          content.classList.add('active');
        } else {
          content.classList.remove('active');
        }
      });
    });
  });
}

document.addEventListener('DOMContentLoaded', function() {
  loadSettings();
  
  // Initialize data panel tabs
  initDataPanelTabs();
  
  // Add event listener for label background opacity slider
  const bgOpacitySlider = document.getElementById('popup-label-bg-opacity');
  const bgOpacityValue = document.getElementById('popup-label-bg-opacity-value');
  if (bgOpacitySlider && bgOpacityValue) {
    bgOpacitySlider.addEventListener('input', function() {
      bgOpacityValue.textContent = this.value + '%';
    });
  }
  
  const hasProgress = loadProgressFromLocal();
  if (!hasProgress) {
    initializeDataTable();
  }
  
  setupAutoSave();
  
  // Initialize ToolbarController
  const toolbarEl = document.getElementById('studio-toolbar');
  const diagramAreaEl = document.getElementById('diagram-area');
  if (typeof ToolbarController !== 'undefined' && toolbarEl) {
    ToolbarController.init(toolbarEl, diagramAreaEl);
  }
  
  // Wait for sankeymatic.js to load, then render
  setTimeout(() => {
    renderDiagram();
    saveStateForUndo();
    // Initial setup of handlers
    setTimeout(() => {
      setupNodeClickHandlers();
      applyLabelPositions();
    }, 300);
  }, 500);
  
  // Re-init handlers after each render
  const observer = new MutationObserver(function(mutations) {
    // Skip if we're currently applying label customizations
    if (window._applyingLabelCustomizations) return;
    
    // Debounce to avoid multiple calls
    clearTimeout(window.svgUpdateTimeout);
    window.svgUpdateTimeout = setTimeout(() => {
      // Double-check the flag before executing
      if (window._applyingLabelCustomizations) return;
      
      setupNodeClickHandlers();
      applyLabelPositions();
    }, 150);
  });
  
  const chartEl = document.getElementById('chart');
  if (chartEl) {
    observer.observe(chartEl, { childList: true, subtree: true });
  }
  
  // Mouse wheel zoom on canvas (Ctrl+Scroll)
  // Requirement 1.3: Zoom centered on mouse position
  const diagramArea = document.getElementById('diagram-area');
  if (diagramArea) {
    diagramArea.addEventListener('wheel', function(e) {
      if (e.ctrlKey) {
        e.preventDefault();
        const delta = e.deltaY > 0 ? -0.1 : 0.1;
        
        // Use ViewportController with center point if available
        if (typeof ViewportController !== 'undefined' && ViewportController.isInitialized()) {
          ViewportController.zoom(delta, e.clientX, e.clientY);
        } else {
          zoomCanvas(delta);
        }
      }
    }, { passive: false });
    
    // Middle-click/spacebar+drag pan handler (Requirement 1.2)
    let isPanning = false;
    let panStartX = 0;
    let panStartY = 0;
    let spacebarHeld = false;
    
    // Track spacebar state and tool switching keyboard shortcuts
    document.addEventListener('keydown', function(e) {
      // Skip if typing in input fields
      if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
        return;
      }
      
      // Spacebar for pan mode
      if (e.code === 'Space' && !e.repeat) {
        spacebarHeld = true;
        diagramArea.classList.add('viewport-pan-mode');
      }
      
      // Tool switching shortcuts (Requirements 10.5)
      if (typeof ToolbarController !== 'undefined' && ToolbarController.isInitialized()) {
        switch (e.key.toLowerCase()) {
          case 'v': // Select tool
            ToolbarController.setTool('select');
            break;
          case 'h': // Pan tool (Hand)
            ToolbarController.setTool('pan');
            break;
          case 'n': // Add Node tool
            ToolbarController.setTool('addNode');
            break;
          case 'f': // Add Flow tool
            ToolbarController.setTool('addFlow');
            break;
          case 'escape': // Deselect / cancel
            if (typeof SelectionManager !== 'undefined') {
              SelectionManager.deselect();
            }
            ToolbarController.setTool('select');
            break;
        }
      }
      
      // Undo/Redo shortcuts
      if (e.ctrlKey || e.metaKey) {
        if (e.key === 'z' && !e.shiftKey) {
          e.preventDefault();
          if (typeof undoLastAction === 'function') {
            undoLastAction();
          }
        } else if ((e.key === 'y') || (e.key === 'z' && e.shiftKey)) {
          e.preventDefault();
          if (typeof redoLastAction === 'function') {
            redoLastAction();
          }
        }
      }
    });
    
    document.addEventListener('keyup', function(e) {
      if (e.code === 'Space') {
        spacebarHeld = false;
        diagramArea.classList.remove('viewport-pan-mode');
        isPanning = false;
      }
    });
    
    // Pan with middle mouse button, spacebar+drag, or Pan tool active
    // Requirement 10.2: Pan tool enables viewport panning on drag
    diagramArea.addEventListener('mousedown', function(e) {
      // Check if Pan tool is active
      const panToolActive = typeof ToolbarController !== 'undefined' && ToolbarController.isPanningEnabled();
      
      // Middle mouse button (button 1), spacebar+left click, or Pan tool + left click
      if (e.button === 1 || (spacebarHeld && e.button === 0) || (panToolActive && e.button === 0)) {
        e.preventDefault();
        isPanning = true;
        panStartX = e.clientX;
        panStartY = e.clientY;
        diagramArea.classList.add('viewport-pan-mode');
        
        // Update cursor to grabbing when actively panning
        if (panToolActive) {
          diagramArea.style.cursor = 'grabbing';
        }
        
        if (typeof StudioUI !== 'undefined') {
          StudioUI.startInteraction('panning');
        }
      }
    });
    
    document.addEventListener('mousemove', function(e) {
      if (isPanning) {
        const dx = e.clientX - panStartX;
        const dy = e.clientY - panStartY;
        panStartX = e.clientX;
        panStartY = e.clientY;
        
        if (typeof ViewportController !== 'undefined' && ViewportController.isInitialized()) {
          ViewportController.pan(dx, dy);
        }
      }
    });
    
    document.addEventListener('mouseup', function(e) {
      if (isPanning) {
        isPanning = false;
        if (!spacebarHeld) {
          diagramArea.classList.remove('viewport-pan-mode');
        }
        
        // Restore cursor for Pan tool
        const panToolActive = typeof ToolbarController !== 'undefined' && ToolbarController.isPanningEnabled();
        if (panToolActive) {
          diagramArea.style.cursor = 'grab';
        }
        
        if (typeof StudioUI !== 'undefined') {
          StudioUI.endInteraction();
        }
      }
    });
    // Add Node tool click handler (Requirement 10.3)
    diagramArea.addEventListener('click', function(e) {
      // Only handle if Add Node tool is active
      if (typeof ToolbarController === 'undefined' || !ToolbarController.isToolActive('addNode')) {
        return;
      }
      
      // Don't trigger on node/flow/label clicks (they have stopPropagation)
      // Only trigger on canvas background clicks
      const target = e.target;
      if (target.closest('.sankey-node') || 
          target.closest('.sankey-label') || 
          target.closest('path[data-source]')) {
        return;
      }
      
      // Convert screen coordinates to diagram coordinates
      let diagramCoords = { x: e.offsetX, y: e.offsetY };
      if (typeof ViewportController !== 'undefined' && ViewportController.isInitialized()) {
        diagramCoords = ViewportController.screenToDiagram(e.clientX, e.clientY);
      }
      
      // Handle the click
      ToolbarController.handleCanvasClick(e, diagramCoords);
    });
  }
  
  // Note: Label dragging is handled by sankeymatic.js D3 drag behavior
  // No additional global handlers needed
  
  // Close popup when clicking outside
  document.getElementById('node-popup-overlay').addEventListener('click', function(e) {
    if (e.target === this) closeNodePopup();
  });
  
  // Keyboard shortcuts
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
      closeNodePopup();
      closeJSONEditor();
      closeSettingsModal();
    }
    if (e.ctrlKey && e.key === 'z') {
      e.preventDefault();
      undoLastAction();
    }
  });
});
</script>
</body>
</html>
